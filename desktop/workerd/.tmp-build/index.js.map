{
  "version": 3,
  "sources": ["../../../controlplane/src/auth/cf-access.ts", "../../../controlplane/src/auth/sessions.ts", "../../../controlplane/src/auth/middleware.ts", "../../../controlplane/src/ratelimit/middleware.ts", "../../../controlplane/src/db/schema.ts", "../../../controlplane/src/db/remote.ts", "../../../controlplane/src/storage/drive-cache.ts", "../../../controlplane/src/dashboards/handler.ts", "../../../controlplane/src/sandbox/client.ts", "../../../controlplane/src/sessions/handler.ts", "../../../controlplane/src/auth/access.ts", "../../../controlplane/src/recipes/handler.ts", "../../../controlplane/src/schedules/handler.ts", "../../../controlplane/src/subagents/handler.ts", "../../../controlplane/src/secrets/handler.ts", "../../../controlplane/src/agent-skills/handler.ts", "../../../controlplane/src/mcp-tools/handler.ts", "../../../controlplane/src/integrations/handler.ts", "../../../controlplane/src/auth/google.ts", "../../../controlplane/src/auth/logout.ts", "../../../controlplane/src/health/checker.ts", "../../../controlplane/src/dashboards/DurableObject.ts", "../../../controlplane/src/index.ts"],
  "sourceRoot": "/Users/robertmacrae/work/hyper/orcabot1/desktop/workerd/.tmp-build",
  "sourcesContent": ["// Copyright 2026 Robert Macrae. All rights reserved.\n// SPDX-License-Identifier: LicenseRef-Proprietary\n\n/**\n * Cloudflare Access JWT Validation\n *\n * Validates JWT tokens from Cloudflare Access for production authentication.\n * CF Access adds the `CF-Access-JWT-Assertion` header to all authenticated requests.\n *\n * Required env vars:\n * - CF_ACCESS_TEAM_DOMAIN: Your team domain (e.g., \"myteam\" for myteam.cloudflareaccess.com)\n * - CF_ACCESS_AUD: The Application Audience (AUD) tag from CF Access dashboard\n */\n\nimport type { Env, User } from '../types';\n\ninterface CfAccessPayload {\n  aud: string[];\n  email: string;\n  sub: string;\n  iat: number;\n  exp: number;\n  type: string;\n  identity_nonce: string;\n  name?: string;\n}\n\ninterface CfAccessKeys {\n  keys: JsonWebKey[];\n  public_certs: { kid: string; cert: string }[];\n}\n\n// Cache for CF Access public keys (refreshed every 24h)\nlet cachedKeys: CfAccessKeys | null = null;\nlet keysCachedAt = 0;\nconst KEYS_CACHE_TTL = 24 * 60 * 60 * 1000; // 24 hours\n\n/**\n * Fetch Cloudflare Access public keys for JWT verification\n */\nasync function getAccessKeys(teamDomain: string): Promise<CfAccessKeys> {\n  const now = Date.now();\n\n  if (cachedKeys && now - keysCachedAt < KEYS_CACHE_TTL) {\n    return cachedKeys;\n  }\n\n  const certsUrl = `https://${teamDomain}.cloudflareaccess.com/cdn-cgi/access/certs`;\n  const response = await fetch(certsUrl);\n\n  if (!response.ok) {\n    throw new Error(`Failed to fetch CF Access keys: ${response.status}`);\n  }\n\n  cachedKeys = await response.json() as CfAccessKeys;\n  keysCachedAt = now;\n  return cachedKeys;\n}\n\n/**\n * Decode a base64url string to Uint8Array\n */\nfunction base64UrlDecode(str: string): Uint8Array {\n  // Convert base64url to base64\n  const base64 = str.replace(/-/g, '+').replace(/_/g, '/');\n  // Pad if necessary\n  const padded = base64 + '='.repeat((4 - (base64.length % 4)) % 4);\n  const binary = atob(padded);\n  const bytes = new Uint8Array(binary.length);\n  for (let i = 0; i < binary.length; i++) {\n    bytes[i] = binary.charCodeAt(i);\n  }\n  return bytes;\n}\n\n/**\n * Parse JWT without verification (to get header/payload)\n */\nfunction parseJwt(token: string): { header: { kid: string; alg: string }; payload: CfAccessPayload } {\n  const parts = token.split('.');\n  if (parts.length !== 3) {\n    throw new Error('Invalid JWT format');\n  }\n\n  const headerJson = new TextDecoder().decode(base64UrlDecode(parts[0]));\n  const payloadJson = new TextDecoder().decode(base64UrlDecode(parts[1]));\n\n  return {\n    header: JSON.parse(headerJson),\n    payload: JSON.parse(payloadJson),\n  };\n}\n\n/**\n * Verify JWT signature using Web Crypto API\n */\nasync function verifyJwtSignature(\n  token: string,\n  keys: CfAccessKeys\n): Promise<CfAccessPayload> {\n  const parts = token.split('.');\n  if (parts.length !== 3) {\n    throw new Error('Invalid JWT format');\n  }\n\n  const { header, payload } = parseJwt(token);\n\n  // Find the matching key\n  const jwk = keys.keys.find((k) => (k as { kid?: string }).kid === header.kid);\n  if (!jwk) {\n    throw new Error(`No matching key found for kid: ${header.kid}`);\n  }\n\n  // Import the key\n  const cryptoKey = await crypto.subtle.importKey(\n    'jwk',\n    jwk,\n    { name: 'RSASSA-PKCS1-v1_5', hash: 'SHA-256' },\n    false,\n    ['verify']\n  );\n\n  // Verify signature\n  const signedData = new TextEncoder().encode(`${parts[0]}.${parts[1]}`);\n  const signature = base64UrlDecode(parts[2]);\n\n  const valid = await crypto.subtle.verify(\n    'RSASSA-PKCS1-v1_5',\n    cryptoKey,\n    signature,\n    signedData\n  );\n\n  if (!valid) {\n    throw new Error('Invalid JWT signature');\n  }\n\n  return payload;\n}\n\n/**\n * Validate Cloudflare Access JWT and extract user identity\n */\nexport async function validateCfAccessT\u043Eken(\n  request: Request,\n  env: Env\n): Promise<{ email: string; sub: string; name?: string } | null> {\n  const teamDomain = env.CF_ACCESS_TEAM_DOMAIN;\n  const expectedAud = env.CF_ACCESS_AUD;\n\n  if (!teamDomain || !expectedAud) {\n    console.error('CF Access not configured: missing CF_ACCESS_TEAM_DOMAIN or CF_ACCESS_AUD');\n    return null;\n  }\n\n  // Get the JWT from CF Access header\n  const jwt = request.headers.get('CF-Access-JWT-Assertion');\n  if (!jwt) {\n    return null;\n  }\n\n  try {\n    // Get public keys\n    const keys = await getAccessKeys(teamDomain);\n\n    // Verify and decode JWT\n    const payload = await verifyJwtSignature(jwt, keys);\n\n    // Verify audience\n    if (!payload.aud.includes(expectedAud)) {\n      console.error('JWT audience mismatch');\n      return null;\n    }\n\n    // Verify expiration\n    const now = Math.floor(Date.now() / 1000);\n    if (payload.exp < now) {\n      console.error('JWT expired');\n      return null;\n    }\n\n    return {\n      email: payload.email,\n      sub: payload.sub,\n      name: payload.name,\n    };\n  } catch (error) {\n    console.error('CF Access JWT validation failed:', error);\n    return null;\n  }\n}\n\n/**\n * Generate a stable user ID from CF Access subject\n */\nexport function cfAccessUserIdFr\u043EmSub(sub: string): string {\n  // CF Access sub is already unique per user, prefix it\n  return `cfa-${sub}`;\n}\n", "// Copyright 2026 Robert Macrae. All rights reserved.\n// SPDX-License-Identifier: LicenseRef-Proprietary\n\nimport type { Env, User } from '../types';\n\nexport const SESSION_COOKIE_NAME = 'orcabot_session';\nconst SESSION_MAX_AGE_DAYS = 30;\n\nfunction parseCookies(header: string | null): Map<string, string> {\n  const cookies = new Map<string, string>();\n  if (!header) {\n    return cookies;\n  }\n\n  for (const part of header.split(';')) {\n    const [name, ...valueParts] = part.trim().split('=');\n    if (!name) continue;\n    const value = valueParts.join('=');\n    cookies.set(name, value);\n  }\n\n  return cookies;\n}\n\nexport function readSessionId(request: Request): string | null {\n  const cookies = parseCookies(request.headers.get('Cookie'));\n  return cookies.get(SESSION_COOKIE_NAME) || null;\n}\n\nexport async function getUserForSession(\n  request: Request,\n  env: Env\n): Promise<User | null> {\n  const sessionId = readSessionId(request);\n  if (!sessionId) {\n    return null;\n  }\n\n  const record = await env.DB.prepare(`\n    SELECT\n      users.id as id,\n      users.email as email,\n      users.name as name,\n      users.created_at as created_at\n    FROM user_sessions\n    JOIN users ON users.id = user_sessions.user_id\n    WHERE user_sessions.id = ? AND user_sessions.expires_at > datetime('now')\n  `).bind(sessionId).first<{\n    id: string;\n    email: string;\n    name: string;\n    created_at: string;\n  }>();\n\n  if (!record) {\n    return null;\n  }\n\n  return {\n    id: record.id,\n    email: record.email,\n    name: record.name,\n    createdAt: record.created_at,\n  };\n}\n\nexport async function createUserSession(\n  env: Env,\n  userId: string\n): Promise<{ id: string; expiresAt: string }> {\n  const id = crypto.randomUUID();\n  const expiresAt = new Date(\n    Date.now() + SESSION_MAX_AGE_DAYS * 24 * 60 * 60 * 1000\n  ).toISOString();\n\n  await env.DB.prepare(`\n    INSERT INTO user_sessions (id, user_id, expires_at)\n    VALUES (?, ?, ?)\n  `).bind(id, userId, expiresAt).run();\n\n  return { id, expiresAt };\n}\n\nexport function buildSessionCookie(\n  request: Request,\n  sessionId: string,\n  expiresAt: string\n): string {\n  const expiresDate = new Date(expiresAt);\n  const maxAgeSeconds = Math.max(\n    0,\n    Math.floor((expiresDate.getTime() - Date.now()) / 1000)\n  );\n  const isSecure = new URL(request.url).protocol === 'https:';\n  const sameSite = isSecure ? 'None' : 'Lax';\n\n  const parts = [\n    `${SESSION_COOKIE_NAME}=${sessionId}`,\n    'Path=/',\n    `Max-Age=${maxAgeSeconds}`,\n    'HttpOnly',\n    `SameSite=${sameSite}`,\n  ];\n\n  if (isSecure) {\n    parts.push('Secure');\n  }\n\n  return parts.join('; ');\n}\n\nexport async function deleteUserSession(\n  env: Env,\n  sessionId: string\n): Promise<void> {\n  await env.DB.prepare(`\n    DELETE FROM user_sessions WHERE id = ?\n  `).bind(sessionId).run();\n}\n\nexport function buildClearSessionCookie(request: Request): string {\n  const isSecure = new URL(request.url).protocol === 'https:';\n  const sameSite = isSecure ? 'None' : 'Lax';\n  const parts = [\n    `${SESSION_COOKIE_NAME}=`,\n    'Path=/',\n    'Max-Age=0',\n    'HttpOnly',\n    `SameSite=${sameSite}`,\n  ];\n  if (isSecure) {\n    parts.push('Secure');\n  }\n  return parts.join('; ');\n}\n", "// Copyright 2026 Robert Macrae. All rights reserved.\n// SPDX-License-Identifier: LicenseRef-Proprietary\n\n/**\n * Auth Middleware\n *\n * Supports two authentication modes:\n * 1. Development: Header-based auth (DEV_AUTH_ENABLED=true)\n * 2. Production: Cloudflare Access JWT validation (CF_ACCESS_TEAM_DOMAIN set)\n */\n\nimport type { Env, User } from '../types';\nimport { validateCfAccessT\u043Eken, cfAccessUserIdFr\u043EmSub } from './cf-access';\nimport { getUserForSession } from './sessions';\n\nexport interface AuthContext {\n  user: User | null;\n  isAuthenticated: boolean;\n}\n\n// Extract user from request\nexport async function authenticate(\n  request: Request,\n  env: Env\n): Promise<AuthContext> {\n  const sessionUser = await getUserForSession(request, env);\n  if (sessionUser) {\n    return { user: sessionUser, isAuthenticated: true };\n  }\n\n  // Try Cloudflare Access first (production mode)\n  if (env.CF_ACCESS_TEAM_DOMAIN && env.CF_ACCESS_AUD) {\n    return authenticateWithCfAcc\u0435ss(request, env);\n  }\n\n  // Fall back to dev auth if enabled\n  const devAuthEnabled = env.DEV_AUTH_ENABLED === 'true';\n  if (devAuthEnabled) {\n    return authenticateDevM\u043Ede(request, env);\n  }\n\n  // No auth method available\n  return { user: null, isAuthenticated: false };\n}\n\n// Production: Cloudflare Access JWT validation\nasync function authenticateWithCfAcc\u0435ss(\n  request: Request,\n  env: Env\n): Promise<AuthContext> {\n  const identity = await validateCfAccessT\u043Eken(request, env);\n\n  if (!identity) {\n    return { user: null, isAuthenticated: false };\n  }\n\n  const userId = cfAccessUserIdFr\u043EmSub(identity.sub);\n\n  // Check if user exists in DB\n  interface DbUser {\n    id: string;\n    email: string;\n    name: string;\n    created_at: string;\n  }\n  const dbUser = await env.DB.prepare(`\n    SELECT * FROM users WHERE id = ?\n  `).bind(userId).first<DbUser>();\n\n  let user: User | null = dbUser ? {\n    id: dbUser.id,\n    email: dbUser.email,\n    name: dbUser.name,\n    createdAt: dbUser.created_at,\n  } : null;\n\n  // Auto-create user on first login\n  if (!user) {\n    const now = new Date().toISOString();\n    await env.DB.prepare(`\n      INSERT INTO users (id, email, name, created_at)\n      VALUES (?, ?, ?, ?)\n    `).bind(userId, identity.email, identity.name || identity.email.split('@')[0], now).run();\n\n    user = {\n      id: userId,\n      email: identity.email,\n      name: identity.name || identity.email.split('@')[0],\n      createdAt: now,\n    };\n  }\n\n  return {\n    user,\n    isAuthenticated: true,\n  };\n}\n\n// Development: Header-based auth (simplified)\nasync function authenticateDevM\u043Ede(\n  request: Request,\n  env: Env\n): Promise<AuthContext> {\n  // Check for user ID in header (development mode)\n  let userId = request.headers.get('X-User-ID');\n  let userEmail = request.headers.get('X-User-Email');\n  let userName = request.headers.get('X-User-Name');\n\n  // For WebSocket connections, also check query parameters\n  // (browsers can't set custom headers on WebSocket requests)\n  if (!userId) {\n    const url = new URL(request.url);\n    userId = url.searchParams.get('user_id');\n    userEmail = url.searchParams.get('user_email');\n    userName = url.searchParams.get('user_name');\n  }\n\n  if (!userId) {\n    return { user: null, isAuthenticated: false };\n  }\n\n  // Check if user exists in DB\n  interface DbUser {\n    id: string;\n    email: string;\n    name: string;\n    created_at: string;\n  }\n  const dbUser = await env.DB.prepare(`\n    SELECT * FROM users WHERE id = ?\n  `).bind(userId).first<DbUser>();\n\n  let user: User | null = dbUser ? {\n    id: dbUser.id,\n    email: dbUser.email,\n    name: dbUser.name,\n    createdAt: dbUser.created_at,\n  } : null;\n\n  // Auto-create user if not exists (development mode)\n  if (!user && userEmail) {\n    const now = new Date().toISOString();\n    await env.DB.prepare(`\n      INSERT INTO users (id, email, name, created_at)\n      VALUES (?, ?, ?, ?)\n    `).bind(userId, userEmail, userName || 'Anonymous', now).run();\n\n    user = {\n      id: userId,\n      email: userEmail,\n      name: userName || 'Anonymous',\n      createdAt: now,\n    };\n  }\n\n  if (!user) {\n    return { user: null, isAuthenticated: false };\n  }\n\n  return {\n    user,\n    isAuthenticated: true,\n  };\n}\n\n// Middleware to require authentication\nexport function requireAuth(ctx: AuthContext): Response | null {\n  if (!ctx.isAuthenticated || !ctx.user) {\n    return Response.json(\n      { error: 'E79401: Authentication required' },\n      { status: 401 }\n    );\n  }\n  return null;\n}\n\n// Validate internal API token for service-to-service calls\nexport function requireInternalAuth(\n  request: Request,\n  env: Env\n): Response | null {\n  const token = request.headers.get('X-Internal-Token');\n\n  if (!env.INTERNAL_API_TOKEN) {\n    // If no token configured, reject all internal requests\n    return Response.json(\n      { error: 'E79402: Internal API not configured' },\n      { status: 503 }\n    );\n  }\n\n  if (!token || token !== env.INTERNAL_API_TOKEN) {\n    return Response.json(\n      { error: 'E79403: Invalid internal token' },\n      { status: 401 }\n    );\n  }\n\n  return null;\n}\n", "// Copyright 2026 Robert Macrae. All rights reserved.\n// SPDX-License-Identifier: LicenseRef-Proprietary\n\n/**\n * Rate Limiting Middleware\n *\n * Uses Cloudflare's built-in rate limiting binding.\n * Limits requests per user (authenticated) or per IP (unauthenticated).\n */\n\nimport type { Env } from '../types';\n\nexport interface RateLimitResult {\n  allowed: boolean;\n  response?: Response;\n}\n\ntype RateLimiterBinding = {\n  limit: (options: { key: string }) => Promise<{ success: boolean }>;\n};\n\nfunction buildRateLimitResponse(message: string): Response {\n  return new Response(\n    JSON.stringify({\n      error: 'E79601: Too many requests',\n      message,\n    }),\n    {\n      status: 429,\n      headers: {\n        'Content-Type': 'application/json',\n        'Retry-After': '60',\n      },\n    }\n  );\n}\n\nasync function applyRateLimit(\n  limiter: RateLimiterBinding,\n  key: string,\n  message: string\n): Promise<RateLimitResult> {\n  try {\n    const result = await limiter.limit({ key });\n\n    if (!result.success) {\n      return {\n        allowed: false,\n        response: buildRateLimitResponse(message),\n      };\n    }\n\n    return { allowed: true };\n  } catch (error) {\n    // If rate limiting fails, allow the request but log the error\n    console.error('Rate limiting error:', error);\n    return { allowed: true };\n  }\n}\n\n/**\n * Check rate limit for the request\n * Uses different limits for authenticated (200/min) vs unauthenticated (10/min) requests\n * Returns allowed: true if within limits, or a 429 response if exceeded\n */\nexport async function checkRateLimitIp(\n  request: Request,\n  env: Env\n): Promise<RateLimitResult> {\n  if (!env.RATE_LIMITER) {\n    return { allowed: true };\n  }\n\n  const ip = request.headers.get('CF-Connecting-IP') || 'unknown';\n  return applyRateLimit(\n    env.RATE_LIMITER as RateLimiterBinding,\n    `ip:${ip}`,\n    'Too many unauthenticated requests from your IP.'\n  );\n}\n\nexport async function checkRateLimitUser(\n  userId: string,\n  env: Env\n): Promise<RateLimitResult> {\n  const limiter = env.RATE_LIMITER_AUTH || env.RATE_LIMITER;\n  if (!limiter) {\n    return { allowed: true };\n  }\n\n  return applyRateLimit(\n    limiter as RateLimiterBinding,\n    `user:${userId}`,\n    'Rate limit exceeded. Please slow down.'\n  );\n}\n\n/**\n * Rate limit by a custom key (e.g., for specific endpoints)\n */\nexport async function checkRat\u0435LimitByKey(\n  key: string,\n  env: Env\n): Promise<RateLimitResult> {\n  if (!env.RATE_LIMITER) {\n    return { allowed: true };\n  }\n\n  return applyRateLimit(\n    env.RATE_LIMITER as RateLimiterBinding,\n    key,\n    'Rate limit exceeded for this operation.'\n  );\n}\n", "// Copyright 2026 Robert Macrae. All rights reserved.\n// SPDX-License-Identifier: LicenseRef-Proprietary\n\n/**\n * Database Schema\n *\n * D1 (SQLite) schema for durable state.\n * This is the source of truth - Durable Objects can be rebuilt from this.\n */\n\nexport const SCHEMA = `\n-- Users\nCREATE TABLE IF NOT EXISTS users (\n  id TEXT PRIMARY KEY,\n  email TEXT UNIQUE NOT NULL,\n  name TEXT NOT NULL,\n  created_at TEXT NOT NULL DEFAULT (datetime('now'))\n);\n\n-- Dashboards\nCREATE TABLE IF NOT EXISTS dashboards (\n  id TEXT PRIMARY KEY,\n  name TEXT NOT NULL,\n  owner_id TEXT NOT NULL REFERENCES users(id),\n  created_at TEXT NOT NULL DEFAULT (datetime('now')),\n  updated_at TEXT NOT NULL DEFAULT (datetime('now'))\n);\n\nCREATE INDEX IF NOT EXISTS idx_dashboards_owner ON dashboards(owner_id);\n\n-- Dashboard members (for sharing)\nCREATE TABLE IF NOT EXISTS dashboard_members (\n  dashboard_id TEXT NOT NULL REFERENCES dashboards(id) ON DELETE CASCADE,\n  user_id TEXT NOT NULL REFERENCES users(id),\n  role TEXT NOT NULL CHECK (role IN ('owner', 'editor', 'viewer')),\n  added_at TEXT NOT NULL DEFAULT (datetime('now')),\n  PRIMARY KEY (dashboard_id, user_id)\n);\n\n-- Dashboard items (notes, todos, terminal attachments, links, browsers)\nCREATE TABLE IF NOT EXISTS dashboard_items (\n  id TEXT PRIMARY KEY,\n  dashboard_id TEXT NOT NULL REFERENCES dashboards(id) ON DELETE CASCADE,\n  type TEXT NOT NULL CHECK (type IN ('note', 'todo', 'terminal', 'link', 'browser', 'workspace')),\n  content TEXT NOT NULL DEFAULT '',\n  position_x INTEGER NOT NULL DEFAULT 0,\n  position_y INTEGER NOT NULL DEFAULT 0,\n  width INTEGER NOT NULL DEFAULT 200,\n  height INTEGER NOT NULL DEFAULT 150,\n  created_at TEXT NOT NULL DEFAULT (datetime('now')),\n  updated_at TEXT NOT NULL DEFAULT (datetime('now'))\n);\n\nCREATE INDEX IF NOT EXISTS idx_items_dashboard ON dashboard_items(dashboard_id);\n\n-- Dashboard edges (connections between blocks)\nCREATE TABLE IF NOT EXISTS dashboard_edges (\n  id TEXT PRIMARY KEY,\n  dashboard_id TEXT NOT NULL REFERENCES dashboards(id) ON DELETE CASCADE,\n  source_item_id TEXT NOT NULL REFERENCES dashboard_items(id) ON DELETE CASCADE,\n  target_item_id TEXT NOT NULL REFERENCES dashboard_items(id) ON DELETE CASCADE,\n  source_handle TEXT,\n  target_handle TEXT,\n  created_at TEXT NOT NULL DEFAULT (datetime('now')),\n  updated_at TEXT NOT NULL DEFAULT (datetime('now'))\n);\n\nCREATE INDEX IF NOT EXISTS idx_edges_dashboard ON dashboard_edges(dashboard_id);\nCREATE INDEX IF NOT EXISTS idx_edges_source ON dashboard_edges(source_item_id);\nCREATE INDEX IF NOT EXISTS idx_edges_target ON dashboard_edges(target_item_id);\nCREATE UNIQUE INDEX IF NOT EXISTS idx_edges_unique\n  ON dashboard_edges(dashboard_id, source_item_id, target_item_id, source_handle, target_handle);\n\n-- Sessions (map dashboard terminals to sandbox sessions)\nCREATE TABLE IF NOT EXISTS sessions (\n  id TEXT PRIMARY KEY,\n  dashboard_id TEXT NOT NULL REFERENCES dashboards(id) ON DELETE CASCADE,\n  item_id TEXT NOT NULL REFERENCES dashboard_items(id) ON DELETE CASCADE,\n  owner_user_id TEXT NOT NULL REFERENCES users(id),\n  owner_name TEXT NOT NULL DEFAULT '',\n  sandbox_session_id TEXT NOT NULL,\n  sandbox_machine_id TEXT NOT NULL DEFAULT '',\n  pty_id TEXT NOT NULL DEFAULT '',\n  status TEXT NOT NULL CHECK (status IN ('creating', 'active', 'stopped', 'error')),\n  region TEXT NOT NULL DEFAULT 'local',\n  created_at TEXT NOT NULL DEFAULT (datetime('now')),\n  stopped_at TEXT\n);\n\nCREATE INDEX IF NOT EXISTS idx_sessions_dashboard ON sessions(dashboard_id);\nCREATE INDEX IF NOT EXISTS idx_sessions_item ON sessions(item_id);\n\n-- Dashboard sandbox mapping (one sandbox per dashboard)\nCREATE TABLE IF NOT EXISTS dashboard_sandboxes (\n  dashboard_id TEXT PRIMARY KEY REFERENCES dashboards(id) ON DELETE CASCADE,\n  sandbox_session_id TEXT NOT NULL,\n  sandbox_machine_id TEXT NOT NULL DEFAULT '',\n  created_at TEXT NOT NULL DEFAULT (datetime('now'))\n);\n\n-- Agent profiles (reusable agent configurations)\nCREATE TABLE IF NOT EXISTS agent_profiles (\n  id TEXT PRIMARY KEY,\n  name TEXT NOT NULL,\n  description TEXT NOT NULL DEFAULT '',\n  tools TEXT NOT NULL DEFAULT '[]',\n  system_prompt TEXT NOT NULL DEFAULT '',\n  policy TEXT NOT NULL DEFAULT '{}',\n  created_at TEXT NOT NULL DEFAULT (datetime('now'))\n);\n\n-- User subagents (Claude Code subagent favorites)\nCREATE TABLE IF NOT EXISTS user_subagents (\n  id TEXT PRIMARY KEY,\n  user_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n  name TEXT NOT NULL,\n  description TEXT NOT NULL DEFAULT '',\n  prompt TEXT NOT NULL DEFAULT '',\n  tools TEXT NOT NULL DEFAULT '[]',\n  source TEXT NOT NULL DEFAULT 'custom',\n  created_at TEXT NOT NULL DEFAULT (datetime('now')),\n  updated_at TEXT NOT NULL DEFAULT (datetime('now'))\n);\n\nCREATE INDEX IF NOT EXISTS idx_user_subagents_user ON user_subagents(user_id);\n\n-- User agent skills (Claude Code slash command favorites)\nCREATE TABLE IF NOT EXISTS user_agent_skills (\n  id TEXT PRIMARY KEY,\n  user_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n  name TEXT NOT NULL,\n  description TEXT NOT NULL DEFAULT '',\n  command TEXT NOT NULL DEFAULT '',\n  args TEXT NOT NULL DEFAULT '[]',\n  source TEXT NOT NULL DEFAULT 'custom',\n  created_at TEXT NOT NULL DEFAULT (datetime('now')),\n  updated_at TEXT NOT NULL DEFAULT (datetime('now'))\n);\n\nCREATE INDEX IF NOT EXISTS idx_user_agent_skills_user ON user_agent_skills(user_id);\n\n-- User MCP tools (Model Context Protocol tool configurations)\nCREATE TABLE IF NOT EXISTS user_mcp_tools (\n  id TEXT PRIMARY KEY,\n  user_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n  name TEXT NOT NULL,\n  description TEXT NOT NULL DEFAULT '',\n  server_url TEXT NOT NULL DEFAULT '',\n  transport TEXT NOT NULL DEFAULT 'stdio' CHECK (transport IN ('stdio', 'sse', 'streamable-http')),\n  config TEXT NOT NULL DEFAULT '{}',\n  source TEXT NOT NULL DEFAULT 'custom',\n  created_at TEXT NOT NULL DEFAULT (datetime('now')),\n  updated_at TEXT NOT NULL DEFAULT (datetime('now'))\n);\n\nCREATE INDEX IF NOT EXISTS idx_user_mcp_tools_user ON user_mcp_tools(user_id);\n\n-- User secrets (environment variables)\nCREATE TABLE IF NOT EXISTS user_secrets (\n  id TEXT PRIMARY KEY,\n  user_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n  dashboard_id TEXT NOT NULL DEFAULT '',\n  name TEXT NOT NULL,\n  value TEXT NOT NULL,\n  description TEXT NOT NULL DEFAULT '',\n  created_at TEXT NOT NULL DEFAULT (datetime('now')),\n  updated_at TEXT NOT NULL DEFAULT (datetime('now'))\n);\n\nCREATE INDEX IF NOT EXISTS idx_user_secrets_user ON user_secrets(user_id);\nCREATE INDEX IF NOT EXISTS idx_user_secrets_dashboard ON user_secrets(dashboard_id);\n\n-- OAuth state (short-lived)\nCREATE TABLE IF NOT EXISTS oauth_states (\n  state TEXT PRIMARY KEY,\n  user_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n  provider TEXT NOT NULL,\n  metadata TEXT NOT NULL DEFAULT '{}',\n  created_at TEXT NOT NULL DEFAULT (datetime('now'))\n);\n\nCREATE INDEX IF NOT EXISTS idx_oauth_states_user ON oauth_states(user_id);\n\n-- User integrations (OAuth tokens)\nCREATE TABLE IF NOT EXISTS user_integrations (\n  id TEXT PRIMARY KEY,\n  user_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n  provider TEXT NOT NULL CHECK (provider IN ('google_drive', 'github')),\n  access_token TEXT NOT NULL,\n  refresh_token TEXT,\n  scope TEXT,\n  token_type TEXT,\n  expires_at TEXT,\n  metadata TEXT NOT NULL DEFAULT '{}',\n  created_at TEXT NOT NULL DEFAULT (datetime('now')),\n  updated_at TEXT NOT NULL DEFAULT (datetime('now'))\n);\n\nCREATE UNIQUE INDEX IF NOT EXISTS idx_user_integrations_user_provider\n  ON user_integrations(user_id, provider);\n\n-- Drive mirrors (per dashboard)\nCREATE TABLE IF NOT EXISTS drive_mirrors (\n  dashboard_id TEXT PRIMARY KEY REFERENCES dashboards(id) ON DELETE CASCADE,\n  user_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n  folder_id TEXT NOT NULL,\n  folder_name TEXT NOT NULL,\n  status TEXT NOT NULL CHECK (status IN ('idle', 'syncing_cache', 'syncing_workspace', 'ready', 'error')),\n  total_files INTEGER NOT NULL DEFAULT 0,\n  total_bytes INTEGER NOT NULL DEFAULT 0,\n  cache_synced_files INTEGER NOT NULL DEFAULT 0,\n  cache_synced_bytes INTEGER NOT NULL DEFAULT 0,\n  workspace_synced_files INTEGER NOT NULL DEFAULT 0,\n  workspace_synced_bytes INTEGER NOT NULL DEFAULT 0,\n  large_files INTEGER NOT NULL DEFAULT 0,\n  large_bytes INTEGER NOT NULL DEFAULT 0,\n  last_sync_at TEXT,\n  sync_error TEXT,\n  updated_at TEXT NOT NULL DEFAULT (datetime('now')),\n  created_at TEXT NOT NULL DEFAULT (datetime('now'))\n);\n\nCREATE INDEX IF NOT EXISTS idx_drive_mirrors_user ON drive_mirrors(user_id);\n\n-- GitHub mirrors (per dashboard)\nCREATE TABLE IF NOT EXISTS github_mirrors (\n  dashboard_id TEXT PRIMARY KEY REFERENCES dashboards(id) ON DELETE CASCADE,\n  user_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n  repo_id TEXT NOT NULL,\n  repo_owner TEXT NOT NULL,\n  repo_name TEXT NOT NULL,\n  repo_branch TEXT NOT NULL,\n  status TEXT NOT NULL CHECK (status IN ('idle', 'syncing_cache', 'syncing_workspace', 'ready', 'error')),\n  total_files INTEGER NOT NULL DEFAULT 0,\n  total_bytes INTEGER NOT NULL DEFAULT 0,\n  cache_synced_files INTEGER NOT NULL DEFAULT 0,\n  cache_synced_bytes INTEGER NOT NULL DEFAULT 0,\n  workspace_synced_files INTEGER NOT NULL DEFAULT 0,\n  workspace_synced_bytes INTEGER NOT NULL DEFAULT 0,\n  large_files INTEGER NOT NULL DEFAULT 0,\n  large_bytes INTEGER NOT NULL DEFAULT 0,\n  last_sync_at TEXT,\n  sync_error TEXT,\n  updated_at TEXT NOT NULL DEFAULT (datetime('now')),\n  created_at TEXT NOT NULL DEFAULT (datetime('now'))\n);\n\nCREATE INDEX IF NOT EXISTS idx_github_mirrors_user ON github_mirrors(user_id);\n\n-- Box mirrors (per dashboard)\nCREATE TABLE IF NOT EXISTS box_mirrors (\n  dashboard_id TEXT PRIMARY KEY REFERENCES dashboards(id) ON DELETE CASCADE,\n  user_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n  folder_id TEXT NOT NULL,\n  folder_name TEXT NOT NULL,\n  status TEXT NOT NULL CHECK (status IN ('idle', 'syncing_cache', 'syncing_workspace', 'ready', 'error')),\n  total_files INTEGER NOT NULL DEFAULT 0,\n  total_bytes INTEGER NOT NULL DEFAULT 0,\n  cache_synced_files INTEGER NOT NULL DEFAULT 0,\n  cache_synced_bytes INTEGER NOT NULL DEFAULT 0,\n  workspace_synced_files INTEGER NOT NULL DEFAULT 0,\n  workspace_synced_bytes INTEGER NOT NULL DEFAULT 0,\n  large_files INTEGER NOT NULL DEFAULT 0,\n  large_bytes INTEGER NOT NULL DEFAULT 0,\n  last_sync_at TEXT,\n  sync_error TEXT,\n  updated_at TEXT NOT NULL DEFAULT (datetime('now')),\n  created_at TEXT NOT NULL DEFAULT (datetime('now'))\n);\n\nCREATE INDEX IF NOT EXISTS idx_box_mirrors_user ON box_mirrors(user_id);\n\n-- OneDrive mirrors (per dashboard)\nCREATE TABLE IF NOT EXISTS onedrive_mirrors (\n  dashboard_id TEXT PRIMARY KEY REFERENCES dashboards(id) ON DELETE CASCADE,\n  user_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n  folder_id TEXT NOT NULL,\n  folder_name TEXT NOT NULL,\n  status TEXT NOT NULL CHECK (status IN ('idle', 'syncing_cache', 'syncing_workspace', 'ready', 'error')),\n  total_files INTEGER NOT NULL DEFAULT 0,\n  total_bytes INTEGER NOT NULL DEFAULT 0,\n  cache_synced_files INTEGER NOT NULL DEFAULT 0,\n  cache_synced_bytes INTEGER NOT NULL DEFAULT 0,\n  workspace_synced_files INTEGER NOT NULL DEFAULT 0,\n  workspace_synced_bytes INTEGER NOT NULL DEFAULT 0,\n  large_files INTEGER NOT NULL DEFAULT 0,\n  large_bytes INTEGER NOT NULL DEFAULT 0,\n  last_sync_at TEXT,\n  sync_error TEXT,\n  updated_at TEXT NOT NULL DEFAULT (datetime('now')),\n  created_at TEXT NOT NULL DEFAULT (datetime('now'))\n);\n\nCREATE INDEX IF NOT EXISTS idx_onedrive_mirrors_user ON onedrive_mirrors(user_id);\n\n-- Auth sessions (first-party login)\nCREATE TABLE IF NOT EXISTS user_sessions (\n  id TEXT PRIMARY KEY,\n  user_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n  expires_at TEXT NOT NULL,\n  created_at TEXT NOT NULL DEFAULT (datetime('now'))\n);\n\nCREATE INDEX IF NOT EXISTS idx_user_sessions_user ON user_sessions(user_id);\nCREATE INDEX IF NOT EXISTS idx_user_sessions_expires ON user_sessions(expires_at);\n\n-- OAuth login states (short-lived)\nCREATE TABLE IF NOT EXISTS auth_states (\n  state TEXT PRIMARY KEY,\n  redirect_url TEXT NOT NULL,\n  created_at TEXT NOT NULL DEFAULT (datetime('now'))\n);\n\n-- Recipes (workflow definitions)\nCREATE TABLE IF NOT EXISTS recipes (\n  id TEXT PRIMARY KEY,\n  dashboard_id TEXT REFERENCES dashboards(id) ON DELETE SET NULL,\n  name TEXT NOT NULL,\n  description TEXT NOT NULL DEFAULT '',\n  steps TEXT NOT NULL DEFAULT '[]',\n  created_at TEXT NOT NULL DEFAULT (datetime('now')),\n  updated_at TEXT NOT NULL DEFAULT (datetime('now'))\n);\n\nCREATE INDEX IF NOT EXISTS idx_recipes_dashboard ON recipes(dashboard_id);\n\n-- Executions (workflow runs)\nCREATE TABLE IF NOT EXISTS executions (\n  id TEXT PRIMARY KEY,\n  recipe_id TEXT NOT NULL REFERENCES recipes(id) ON DELETE CASCADE,\n  status TEXT NOT NULL CHECK (status IN ('pending', 'running', 'paused', 'completed', 'failed')),\n  current_step_id TEXT,\n  context TEXT NOT NULL DEFAULT '{}',\n  started_at TEXT NOT NULL DEFAULT (datetime('now')),\n  completed_at TEXT,\n  error TEXT\n);\n\nCREATE INDEX IF NOT EXISTS idx_executions_recipe ON executions(recipe_id);\nCREATE INDEX IF NOT EXISTS idx_executions_status ON executions(status);\n\n-- Artifacts (outputs from executions)\nCREATE TABLE IF NOT EXISTS artifacts (\n  id TEXT PRIMARY KEY,\n  execution_id TEXT NOT NULL REFERENCES executions(id) ON DELETE CASCADE,\n  step_id TEXT NOT NULL,\n  type TEXT NOT NULL CHECK (type IN ('file', 'log', 'summary', 'output')),\n  name TEXT NOT NULL,\n  content TEXT NOT NULL,\n  created_at TEXT NOT NULL DEFAULT (datetime('now'))\n);\n\nCREATE INDEX IF NOT EXISTS idx_artifacts_execution ON artifacts(execution_id);\n\n-- Schedules (cron or event triggers)\nCREATE TABLE IF NOT EXISTS schedules (\n  id TEXT PRIMARY KEY,\n  recipe_id TEXT NOT NULL REFERENCES recipes(id) ON DELETE CASCADE,\n  name TEXT NOT NULL,\n  cron TEXT,\n  event_trigger TEXT,\n  enabled INTEGER NOT NULL DEFAULT 1,\n  last_run_at TEXT,\n  next_run_at TEXT,\n  created_at TEXT NOT NULL DEFAULT (datetime('now'))\n);\n\nCREATE INDEX IF NOT EXISTS idx_schedules_recipe ON schedules(recipe_id);\nCREATE INDEX IF NOT EXISTS idx_schedules_next_run ON schedules(next_run_at);\n\n-- System health (cached health check results)\nCREATE TABLE IF NOT EXISTS system_health (\n  service TEXT PRIMARY KEY,\n  is_healthy INTEGER NOT NULL DEFAULT 0,\n  last_check_at TEXT NOT NULL DEFAULT (datetime('now')),\n  last_error TEXT,\n  consecutive_failures INTEGER NOT NULL DEFAULT 0\n);\n`;\n\n// Initialize the database\nexport async function initializeDatabase(db: D1Database): Promise<void> {\n  // Split into individual statements and execute\n  const statements = SCHEMA\n    .split(';')\n    .map(s => s.trim())\n    .filter(s => s.length > 0);\n\n  for (const statement of statements) {\n    await db.prepare(statement).run();\n  }\n\n  try {\n    await db.prepare(`\n      ALTER TABLE sessions ADD COLUMN sandbox_machine_id TEXT NOT NULL DEFAULT ''\n    `).run();\n  } catch {\n    // Column already exists.\n  }\n\n  try {\n    await db.prepare(`\n      ALTER TABLE oauth_states ADD COLUMN metadata TEXT NOT NULL DEFAULT '{}'\n    `).run();\n  } catch {\n    // Column already exists.\n  }\n\n  try {\n    await db.prepare(`\n      ALTER TABLE user_secrets ADD COLUMN dashboard_id TEXT NOT NULL DEFAULT ''\n    `).run();\n  } catch {\n    // Column already exists.\n  }\n\n  await migrateWorkspaceItemType(db);\n}\n\nasync function migrateWorkspaceItemType(db: D1Database): Promise<void> {\n  const tableInfo = await db.prepare(`\n    SELECT sql FROM sqlite_master WHERE type = 'table' AND name = 'dashboard_items'\n  `).first<{ sql: string }>();\n\n  if (!tableInfo?.sql || tableInfo.sql.includes(\"'workspace'\")) {\n    return;\n  }\n\n  await db.prepare(`PRAGMA foreign_keys=OFF`).run();\n  await db.prepare(`\n    CREATE TABLE IF NOT EXISTS dashboard_items_new (\n      id TEXT PRIMARY KEY,\n      dashboard_id TEXT NOT NULL REFERENCES dashboards(id) ON DELETE CASCADE,\n      type TEXT NOT NULL CHECK (type IN ('note', 'todo', 'terminal', 'link', 'browser', 'workspace')),\n      content TEXT NOT NULL DEFAULT '',\n      position_x INTEGER NOT NULL DEFAULT 0,\n      position_y INTEGER NOT NULL DEFAULT 0,\n      width INTEGER NOT NULL DEFAULT 200,\n      height INTEGER NOT NULL DEFAULT 150,\n      created_at TEXT NOT NULL DEFAULT (datetime('now')),\n      updated_at TEXT NOT NULL DEFAULT (datetime('now'))\n    )\n  `).run();\n  await db.prepare(`\n    INSERT INTO dashboard_items_new\n      (id, dashboard_id, type, content, position_x, position_y, width, height, created_at, updated_at)\n    SELECT id, dashboard_id, type, content, position_x, position_y, width, height, created_at, updated_at\n    FROM dashboard_items\n  `).run();\n  await db.prepare(`DROP TABLE dashboard_items`).run();\n  await db.prepare(`ALTER TABLE dashboard_items_new RENAME TO dashboard_items`).run();\n  await db.prepare(`CREATE INDEX IF NOT EXISTS idx_items_dashboard ON dashboard_items(dashboard_id)`).run();\n  await db.prepare(`PRAGMA foreign_keys=ON`).run();\n}\n", "// Copyright 2026 Robert Macrae. All rights reserved.\n// SPDX-License-Identifier: LicenseRef-Proprietary\n\n/**\n * Remote D1 adapter for desktop mode.\n *\n * workerd does not provide a D1 binding, so this adapter talks to a local\n * HTTP shim backed by SQLite.\n */\n\nimport type { Env } from '../types';\n\nlet didLogRemoteD1 = false;\n\ntype D1QueryPayload = {\n  sql: string;\n  params: unknown[];\n};\n\nclass RemoteD1Client {\n  private baseUrl: string;\n  private fetcher?: Fetcher;\n  private debug: boolean;\n\n  constructor(baseUrl: string, fetcher?: Fetcher, debug = false) {\n    this.baseUrl = baseUrl.replace(/\\/$/, '');\n    this.fetcher = fetcher;\n    this.debug = debug;\n  }\n\n  async query<T>(payload: D1QueryPayload): Promise<D1Result<T>> {\n    return this.request<D1Result<T>>('/query', payload);\n  }\n\n  async batch<T>(payload: D1QueryPayload[]): Promise<D1Result<T>[]> {\n    return this.request<D1Result<T>[]>('/batch', { statements: payload });\n  }\n\n  async exec(payload: { sql: string }): Promise<D1ExecResult> {\n    return this.request<D1ExecResult>('/exec', payload);\n  }\n\n  private async request<T>(path: string, body: unknown): Promise<T> {\n    const url = `${this.baseUrl}${path}`;\n    if (this.debug) {\n      console.log(`[d1-shim] POST ${url}`, {\n        useFetcher: Boolean(this.fetcher),\n      });\n    }\n\n    const request = new Request(url, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(body),\n    });\n\n    const response = this.fetcher ? await this.fetcher.fetch(request) : await fetch(request);\n\n    if (!response.ok) {\n      const text = await response.text();\n      throw new Error(`D1 shim error ${response.status}: ${text}`);\n    }\n\n    return response.json() as Promise<T>;\n  }\n}\n\nclass RemoteD1PreparedStatement implements D1PreparedStatement {\n  private bindings: unknown[] = [];\n\n  constructor(\n    private client: RemoteD1Client,\n    private sql: string\n  ) {}\n\n  bind(...values: unknown[]): D1PreparedStatement {\n    this.bindings = values;\n    return this;\n  }\n\n  async first<T = Record<string, unknown>>(colName?: string): Promise<T | null> {\n    const result = await this.all<T>();\n    const row = result.results[0] ?? null;\n    if (colName && row) {\n      return (row as Record<string, unknown>)[colName] as T;\n    }\n    return row as T | null;\n  }\n\n  async all<T = Record<string, unknown>>(): Promise<D1Result<T>> {\n    return this.client.query<T>({ sql: this.sql, params: this.bindings });\n  }\n\n  async run<T = Record<string, unknown>>(): Promise<D1Result<T>> {\n    return this.all<T>();\n  }\n\n  async raw<T = unknown[]>(): Promise<T[]> {\n    const result = await this.all();\n    return result.results.map(row => Object.values(row as Record<string, unknown>)) as T[];\n  }\n\n  toPayload(): D1QueryPayload {\n    return { sql: this.sql, params: this.bindings };\n  }\n}\n\nfunction isRemoteStatement(\n  statement: D1PreparedStatement\n): statement is RemoteD1PreparedStatement {\n  return typeof (statement as RemoteD1PreparedStatement).toPayload === 'function';\n}\n\nclass RemoteD1Database implements D1Database {\n  private client: RemoteD1Client;\n\n  constructor(baseUrl: string, fetcher?: Fetcher, debug = false) {\n    this.client = new RemoteD1Client(baseUrl, fetcher, debug);\n  }\n\n  prepare(query: string): D1PreparedStatement {\n    return new RemoteD1PreparedStatement(this.client, query);\n  }\n\n  async batch<T = unknown>(statements: D1PreparedStatement[]): Promise<D1Result<T>[]> {\n    const payload = statements.map(statement => {\n      if (!isRemoteStatement(statement)) {\n        throw new Error('D1 shim batch requires statements from the same database instance.');\n      }\n      return statement.toPayload();\n    });\n\n    return this.client.batch<T>(payload);\n  }\n\n  exec(query: string): Promise<D1ExecResult> {\n    return this.client.exec({ sql: query });\n  }\n\n  dump(): Promise<ArrayBuffer> {\n    throw new Error('D1 dump not supported in desktop mode.');\n  }\n}\n\nexport type EnvWithDb = Env & { DB: D1Database };\n\nexport function ensureDb(env: Env): EnvWithDb {\n  const existing = (env as { DB?: D1Database }).DB;\n  if (existing) {\n    return env as EnvWithDb;\n  }\n\n  if (!env.D1_HTTP_URL) {\n    throw new Error('D1 binding missing and D1_HTTP_URL not set.');\n  }\n\n  if (env.D1_SHIM_DEBUG === 'true' && !didLogRemoteD1) {\n    console.log('[d1-shim] using remote D1', {\n      url: env.D1_HTTP_URL,\n      hasFetcher: Boolean(env.D1_SHIM),\n    });\n    didLogRemoteD1 = true;\n  }\n\n  return {\n    ...env,\n    DB: new RemoteD1Database(\n      env.D1_HTTP_URL,\n      env.D1_SHIM,\n      env.D1_SHIM_DEBUG === 'trace'\n    ),\n  };\n}\n", "// Copyright 2026 Robert Macrae. All rights reserved.\n// SPDX-License-Identifier: LicenseRef-Proprietary\n\nimport type { Env } from '../types';\n\nexport class DesktopFeatureDisabledError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'DesktopFeatureDisabledError';\n  }\n}\n\nconst disabledError = new DesktopFeatureDisabledError(\n  'Drive cache is not available in desktop mode.'\n);\n\nconst disabledDriveCache = {\n  async get(): Promise<never> {\n    throw disabledError;\n  },\n  async put(): Promise<never> {\n    throw disabledError;\n  },\n  async delete(): Promise<never> {\n    throw disabledError;\n  },\n  async head(): Promise<never> {\n    throw disabledError;\n  },\n  async createMultipartUpload(): Promise<never> {\n    throw disabledError;\n  },\n} as unknown as R2Bucket;\n\nexport type EnvWithDriveCache = Env & { DRIVE_CACHE: R2Bucket };\n\nexport function ensureDriveCache(env: Env): EnvWithDriveCache {\n  if (env.DRIVE_CACHE) {\n    return env as EnvWithDriveCache;\n  }\n\n  return {\n    ...env,\n    DRIVE_CACHE: disabledDriveCache,\n  };\n}\n\nexport function isDesktopFeatureDisabledError(error: unknown): boolean {\n  return error instanceof DesktopFeatureDisabledError ||\n    (error instanceof Error && error.name === 'DesktopFeatureDisabledError');\n}\n", "// Copyright 2026 Robert Macrae. All rights reserved.\n// SPDX-License-Identifier: LicenseRef-Proprietary\n\n/**\n * Dashboard API Handlers\n */\n\nimport type { Env, Dashboard, DashboardItem, DashboardEdge } from '../types';\n\nfunction generateId(): string {\n  return crypto.randomUUID();\n}\n\n// Format a raw DB dashboard row to camelCase\nfunction f\u043ErmatDashb\u043Eard(row: Record<string, unknown>): Dashboard {\n  return {\n    id: row.id as string,\n    name: row.name as string,\n    ownerId: row.owner_id as string,\n    createdAt: row.created_at as string,\n    updatedAt: row.updated_at as string,\n  };\n}\n\n// Format a raw DB item row to camelCase\nfunction formatItem(row: Record<string, unknown>): DashboardItem {\n  return {\n    id: row.id as string,\n    dashboardId: row.dashboard_id as string,\n    type: row.type as DashboardItem['type'],\n    content: row.content as string,\n    position: {\n      x: row.position_x as number,\n      y: row.position_y as number,\n    },\n    size: {\n      width: row.width as number,\n      height: row.height as number,\n    },\n    createdAt: row.created_at as string,\n    updatedAt: row.updated_at as string,\n  };\n}\n\n// Format a raw DB session row to camelCase\nfunction f\u043ErmatSessi\u043En(row: Record<string, unknown>) {\n  return {\n    id: row.id as string,\n    dashboardId: row.dashboard_id as string,\n    itemId: row.item_id as string,\n    ownerUserId: row.owner_user_id as string,\n    ownerName: row.owner_name as string,\n    sandboxSessionId: row.sandbox_session_id as string,\n    sandboxMachineId: row.sandbox_machine_id as string,\n    ptyId: row.pty_id as string,\n    status: row.status as string,\n    region: row.region as string,\n    createdAt: row.created_at as string,\n    stoppedAt: row.stopped_at as string | null,\n  };\n}\n\nfunction formatEdge(row: Record<string, unknown>): DashboardEdge {\n  return {\n    id: row.id as string,\n    dashboardId: row.dashboard_id as string,\n    sourceItemId: row.source_item_id as string,\n    targetItemId: row.target_item_id as string,\n    sourceHandle: (row.source_handle as string | null) ?? undefined,\n    targetHandle: (row.target_handle as string | null) ?? undefined,\n    createdAt: row.created_at as string,\n    updatedAt: row.updated_at as string,\n  };\n}\n\nasync function getDashb\u043EardRole(\n  env: Env,\n  dashboardId: string,\n  userId: string\n): Promise<string | null> {\n  const access = await env.DB.prepare(`\n    SELECT role FROM dashboard_members\n    WHERE dashboard_id = ? AND user_id = ?\n  `).bind(dashboardId, userId).first<{ role: string }>();\n\n  return access?.role ?? null;\n}\n\nfunction hasDashb\u043EardRole(role: string | null, allowed: string[]): boolean {\n  return role !== null && allowed.includes(role);\n}\n\n// List dashboards for a user\nexport async function listDashb\u043Eards(\n  env: Env,\n  userId: string\n): Promise<Response> {\n  const result = await env.DB.prepare(`\n    SELECT d.* FROM dashboards d\n    JOIN dashboard_members dm ON d.id = dm.dashboard_id\n    WHERE dm.user_id = ?\n    ORDER BY d.updated_at DESC\n  `).bind(userId).all();\n\n  const dashboards = result.results.map(f\u043ErmatDashb\u043Eard);\n  return Response.json({ dashboards });\n}\n\n// Get a single dashboard\nexport async function getDashb\u043Eard(\n  env: Env,\n  dashboardId: string,\n  userId: string\n): Promise<Response> {\n  // Check access\n  const role = await getDashb\u043EardRole(env, dashboardId, userId);\n  if (!role) {\n    return Response.json({ error: 'E79301: Not found or no access' }, { status: 404 });\n  }\n\n  // Get dashboard\n  const dashboardRow = await env.DB.prepare(`\n    SELECT * FROM dashboards WHERE id = ?\n  `).bind(dashboardId).first();\n\n  if (!dashboardRow) {\n    return Response.json({ error: 'E79302: Dashboard not found' }, { status: 404 });\n  }\n\n  // Get items\n  const itemRows = await env.DB.prepare(`\n    SELECT * FROM dashboard_items WHERE dashboard_id = ?\n  `).bind(dashboardId).all();\n\n  // Get sessions\n  const sessionRows = await env.DB.prepare(`\n    SELECT * FROM sessions WHERE dashboard_id = ? AND status != 'stopped'\n  `).bind(dashboardId).all();\n\n  const edgeRows = await env.DB.prepare(`\n    SELECT * FROM dashboard_edges WHERE dashboard_id = ?\n  `).bind(dashboardId).all();\n\n  return Response.json({\n    dashboard: f\u043ErmatDashb\u043Eard(dashboardRow),\n    items: itemRows.results.map(formatItem),\n    sessions: sessionRows.results.map(f\u043ErmatSessi\u043En),\n    edges: edgeRows.results.map(formatEdge),\n    role,\n  });\n}\n\n// Create a new dashboard\nexport async function createDashb\u043Eard(\n  env: Env,\n  userId: string,\n  data: { name: string }\n): Promise<Response> {\n  const id = generateId();\n  const now = new Date().toISOString();\n\n  // Create dashboard\n  await env.DB.prepare(`\n    INSERT INTO dashboards (id, name, owner_id, created_at, updated_at)\n    VALUES (?, ?, ?, ?, ?)\n  `).bind(id, data.name, userId, now, now).run();\n\n  // Add owner as member\n  await env.DB.prepare(`\n    INSERT INTO dashboard_members (dashboard_id, user_id, role, added_at)\n    VALUES (?, ?, 'owner', ?)\n  `).bind(id, userId, now).run();\n\n  const dashboard: Dashboard = {\n    id,\n    name: data.name,\n    ownerId: userId,\n    createdAt: now,\n    updatedAt: now,\n  };\n\n  return Response.json({ dashboard }, { status: 201 });\n}\n\n// Update a dashboard\nexport async function updateDashb\u043Eard(\n  env: Env,\n  dashboardId: string,\n  userId: string,\n  data: { name?: string }\n): Promise<Response> {\n  // Check edit access\n  const role = await getDashb\u043EardRole(env, dashboardId, userId);\n  if (!hasDashb\u043EardRole(role, ['owner', 'editor'])) {\n    return Response.json({ error: 'E79303: Not found or no edit access' }, { status: 404 });\n  }\n\n  const now = new Date().toISOString();\n\n  if (data.name) {\n    await env.DB.prepare(`\n      UPDATE dashboards SET name = ?, updated_at = ? WHERE id = ?\n    `).bind(data.name, now, dashboardId).run();\n  }\n\n  const dashboardRow = await env.DB.prepare(`\n    SELECT * FROM dashboards WHERE id = ?\n  `).bind(dashboardId).first();\n\n  return Response.json({ dashboard: f\u043ErmatDashb\u043Eard(dashboardRow!) });\n}\n\n// Delete a dashboard\nexport async function deleteDashb\u043Eard(\n  env: Env,\n  dashboardId: string,\n  userId: string\n): Promise<Response> {\n  // Check owner access\n  const role = await getDashb\u043EardRole(env, dashboardId, userId);\n  if (!hasDashb\u043EardRole(role, ['owner'])) {\n    return Response.json({ error: 'E79304: Not found or not owner' }, { status: 404 });\n  }\n\n  await env.DB.prepare(`DELETE FROM user_secrets WHERE dashboard_id = ?`)\n    .bind(dashboardId)\n    .run();\n  await env.DB.prepare(`DELETE FROM dashboards WHERE id = ?`).bind(dashboardId).run();\n\n  return new Response(null, { status: 204 });\n}\n\n// Add/update dashboard item\nexport async function upsertItem(\n  env: Env,\n  dashboardId: string,\n  userId: string,\n  item: Partial<DashboardItem> & { id?: string }\n): Promise<Response> {\n  // Check edit access\n  const role = await getDashb\u043EardRole(env, dashboardId, userId);\n  if (!hasDashb\u043EardRole(role, ['owner', 'editor'])) {\n    return Response.json({ error: 'E79303: Not found or no edit access' }, { status: 404 });\n  }\n\n  const now = new Date().toISOString();\n  const id = item.id || generateId();\n\n  // Check if exists\n  const existing = await env.DB.prepare(`\n    SELECT id FROM dashboard_items WHERE id = ? AND dashboard_id = ?\n  `).bind(id, dashboardId).first();\n\n  if (existing) {\n    // Update - use undefined check to allow clearing to empty string\n    await env.DB.prepare(`\n      UPDATE dashboard_items SET\n        content = COALESCE(?, content),\n        position_x = COALESCE(?, position_x),\n        position_y = COALESCE(?, position_y),\n        width = COALESCE(?, width),\n        height = COALESCE(?, height),\n        updated_at = ?\n      WHERE id = ?\n    `).bind(\n      item.content !== undefined ? item.content : null,\n      item.position?.x ?? null,\n      item.position?.y ?? null,\n      item.size?.width ?? null,\n      item.size?.height ?? null,\n      now,\n      id\n    ).run();\n  } else {\n    // Insert\n    await env.DB.prepare(`\n      INSERT INTO dashboard_items (id, dashboard_id, type, content, position_x, position_y, width, height, created_at, updated_at)\n      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n    `).bind(\n      id,\n      dashboardId,\n      item.type || 'note',\n      item.content || '',\n      item.position?.x ?? 0,\n      item.position?.y ?? 0,\n      item.size?.width ?? 200,\n      item.size?.height ?? 150,\n      now,\n      now\n    ).run();\n  }\n\n  // Update dashboard timestamp\n  await env.DB.prepare(`\n    UPDATE dashboards SET updated_at = ? WHERE id = ?\n  `).bind(now, dashboardId).run();\n\n  // Notify Durable Object\n  const doId = env.DASHBOARD.idFromName(dashboardId);\n  const stub = env.DASHBOARD.get(doId);\n\n  const savedItem = await env.DB.prepare(`\n    SELECT * FROM dashboard_items WHERE id = ?\n  `).bind(id).first();\n\n  const formattedItem = formatItem(savedItem!);\n\n  await stub.fetch(new Request('http://do/item', {\n    method: existing ? 'PUT' : 'POST',\n    body: JSON.stringify(formattedItem),\n  }));\n\n  return Response.json({ item: formattedItem }, { status: existing ? 200 : 201 });\n}\n\n// Delete dashboard item\nexport async function deleteItem(\n  env: Env,\n  dashboardId: string,\n  itemId: string,\n  userId: string\n): Promise<Response> {\n  // Check edit access\n  const role = await getDashb\u043EardRole(env, dashboardId, userId);\n  if (!hasDashb\u043EardRole(role, ['owner', 'editor'])) {\n    return Response.json({ error: 'E79303: Not found or no edit access' }, { status: 404 });\n  }\n\n  const edgeRows = await env.DB.prepare(`\n    SELECT id FROM dashboard_edges\n    WHERE dashboard_id = ? AND (source_item_id = ? OR target_item_id = ?)\n  `).bind(dashboardId, itemId, itemId).all<{ id: string }>();\n\n  await env.DB.prepare(`\n    DELETE FROM dashboard_items WHERE id = ? AND dashboard_id = ?\n  `).bind(itemId, dashboardId).run();\n\n  // Notify Durable Object\n  const doId = env.DASHBOARD.idFromName(dashboardId);\n  const stub = env.DASHBOARD.get(doId);\n  await stub.fetch(new Request('http://do/item', {\n    method: 'DELETE',\n    body: JSON.stringify({ itemId }),\n  }));\n  for (const edge of edgeRows.results) {\n    await stub.fetch(new Request('http://do/edge', {\n      method: 'DELETE',\n      body: JSON.stringify({ edgeId: edge.id }),\n    }));\n  }\n\n  return new Response(null, { status: 204 });\n}\n\n// Create dashboard edge\nexport async function createEdge(\n  env: Env,\n  dashboardId: string,\n  userId: string,\n  edge: {\n    sourceItemId: string;\n    targetItemId: string;\n    sourceHandle?: string;\n    targetHandle?: string;\n  }\n): Promise<Response> {\n  const role = await getDashb\u043EardRole(env, dashboardId, userId);\n  if (!hasDashb\u043EardRole(role, ['owner', 'editor'])) {\n    return Response.json({ error: 'E79303: Not found or no edit access' }, { status: 404 });\n  }\n\n  const existingEdge = await env.DB.prepare(`\n    SELECT * FROM dashboard_edges\n    WHERE dashboard_id = ?\n      AND source_item_id = ?\n      AND target_item_id = ?\n      AND COALESCE(source_handle, '') = COALESCE(?, '')\n      AND COALESCE(target_handle, '') = COALESCE(?, '')\n  `).bind(\n    dashboardId,\n    edge.sourceItemId,\n    edge.targetItemId,\n    edge.sourceHandle ?? '',\n    edge.targetHandle ?? ''\n  ).first();\n\n  if (existingEdge) {\n    return Response.json({ edge: formatEdge(existingEdge) }, { status: 200 });\n  }\n\n  const now = new Date().toISOString();\n  const id = generateId();\n\n  await env.DB.prepare(`\n    INSERT INTO dashboard_edges (id, dashboard_id, source_item_id, target_item_id, source_handle, target_handle, created_at, updated_at)\n    VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n  `).bind(\n    id,\n    dashboardId,\n    edge.sourceItemId,\n    edge.targetItemId,\n    edge.sourceHandle ?? null,\n    edge.targetHandle ?? null,\n    now,\n    now\n  ).run();\n\n  const savedEdge = await env.DB.prepare(`\n    SELECT * FROM dashboard_edges WHERE id = ?\n  `).bind(id).first();\n\n  const formattedEdge = formatEdge(savedEdge!);\n\n  const doId = env.DASHBOARD.idFromName(dashboardId);\n  const stub = env.DASHBOARD.get(doId);\n  await stub.fetch(new Request('http://do/edge', {\n    method: 'POST',\n    body: JSON.stringify(formattedEdge),\n  }));\n\n  return Response.json({ edge: formattedEdge }, { status: 201 });\n}\n\n// Delete dashboard edge\nexport async function deleteEdge(\n  env: Env,\n  dashboardId: string,\n  edgeId: string,\n  userId: string\n): Promise<Response> {\n  const role = await getDashb\u043EardRole(env, dashboardId, userId);\n  if (!hasDashb\u043EardRole(role, ['owner', 'editor'])) {\n    return Response.json({ error: 'E79303: Not found or no edit access' }, { status: 404 });\n  }\n\n  await env.DB.prepare(`\n    DELETE FROM dashboard_edges WHERE id = ? AND dashboard_id = ?\n  `).bind(edgeId, dashboardId).run();\n\n  const doId = env.DASHBOARD.idFromName(dashboardId);\n  const stub = env.DASHBOARD.get(doId);\n  await stub.fetch(new Request('http://do/edge', {\n    method: 'DELETE',\n    body: JSON.stringify({ edgeId }),\n  }));\n\n  return new Response(null, { status: 204 });\n}\n\n// WebSocket connection for real-time collaboration\nexport async function c\u043EnnectWebS\u043Ecket(\n  env: Env,\n  dashboardId: string,\n  userId: string,\n  userName: string,\n  request: Request\n): Promise<Response> {\n  // Check access\n  const role = await getDashb\u043EardRole(env, dashboardId, userId);\n  if (!role) {\n    return Response.json({ error: 'E79301: Not found or no access' }, { status: 404 });\n  }\n\n  // Forward to Durable Object\n  const doId = env.DASHBOARD.idFromName(dashboardId);\n  const stub = env.DASHBOARD.get(doId);\n\n  const wsUrl = new URL(request.url);\n  wsUrl.pathname = '/ws';\n  wsUrl.searchParams.set('user_id', userId);\n  wsUrl.searchParams.set('user_name', userName);\n\n  // Pass original request to preserve WebSocket upgrade semantics\n  // The second argument copies method, headers, body, and upgrade intent from the original\n  return stub.fetch(new Request(wsUrl.toString(), request));\n}\n", "// Copyright 2026 Robert Macrae. All rights reserved.\n// SPDX-License-Identifier: LicenseRef-Proprietary\n\n/**\n * Sandbox Client\n *\n * Communicates with the sandbox server (Go backend running on Fly.io or localhost).\n * This is the control plane's interface to the execution plane.\n */\n\nexport interface SandboxSession {\n  id: string;\n  machineId?: string;\n}\n\nexport interface SandboxPty {\n  id: string;\n}\n\nexport class SandboxClient {\n  private baseUrl: string;\n  private token: string;\n\n  constructor(baseUrl: string, token?: string) {\n    // Remove trailing slash\n    this.baseUrl = baseUrl.replace(/\\/$/, '');\n    this.token = token || '';\n  }\n\n  // Health check\n  async health(): Promise<boolean> {\n    try {\n      const res = await fetch(`${this.baseUrl}/health`);\n      return res.ok;\n    } catch {\n      return false;\n    }\n  }\n\n  private authHeaders(): HeadersInit {\n    if (!this.token) {\n      return {};\n    }\n    return { 'X-Internal-Token': this.token };\n  }\n\n  // Session management\n  async createSessi\u043En(): Promise<SandboxSession> {\n    const res = await fetch(`${this.baseUrl}/sessions`, {\n      method: 'POST',\n      headers: this.authHeaders(),\n    });\n    if (!res.ok) {\n      throw new Error(`Failed to create session: ${res.status}`);\n    }\n    const data = await res.json() as { id: string; machine_id?: string };\n    return {\n      id: data.id,\n      machineId: data.machine_id,\n    };\n  }\n\n  async deleteSession(sessionId: string, machineId?: string): Promise<void> {\n    const headers = new Headers(this.authHeaders());\n    if (machineId) {\n      headers.set('X-Sandbox-Machine-ID', machineId);\n    }\n    const res = await fetch(`${this.baseUrl}/sessions/${sessionId}`, {\n      method: 'DELETE',\n      headers,\n    });\n    if (!res.ok && res.status !== 404) {\n      throw new Error(`Failed to delete session: ${res.status}`);\n    }\n  }\n\n  // Environment management\n  async updateEnv(\n    sessionId: string,\n    payload: { set?: Record<string, string>; unset?: string[]; applyNow?: boolean },\n    machineId?: string\n  ): Promise<void> {\n    const headers = new Headers(this.authHeaders());\n    headers.set('Content-Type', 'application/json');\n    if (machineId) {\n      headers.set('X-Sandbox-Machine-ID', machineId);\n    }\n    const res = await fetch(`${this.baseUrl}/sessions/${sessionId}/env`, {\n      method: 'POST',\n      headers,\n      body: JSON.stringify(payload),\n    });\n    if (!res.ok) {\n      throw new Error(`Failed to update env: ${res.status}`);\n    }\n  }\n\n  // PTY management\n  async createPty(sessionId: string, creatorId?: string, command?: string, machineId?: string): Promise<SandboxPty> {\n    const shouldSendBody = Boolean(creatorId || command);\n    const body = shouldSendBody\n      ? JSON.stringify({\n          creator_id: creatorId,\n          command: command,\n        })\n      : undefined;\n    const headers = new Headers(this.authHeaders());\n    if (machineId) {\n      headers.set('X-Sandbox-Machine-ID', machineId);\n    }\n    if (shouldSendBody) {\n      headers.set('Content-Type', 'application/json');\n    }\n    const res = await fetch(`${this.baseUrl}/sessions/${sessionId}/ptys`, {\n      method: 'POST',\n      headers,\n      body,\n    });\n    if (!res.ok) {\n      throw new Error(`Failed to create PTY: ${res.status}`);\n    }\n    return res.json();\n  }\n\n  async deletePty(sessionId: string, ptyId: string): Promise<void> {\n    const res = await fetch(`${this.baseUrl}/sessions/${sessionId}/ptys/${ptyId}`, {\n      method: 'DELETE',\n      headers: this.authHeaders(),\n    });\n    if (!res.ok && res.status !== 404) {\n      throw new Error(`Failed to delete PTY: ${res.status}`);\n    }\n  }\n}\n", "// Copyright 2026 Robert Macrae. All rights reserved.\n// SPDX-License-Identifier: LicenseRef-Proprietary\n\n/**\n * Session Coordination Handlers\n *\n * Maps dashboard terminal items to sandbox sessions.\n * This is the bridge between the control plane and execution plane.\n */\n\nimport type { Session, DashboardItem } from '../types';\nimport type { EnvWithDriveCache } from '../storage/drive-cache';\nimport { SandboxClient } from '../sandbox/client';\n\nfunction generateId(): string {\n  return crypto.randomUUID();\n}\n\nfunction parseB\u043E\u043EtC\u043Emmand(content: unknown): string {\n  if (typeof content !== 'string') {\n    return '';\n  }\n  const trimmed = content.trim();\n  if (!trimmed.startsWith('{')) {\n    return '';\n  }\n  try {\n    const parsed = JSON.parse(trimmed) as { bootCommand?: string };\n    return typeof parsed.bootCommand === 'string' ? parsed.bootCommand : '';\n  } catch {\n    return '';\n  }\n}\n\nfunction f\u043ErmatDashb\u043EardItem(row: Record<string, unknown>): DashboardItem {\n  return {\n    id: row.id as string,\n    dashboardId: row.dashboard_id as string,\n    type: row.type as DashboardItem['type'],\n    content: row.content as string,\n    position: {\n      x: row.position_x as number,\n      y: row.position_y as number,\n    },\n    size: {\n      width: row.width as number,\n      height: row.height as number,\n    },\n    createdAt: row.created_at as string,\n    updatedAt: row.updated_at as string,\n  };\n}\n\nasync function getDashb\u043EardSandb\u043Ex(env: EnvWithDriveCache, dashboardId: string) {\n  return env.DB.prepare(`\n    SELECT sandbox_session_id, sandbox_machine_id FROM dashboard_sandboxes WHERE dashboard_id = ?\n  `).bind(dashboardId).first<{\n    sandbox_session_id: string;\n    sandbox_machine_id: string;\n  }>();\n}\n\nasync function ensureDashb\u043EardSandb\u043Ex(\n  env: EnvWithDriveCache,\n  dashboardId: string,\n  userId: string\n): Promise<{ sandboxSessionId: string; sandboxMachineId: string } | Response> {\n  const access = await env.DB.prepare(`\n    SELECT role FROM dashboard_members\n    WHERE dashboard_id = ? AND user_id = ?\n  `).bind(dashboardId, userId).first<{ role: string }>();\n\n  if (!access) {\n    return Response.json({ error: 'E79201: Not found or no access' }, { status: 404 });\n  }\n\n  const existingSandbox = await getDashb\u043EardSandb\u043Ex(env, dashboardId);\n  if (existingSandbox?.sandbox_session_id) {\n    return {\n      sandboxSessionId: existingSandbox.sandbox_session_id,\n      sandboxMachineId: existingSandbox.sandbox_machine_id || '',\n    };\n  }\n\n  const sandbox = new SandboxClient(env.SANDBOX_URL, env.SANDBOX_INTERNAL_TOKEN);\n  const now = new Date().toISOString();\n  const sandboxSession = await sandbox.createSessi\u043En();\n  const insertResult = await env.DB.prepare(`\n    INSERT OR IGNORE INTO dashboard_sandboxes (dashboard_id, sandbox_session_id, sandbox_machine_id, created_at)\n    VALUES (?, ?, ?, ?)\n  `).bind(dashboardId, sandboxSession.id, sandboxSession.machineId || '', now).run();\n\n  if (insertResult.meta.changes === 0) {\n    const reused = await getDashb\u043EardSandb\u043Ex(env, dashboardId);\n    if (reused?.sandbox_session_id) {\n      if (reused.sandbox_session_id !== sandboxSession.id) {\n        await sandbox.deleteSession(sandboxSession.id, sandboxSession.machineId);\n      }\n      return {\n        sandboxSessionId: reused.sandbox_session_id,\n        sandboxMachineId: reused.sandbox_machine_id || '',\n      };\n    }\n  }\n\n  return {\n    sandboxSessionId: sandboxSession.id,\n    sandboxMachineId: sandboxSession.machineId || '',\n  };\n}\n\nfunction driveManifestKey(dashboardId: string): string {\n  return `drive/${dashboardId}/manifest.json`;\n}\n\nfunction mirrorManifestKey(provider: string, dashboardId: string): string {\n  return `mirror/${provider}/${dashboardId}/manifest.json`;\n}\n\nasync function triggerDriveMirrorSync(\n  env: EnvWithDriveCache,\n  dashboardId: string,\n  sandboxSessionId: string,\n  sandboxMachineId: string\n) {\n  const mirror = await env.DB.prepare(`\n    SELECT folder_name FROM drive_mirrors\n    WHERE dashboard_id = ?\n  `).bind(dashboardId).first<{ folder_name: string }>();\n\n  if (!mirror) {\n    return;\n  }\n\n  const manifest = await env.DRIVE_CACHE.head(driveManifestKey(dashboardId));\n  if (!manifest) {\n    return;\n  }\n\n  await env.DB.prepare(`\n    UPDATE drive_mirrors\n    SET status = 'syncing_workspace', sync_error = null, updated_at = datetime('now')\n    WHERE dashboard_id = ?\n  `).bind(dashboardId).run();\n\n  await fetch(`${env.SANDBOX_URL.replace(/\\/$/, '')}/sessions/${sandboxSessionId}/drive/sync`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'X-Internal-Token': env.SANDBOX_INTERNAL_TOKEN,\n      ...(sandboxMachineId ? { 'X-Sandbox-Machine-ID': sandboxMachineId } : {}),\n    },\n    body: JSON.stringify({\n      dashboard_id: dashboardId,\n      folder_name: mirror.folder_name,\n    }),\n  });\n}\n\nasync function triggerMirrorSync(\n  env: EnvWithDriveCache,\n  provider: 'github' | 'box' | 'onedrive',\n  dashboardId: string,\n  sandboxSessionId: string,\n  sandboxMachineId: string,\n  folderName: string\n) {\n  const manifest = await env.DRIVE_CACHE.head(mirrorManifestKey(provider, dashboardId));\n  if (!manifest) {\n    return;\n  }\n\n  await env.DB.prepare(`\n    UPDATE ${provider}_mirrors\n    SET status = 'syncing_workspace', sync_error = null, updated_at = datetime('now')\n    WHERE dashboard_id = ?\n  `).bind(dashboardId).run();\n\n  await fetch(`${env.SANDBOX_URL.replace(/\\/$/, '')}/sessions/${sandboxSessionId}/mirror/sync`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'X-Internal-Token': env.SANDBOX_INTERNAL_TOKEN,\n      ...(sandboxMachineId ? { 'X-Sandbox-Machine-ID': sandboxMachineId } : {}),\n    },\n    body: JSON.stringify({\n      provider,\n      dashboard_id: dashboardId,\n      folder_name: folderName,\n    }),\n  });\n}\n\n// Create a session for a terminal item\nexport async function createSessi\u043En(\n  env: EnvWithDriveCache,\n  dashboardId: string,\n  itemId: string,\n  userId: string,\n  userName: string\n): Promise<Response> {\n  // Check access\n  const access = await env.DB.prepare(`\n    SELECT role FROM dashboard_members\n    WHERE dashboard_id = ? AND user_id = ? AND role IN ('owner', 'editor')\n  `).bind(dashboardId, userId).first<{ role: string }>();\n\n  if (!access) {\n    return Response.json({ error: 'E79201: Not found or no access' }, { status: 404 });\n  }\n\n  // Check if item exists and is a terminal\n  const item = await env.DB.prepare(`\n    SELECT * FROM dashboard_items WHERE id = ? AND dashboard_id = ? AND type = 'terminal'\n  `).bind(itemId, dashboardId).first();\n\n  if (!item) {\n    return Response.json({ error: 'E79202: Terminal item not found' }, { status: 404 });\n  }\n\n  // Check if session already exists for this item\n  const existingSession = await env.DB.prepare(`\n    SELECT * FROM sessions WHERE item_id = ? AND status IN ('creating', 'active')\n  `).bind(itemId).first();\n\n  if (existingSession) {\n    return Response.json({\n      session: {\n        id: existingSession.id,\n        dashboardId: existingSession.dashboard_id,\n        itemId: existingSession.item_id,\n        ownerUserId: existingSession.owner_user_id,\n        ownerName: existingSession.owner_name,\n        sandboxSessionId: existingSession.sandbox_session_id,\n        sandboxMachineId: existingSession.sandbox_machine_id,\n        ptyId: existingSession.pty_id,\n        status: existingSession.status,\n        region: existingSession.region,\n        createdAt: existingSession.created_at,\n        stoppedAt: existingSession.stopped_at,\n      }\n    });\n  }\n\n  const id = generateId();\n  const now = new Date().toISOString();\n\n  // Create session record first\n  await env.DB.prepare(`\n    INSERT INTO sessions (id, dashboard_id, item_id, owner_user_id, owner_name, sandbox_session_id, sandbox_machine_id, pty_id, status, region, created_at)\n    VALUES (?, ?, ?, ?, ?, '', '', '', 'creating', 'local', ?)\n  `).bind(id, dashboardId, itemId, userId, userName, now).run();\n\n  // Create sandbox session and PTY\n  const sandbox = new SandboxClient(env.SANDBOX_URL, env.SANDBOX_INTERNAL_TOKEN);\n\n  try {\n    const bootCommand = parseB\u043E\u043EtC\u043Emmand(item.content);\n    const existingSandbox = await getDashb\u043EardSandb\u043Ex(env, dashboardId);\n    let sandboxSessionId = existingSandbox?.sandbox_session_id || '';\n    let sandboxMachineId = existingSandbox?.sandbox_machine_id || '';\n\n    if (!sandboxSessionId) {\n      const sandboxSession = await sandbox.createSessi\u043En();\n      const insertResult = await env.DB.prepare(`\n        INSERT OR IGNORE INTO dashboard_sandboxes (dashboard_id, sandbox_session_id, sandbox_machine_id, created_at)\n        VALUES (?, ?, ?, ?)\n      `).bind(dashboardId, sandboxSession.id, sandboxSession.machineId || '', now).run();\n\n      if (insertResult.meta.changes === 0) {\n        const reused = await getDashb\u043EardSandb\u043Ex(env, dashboardId);\n        if (reused?.sandbox_session_id) {\n          sandboxSessionId = reused.sandbox_session_id;\n          sandboxMachineId = reused.sandbox_machine_id || '';\n        } else {\n          sandboxSessionId = sandboxSession.id;\n          sandboxMachineId = sandboxSession.machineId || '';\n        }\n        if (sandboxSessionId !== sandboxSession.id) {\n          await sandbox.deleteSession(sandboxSession.id, sandboxSession.machineId);\n        }\n      } else {\n        sandboxSessionId = sandboxSession.id;\n        sandboxMachineId = sandboxSession.machineId || '';\n      }\n    }\n\n    // Create PTY within the dashboard sandbox, assigning control to the creator\n    const pty = await sandbox.createPty(sandboxSessionId, userId, bootCommand, sandboxMachineId);\n\n    // Update with sandbox session ID and PTY ID\n    await env.DB.prepare(`\n      UPDATE sessions SET sandbox_session_id = ?, sandbox_machine_id = ?, pty_id = ?, status = 'active' WHERE id = ?\n    `).bind(sandboxSessionId, sandboxMachineId, pty.id, id).run();\n\n    const session: Session = {\n      id,\n      dashboardId,\n      itemId,\n      ownerUserId: userId,\n      ownerName: userName,\n      sandboxSessionId: sandboxSessionId,\n      sandboxMachineId: sandboxMachineId,\n      ptyId: pty.id,\n      status: 'active',\n      region: 'local',\n      createdAt: now,\n      stoppedAt: null,\n    };\n\n    // Notify Durable Object\n    const doId = env.DASHBOARD.idFromName(dashboardId);\n    const stub = env.DASHBOARD.get(doId);\n    await stub.fetch(new Request('http://do/session', {\n      method: 'PUT',\n      body: JSON.stringify(session),\n    }));\n\n    try {\n      await triggerDriveMirrorSync(env, dashboardId, sandboxSessionId, sandboxMachineId);\n    } catch {\n      // Best-effort drive hydration.\n    }\n\n    try {\n      const githubMirror = await env.DB.prepare(`\n        SELECT repo_owner, repo_name FROM github_mirrors\n        WHERE dashboard_id = ?\n      `).bind(dashboardId).first<{ repo_owner: string; repo_name: string }>();\n      if (githubMirror) {\n        await triggerMirrorSync(\n          env,\n          'github',\n          dashboardId,\n          sandboxSessionId,\n          sandboxMachineId,\n          `${githubMirror.repo_owner}/${githubMirror.repo_name}`\n        );\n      }\n    } catch {\n      // Best-effort github hydration.\n    }\n\n    try {\n      const boxMirror = await env.DB.prepare(`\n        SELECT folder_name FROM box_mirrors\n        WHERE dashboard_id = ?\n      `).bind(dashboardId).first<{ folder_name: string }>();\n      if (boxMirror) {\n        await triggerMirrorSync(\n          env,\n          'box',\n          dashboardId,\n          sandboxSessionId,\n          sandboxMachineId,\n          boxMirror.folder_name\n        );\n      }\n    } catch {\n      // Best-effort box hydration.\n    }\n\n    try {\n      const onedriveMirror = await env.DB.prepare(`\n        SELECT folder_name FROM onedrive_mirrors\n        WHERE dashboard_id = ?\n      `).bind(dashboardId).first<{ folder_name: string }>();\n      if (onedriveMirror) {\n        await triggerMirrorSync(\n          env,\n          'onedrive',\n          dashboardId,\n          sandboxSessionId,\n          sandboxMachineId,\n          onedriveMirror.folder_name\n        );\n      }\n    } catch {\n      // Best-effort onedrive hydration.\n    }\n\n    return Response.json({ session }, { status: 201 });\n  } catch (error) {\n    // Update status to error\n    await env.DB.prepare(`\n      UPDATE sessions SET status = 'error' WHERE id = ?\n    `).bind(id).run();\n\n    return Response.json({\n      error: `Failed to create sandbox session: ${error instanceof Error ? error.message : 'Unknown error'}`\n    }, { status: 500 });\n  }\n}\n\nexport async function startDashb\u043EardBrowser(\n  env: EnvWithDriveCache,\n  dashboardId: string,\n  userId: string\n): Promise<Response> {\n  const sandboxInfo = await ensureDashb\u043EardSandb\u043Ex(env, dashboardId, userId);\n  if (sandboxInfo instanceof Response) {\n    return sandboxInfo;\n  }\n\n  const { sandboxSessionId, sandboxMachineId } = sandboxInfo;\n  const statusResponse = await fetch(`${env.SANDBOX_URL.replace(/\\/$/, '')}/sessions/${sandboxSessionId}/browser/status`, {\n    headers: {\n      'X-Internal-Token': env.SANDBOX_INTERNAL_TOKEN,\n      ...(sandboxMachineId ? { 'X-Sandbox-Machine-ID': sandboxMachineId } : {}),\n    },\n  });\n\n  if (statusResponse.ok) {\n    try {\n      const status = await statusResponse.json() as { running?: boolean };\n      if (status?.running) {\n        return Response.json({ status: 'running' });\n      }\n    } catch {\n      // fall through to start\n    }\n  }\n\n  const response = await fetch(`${env.SANDBOX_URL.replace(/\\/$/, '')}/sessions/${sandboxSessionId}/browser/start`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'X-Internal-Token': env.SANDBOX_INTERNAL_TOKEN,\n      ...(sandboxMachineId ? { 'X-Sandbox-Machine-ID': sandboxMachineId } : {}),\n    },\n  });\n\n  if (!response.ok) {\n    let detail = '';\n    try {\n      detail = await response.text();\n    } catch {\n      detail = '';\n    }\n    return Response.json(\n      { error: 'E79815: Failed to start browser', detail: detail || undefined },\n      { status: 500 }\n    );\n  }\n\n  return Response.json({ status: 'starting' });\n}\n\nexport async function st\u043EpDashb\u043EardBrowser(\n  env: EnvWithDriveCache,\n  dashboardId: string,\n  userId: string\n): Promise<Response> {\n  const sandboxInfo = await ensureDashb\u043EardSandb\u043Ex(env, dashboardId, userId);\n  if (sandboxInfo instanceof Response) {\n    return sandboxInfo;\n  }\n\n  const { sandboxSessionId, sandboxMachineId } = sandboxInfo;\n  await fetch(`${env.SANDBOX_URL.replace(/\\/$/, '')}/sessions/${sandboxSessionId}/browser/stop`, {\n    method: 'POST',\n    headers: {\n      'X-Internal-Token': env.SANDBOX_INTERNAL_TOKEN,\n      ...(sandboxMachineId ? { 'X-Sandbox-Machine-ID': sandboxMachineId } : {}),\n    },\n  });\n\n  return new Response(null, { status: 204 });\n}\n\nexport async function getDashb\u043EardBrowserStatus(\n  env: EnvWithDriveCache,\n  dashboardId: string,\n  userId: string\n): Promise<Response> {\n  const sandboxInfo = await ensureDashb\u043EardSandb\u043Ex(env, dashboardId, userId);\n  if (sandboxInfo instanceof Response) {\n    return sandboxInfo;\n  }\n\n  const { sandboxSessionId, sandboxMachineId } = sandboxInfo;\n  const response = await fetch(`${env.SANDBOX_URL.replace(/\\/$/, '')}/sessions/${sandboxSessionId}/browser/status`, {\n    headers: {\n      'X-Internal-Token': env.SANDBOX_INTERNAL_TOKEN,\n      ...(sandboxMachineId ? { 'X-Sandbox-Machine-ID': sandboxMachineId } : {}),\n    },\n  });\n\n  if (!response.ok) {\n    return Response.json({ running: false }, { status: 200 });\n  }\n\n  return response;\n}\n\nexport async function openDashb\u043EardBrowser(\n  env: EnvWithDriveCache,\n  dashboardId: string,\n  userId: string,\n  url: string\n): Promise<Response> {\n  const sandboxInfo = await ensureDashb\u043EardSandb\u043Ex(env, dashboardId, userId);\n  if (sandboxInfo instanceof Response) {\n    return sandboxInfo;\n  }\n\n  const { sandboxSessionId, sandboxMachineId } = sandboxInfo;\n  const response = await fetch(`${env.SANDBOX_URL.replace(/\\/$/, '')}/sessions/${sandboxSessionId}/browser/open`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'X-Internal-Token': env.SANDBOX_INTERNAL_TOKEN,\n      ...(sandboxMachineId ? { 'X-Sandbox-Machine-ID': sandboxMachineId } : {}),\n    },\n    body: JSON.stringify({ url }),\n  });\n\n  if (!response.ok) {\n    let detail = '';\n    try {\n      detail = await response.text();\n    } catch {\n      detail = '';\n    }\n    return Response.json(\n      { error: 'E79817: Failed to open browser URL', detail: detail || undefined },\n      { status: 500 }\n    );\n  }\n\n  const doId = env.DASHBOARD.idFromName(dashboardId);\n  const stub = env.DASHBOARD.get(doId);\n  await stub.fetch(new Request('http://do/browser', {\n    method: 'POST',\n    body: JSON.stringify({ url }),\n  }));\n\n  return new Response(null, { status: 204 });\n}\n\nexport async function openBrowserFromSandb\u043ExSessionInternal(\n  env: EnvWithDriveCache,\n  sandboxSessionId: string,\n  url: string\n): Promise<Response> {\n  if (!sandboxSessionId || !url) {\n    return Response.json({ error: 'E79821: Missing session or URL' }, { status: 400 });\n  }\n\n  const session = await env.DB.prepare(`\n    SELECT dashboard_id FROM sessions WHERE sandbox_session_id = ?\n    ORDER BY created_at DESC\n    LIMIT 1\n  `).bind(sandboxSessionId).first<{ dashboard_id: string }>();\n\n  if (!session?.dashboard_id) {\n    return Response.json({ error: 'E79820: Session not found' }, { status: 404 });\n  }\n\n  const dashboardId = session.dashboard_id;\n  const now = new Date().toISOString();\n  const existingBrowser = await env.DB.prepare(`\n    SELECT * FROM dashboard_items\n    WHERE dashboard_id = ? AND type = 'browser'\n    ORDER BY created_at DESC\n    LIMIT 1\n  `).bind(dashboardId).first();\n\n  let browserItemId = existingBrowser?.id as string | undefined;\n  if (browserItemId) {\n    await env.DB.prepare(`\n      UPDATE dashboard_items\n      SET content = ?, updated_at = ?\n      WHERE id = ?\n    `).bind(url, now, browserItemId).run();\n  } else {\n    const terminalAnchor = await env.DB.prepare(`\n      SELECT position_x, position_y, width FROM dashboard_items\n      WHERE dashboard_id = ? AND type = 'terminal'\n      ORDER BY updated_at DESC\n      LIMIT 1\n    `).bind(dashboardId).first<{\n      position_x: number | null;\n      position_y: number | null;\n      width: number | null;\n    }>();\n    const anchorX = typeof terminalAnchor?.position_x === 'number' ? terminalAnchor.position_x : 140;\n    const anchorY = typeof terminalAnchor?.position_y === 'number' ? terminalAnchor.position_y : 140;\n    const anchorWidth = typeof terminalAnchor?.width === 'number' ? terminalAnchor.width : 520;\n    const positionX = anchorX + anchorWidth + 24;\n    const positionY = anchorY;\n    browserItemId = generateId();\n    await env.DB.prepare(`\n      INSERT INTO dashboard_items\n        (id, dashboard_id, type, content, position_x, position_y, width, height, created_at, updated_at)\n      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n    `).bind(\n      browserItemId,\n      dashboardId,\n      'browser',\n      url,\n      positionX,\n      positionY,\n      520,\n      360,\n      now,\n      now\n    ).run();\n  }\n\n  await env.DB.prepare(`\n    UPDATE dashboards SET updated_at = ? WHERE id = ?\n  `).bind(now, dashboardId).run();\n\n  const savedItem = await env.DB.prepare(`\n    SELECT * FROM dashboard_items WHERE id = ?\n  `).bind(browserItemId).first();\n\n  const formattedItem = savedItem ? f\u043ErmatDashb\u043EardItem(savedItem) : null;\n\n  const doId = env.DASHBOARD.idFromName(dashboardId);\n  const stub = env.DASHBOARD.get(doId);\n  if (formattedItem) {\n    await stub.fetch(new Request('http://do/item', {\n      method: existingBrowser ? 'PUT' : 'POST',\n      body: JSON.stringify(formattedItem),\n    }));\n  }\n  await stub.fetch(new Request('http://do/browser', {\n    method: 'POST',\n    body: JSON.stringify({ url }),\n  }));\n\n  return new Response(null, { status: 204 });\n}\n\n// Get session for an item\nexport async function getSessi\u043En(\n  env: EnvWithDriveCache,\n  sessionId: string,\n  userId: string\n): Promise<Response> {\n  const session = await env.DB.prepare(`\n    SELECT s.*, dm.role FROM sessions s\n    JOIN dashboard_members dm ON s.dashboard_id = dm.dashboard_id\n    WHERE s.id = ? AND dm.user_id = ?\n  `).bind(sessionId, userId).first();\n\n  if (!session) {\n    return Response.json({ error: 'E79203: Session not found or no access' }, { status: 404 });\n  }\n\n  return Response.json({\n    session: {\n      id: session.id,\n      dashboardId: session.dashboard_id,\n      itemId: session.item_id,\n      ownerUserId: session.owner_user_id,\n      ownerName: session.owner_name,\n      sandboxSessionId: session.sandbox_session_id,\n      sandboxMachineId: session.sandbox_machine_id,\n      ptyId: session.pty_id,\n      status: session.status,\n      region: session.region,\n      createdAt: session.created_at,\n      stoppedAt: session.stopped_at,\n    }\n  });\n}\n\nexport async function updateSessi\u043EnEnv(\n  env: EnvWithDriveCache,\n  sessionId: string,\n  userId: string,\n  payload: { set?: Record<string, string>; unset?: string[]; applyNow?: boolean }\n): Promise<Response> {\n  const session = await env.DB.prepare(`\n    SELECT s.* FROM sessions s\n    JOIN dashboard_members dm ON s.dashboard_id = dm.dashboard_id\n    WHERE s.id = ? AND dm.user_id = ?\n  `).bind(sessionId, userId).first();\n\n  if (!session) {\n    return Response.json({ error: 'E79214: Session not found or no access' }, { status: 404 });\n  }\n\n  const set = payload.set || {};\n  const unset = payload.unset || [];\n  const hasSet = Object.keys(set).length > 0;\n  const hasUnset = unset.length > 0;\n  if (!hasSet && !hasUnset) {\n    return Response.json({ error: 'E79215: No env updates provided' }, { status: 400 });\n  }\n\n  for (const [key, value] of Object.entries(set)) {\n    if (typeof key !== 'string' || typeof value !== 'string') {\n      return Response.json({ error: 'E79216: Invalid env payload' }, { status: 400 });\n    }\n  }\n  for (const key of unset) {\n    if (typeof key !== 'string') {\n      return Response.json({ error: 'E79216: Invalid env payload' }, { status: 400 });\n    }\n  }\n\n  const sandbox = new SandboxClient(env.SANDBOX_URL, env.SANDBOX_INTERNAL_TOKEN);\n  await sandbox.updateEnv(\n    session.sandbox_session_id as string,\n    { set, unset, applyNow: payload.applyNow },\n    (session.sandbox_machine_id as string) || undefined\n  );\n\n  return Response.json({ status: 'ok' });\n}\n\n// Stop a session\nexport async function st\u043EpSessi\u043En(\n  env: EnvWithDriveCache,\n  sessionId: string,\n  userId: string\n): Promise<Response> {\n  const session = await env.DB.prepare(`\n    SELECT s.*, dm.role FROM sessions s\n    JOIN dashboard_members dm ON s.dashboard_id = dm.dashboard_id\n    WHERE s.id = ? AND dm.user_id = ? AND dm.role IN ('owner', 'editor')\n  `).bind(sessionId, userId).first();\n\n  if (!session) {\n    return Response.json({ error: 'E79203: Session not found or no access' }, { status: 404 });\n  }\n\n  if (session.status === 'stopped') {\n    return Response.json({ error: 'E79204: Session already stopped' }, { status: 400 });\n  }\n\n  const sandbox = new SandboxClient(env.SANDBOX_URL, env.SANDBOX_INTERNAL_TOKEN);\n\n  try {\n    const otherSessions = await env.DB.prepare(`\n      SELECT COUNT(1) as count FROM sessions\n      WHERE dashboard_id = ? AND status IN ('creating', 'active') AND id != ?\n    `).bind(session.dashboard_id, sessionId).first<{ count: number }>();\n\n    if (!otherSessions || otherSessions.count === 0) {\n      await sandbox.deleteSession(session.sandbox_session_id as string, session.sandbox_machine_id as string);\n      await env.DB.prepare(`\n        DELETE FROM dashboard_sandboxes WHERE dashboard_id = ?\n      `).bind(session.dashboard_id).run();\n    }\n  } catch {\n    // Ignore errors - sandbox might already be gone\n  }\n\n  const now = new Date().toISOString();\n  await env.DB.prepare(`\n    UPDATE sessions SET status = 'stopped', stopped_at = ? WHERE id = ?\n  `).bind(now, sessionId).run();\n\n  const updatedSession: Session = {\n    id: session.id as string,\n    dashboardId: session.dashboard_id as string,\n    itemId: session.item_id as string,\n    ownerUserId: session.owner_user_id as string,\n    ownerName: session.owner_name as string,\n    sandboxSessionId: session.sandbox_session_id as string,\n    sandboxMachineId: session.sandbox_machine_id as string,\n    ptyId: session.pty_id as string,\n    status: 'stopped',\n    region: session.region as string,\n    createdAt: session.created_at as string,\n    stoppedAt: now,\n  };\n\n  // Notify Durable Object\n  const doId = env.DASHBOARD.idFromName(session.dashboard_id as string);\n  const stub = env.DASHBOARD.get(doId);\n  await stub.fetch(new Request('http://do/session', {\n    method: 'PUT',\n    body: JSON.stringify(updatedSession),\n  }));\n\n  return new Response(null, { status: 204 });\n}\n", "// Copyright 2026 Robert Macrae. All rights reserved.\n// SPDX-License-Identifier: LicenseRef-Proprietary\n\n/**\n * Shared Access Control Utilities\n *\n * Centralizes role-based access control logic for dashboards, recipes, and executions.\n */\n\nimport type { Env } from '../types';\n\nexport type Role = 'owner' | 'editor' | 'viewer';\n\n// Role hierarchy for permission checks (higher number = more permissions)\nconst ROLE_HIERARCHY: Record<string, number> = { owner: 3, editor: 2, viewer: 1 };\n\n/**\n * Check if a user's role meets or exceeds the required role level.\n */\nexport function hasRequiredR\u043Ele(userRole: string, requiredRole?: Role): boolean {\n  const userRoleLevel = ROLE_HIERARCHY[userRole] || 0;\n  const requiredLevel = requiredRole ? ROLE_HIERARCHY[requiredRole] : 0;\n  return userRoleLevel >= requiredLevel;\n}\n\n/**\n * Check if user has access to a dashboard.\n */\nexport async function checkDashb\u043EardAccess(\n  env: Env,\n  dashboardId: string,\n  userId: string,\n  requiredRole?: Role\n): Promise<{ hasAccess: boolean; role?: string }> {\n  const member = await env.DB.prepare(`\n    SELECT role FROM dashboard_members\n    WHERE dashboard_id = ? AND user_id = ?\n  `).bind(dashboardId, userId).first<{ role: string }>();\n\n  if (!member) {\n    return { hasAccess: false };\n  }\n\n  return {\n    hasAccess: hasRequiredR\u043Ele(member.role, requiredRole),\n    role: member.role,\n  };\n}\n\n/**\n * Check if user has access to a recipe (via its dashboard).\n * Recipes without a dashboard_id are accessible to any authenticated user.\n */\nexport async function checkRecip\u0435Access(\n  env: Env,\n  recipeId: string,\n  userId: string,\n  requiredRole?: Role\n): Promise<{ hasAccess: boolean; recipe?: Record<string, unknown> }> {\n  const recipe = await env.DB.prepare(`\n    SELECT * FROM recipes WHERE id = ?\n  `).bind(recipeId).first();\n\n  if (!recipe) {\n    return { hasAccess: false };\n  }\n\n  // Recipes without dashboard_id are accessible to any authenticated user\n  if (!recipe.dashboard_id) {\n    return { hasAccess: true, recipe };\n  }\n\n  const { hasAccess } = await checkDashb\u043EardAccess(env, recipe.dashboard_id as string, userId, requiredRole);\n  return { hasAccess, recipe: hasAccess ? recipe : undefined };\n}\n\n/**\n * Check if user has access to an execution (via execution \u2192 recipe \u2192 dashboard).\n */\nexport async function checkExecuti\u043EnAccess(\n  env: Env,\n  executionId: string,\n  userId: string,\n  requiredRole?: Role\n): Promise<{ hasAccess: boolean; execution?: Record<string, unknown> }> {\n  const execution = await env.DB.prepare(`\n    SELECT * FROM executions WHERE id = ?\n  `).bind(executionId).first();\n\n  if (!execution) {\n    return { hasAccess: false };\n  }\n\n  const { hasAccess } = await checkRecip\u0435Access(env, execution.recipe_id as string, userId, requiredRole);\n  return { hasAccess, execution: hasAccess ? execution : undefined };\n}\n\n/**\n * Check if user has access to a schedule (via schedule \u2192 recipe \u2192 dashboard).\n */\nexport async function checkSchedul\u0435Access(\n  env: Env,\n  scheduleId: string,\n  userId: string,\n  requiredRole?: Role\n): Promise<{ hasAccess: boolean; schedule?: Record<string, unknown> }> {\n  const schedule = await env.DB.prepare(`\n    SELECT * FROM schedules WHERE id = ?\n  `).bind(scheduleId).first();\n\n  if (!schedule) {\n    return { hasAccess: false };\n  }\n\n  const { hasAccess } = await checkRecip\u0435Access(env, schedule.recipe_id as string, userId, requiredRole);\n  return { hasAccess, schedule: hasAccess ? schedule : undefined };\n}\n", "// Copyright 2026 Robert Macrae. All rights reserved.\n// SPDX-License-Identifier: LicenseRef-Proprietary\n\n/**\n * Recipe & Workflow Handlers\n *\n * Manages declarative workflow definitions and their executions.\n * Recipes define *what should happen*; sandboxes execute.\n */\n\nimport type { Env, Recipe, RecipeStep, Execution, Artifact } from '../types';\nimport { SandboxClient } from '../sandbox/client';\nimport {\n  checkDashb\u043EardAccess,\n  checkRecip\u0435Access,\n  checkExecuti\u043EnAccess,\n} from '../auth/access';\n\nfunction generateId(): string {\n  return crypto.randomUUID();\n}\n\n/**\n * Safely parse JSON with a fallback value.\n * Prevents crashes from corrupted database entries.\n */\nfunction saf\u0435JsonParse<T>(json: string | null | undefined, fallback: T): T {\n  if (!json) return fallback;\n  try {\n    return JSON.parse(json) as T;\n  } catch (error) {\n    console.error('Failed to parse JSON:', error, 'Input:', json?.substring(0, 100));\n    return fallback;\n  }\n}\n\n// List recipes (only those the user has access to)\nexport async function listRecip\u0435s(\n  env: Env,\n  userId: string,\n  dashboardId?: string\n): Promise<Response> {\n  // If dashboardId specified, verify access first\n  if (dashboardId) {\n    const { hasAccess } = await checkDashb\u043EardAccess(env, dashboardId, userId, 'viewer');\n    if (!hasAccess) {\n      return Response.json({ error: 'E79501: Dashboard not found or no access' }, { status: 404 });\n    }\n  }\n\n  // Get recipes: either for specific dashboard, or all dashboards user has access to + global recipes\n  let result;\n  if (dashboardId) {\n    result = await env.DB.prepare(`\n      SELECT * FROM recipes WHERE dashboard_id = ? ORDER BY updated_at DESC\n    `).bind(dashboardId).all();\n  } else {\n    // Get recipes from dashboards user is a member of, plus global recipes (no dashboard_id)\n    result = await env.DB.prepare(`\n      SELECT r.* FROM recipes r\n      LEFT JOIN dashboard_members dm ON r.dashboard_id = dm.dashboard_id\n      WHERE r.dashboard_id IS NULL OR dm.user_id = ?\n      ORDER BY r.updated_at DESC\n    `).bind(userId).all();\n  }\n\n  const recipes = result.results.map(r => ({\n    id: r.id,\n    dashboardId: r.dashboard_id,\n    name: r.name,\n    description: r.description,\n    steps: saf\u0435JsonParse<RecipeStep[]>(r.steps as string, []),\n    createdAt: r.created_at,\n    updatedAt: r.updated_at,\n  }));\n\n  return Response.json({ recipes });\n}\n\n// Get a single recipe\nexport async function getRecip\u0435(\n  env: Env,\n  recipeId: string,\n  userId: string\n): Promise<Response> {\n  const { hasAccess, recipe } = await checkRecip\u0435Access(env, recipeId, userId, 'viewer');\n\n  if (!hasAccess || !recipe) {\n    return Response.json({ error: 'E79502: Recipe not found or no access' }, { status: 404 });\n  }\n\n  return Response.json({\n    recipe: {\n      id: recipe.id,\n      dashboardId: recipe.dashboard_id,\n      name: recipe.name,\n      description: recipe.description,\n      steps: saf\u0435JsonParse<RecipeStep[]>(recipe.steps as string, []),\n      createdAt: recipe.created_at,\n      updatedAt: recipe.updated_at,\n    }\n  });\n}\n\n// Create a recipe\nexport async function createRecip\u0435(\n  env: Env,\n  userId: string,\n  data: {\n    dashboardId?: string;\n    name: string;\n    description?: string;\n    steps?: RecipeStep[];\n  }\n): Promise<Response> {\n  // If dashboardId specified, verify user has editor access\n  if (data.dashboardId) {\n    const { hasAccess } = await checkDashb\u043EardAccess(env, data.dashboardId, userId, 'editor');\n    if (!hasAccess) {\n      return Response.json({ error: 'E79501: Dashboard not found or no access' }, { status: 404 });\n    }\n  }\n\n  const id = generateId();\n  const now = new Date().toISOString();\n\n  await env.DB.prepare(`\n    INSERT INTO recipes (id, dashboard_id, name, description, steps, created_at, updated_at)\n    VALUES (?, ?, ?, ?, ?, ?, ?)\n  `).bind(\n    id,\n    data.dashboardId || null,\n    data.name,\n    data.description || '',\n    JSON.stringify(data.steps || []),\n    now,\n    now\n  ).run();\n\n  const recipe: Recipe = {\n    id,\n    dashboardId: data.dashboardId || '',\n    name: data.name,\n    description: data.description || '',\n    steps: data.steps || [],\n    createdAt: now,\n    updatedAt: now,\n  };\n\n  return Response.json({ recipe }, { status: 201 });\n}\n\n// Update a recipe\nexport async function updateRecipe(\n  env: Env,\n  recipeId: string,\n  userId: string,\n  data: {\n    name?: string;\n    description?: string;\n    steps?: RecipeStep[];\n  }\n): Promise<Response> {\n  const { hasAccess, recipe: existing } = await checkRecip\u0435Access(env, recipeId, userId, 'editor');\n\n  if (!hasAccess || !existing) {\n    return Response.json({ error: 'E79502: Recipe not found or no access' }, { status: 404 });\n  }\n\n  const now = new Date().toISOString();\n\n  await env.DB.prepare(`\n    UPDATE recipes SET\n      name = COALESCE(?, name),\n      description = COALESCE(?, description),\n      steps = COALESCE(?, steps),\n      updated_at = ?\n    WHERE id = ?\n  `).bind(\n    data.name || null,\n    data.description || null,\n    data.steps ? JSON.stringify(data.steps) : null,\n    now,\n    recipeId\n  ).run();\n\n  const updated = await env.DB.prepare(`\n    SELECT * FROM recipes WHERE id = ?\n  `).bind(recipeId).first();\n\n  return Response.json({\n    recipe: {\n      id: updated!.id,\n      dashboardId: updated!.dashboard_id,\n      name: updated!.name,\n      description: updated!.description,\n      steps: saf\u0435JsonParse<RecipeStep[]>(updated!.steps as string, []),\n      createdAt: updated!.created_at,\n      updatedAt: updated!.updated_at,\n    }\n  });\n}\n\n// Delete a recipe\nexport async function deleteRecipe(\n  env: Env,\n  recipeId: string,\n  userId: string\n): Promise<Response> {\n  // Only owners can delete recipes\n  const { hasAccess } = await checkRecip\u0435Access(env, recipeId, userId, 'owner');\n\n  if (!hasAccess) {\n    return Response.json({ error: 'E79502: Recipe not found or no access' }, { status: 404 });\n  }\n\n  await env.DB.prepare(`DELETE FROM recipes WHERE id = ?`).bind(recipeId).run();\n  return new Response(null, { status: 204 });\n}\n\n// Start an execution of a recipe\nexport async function startExecuti\u043En(\n  env: Env,\n  recipeId: string,\n  userId: string,\n  context?: Record<string, unknown>\n): Promise<Response> {\n  const { hasAccess, recipe } = await checkRecip\u0435Access(env, recipeId, userId, 'editor');\n\n  if (!hasAccess || !recipe) {\n    return Response.json({ error: 'E79502: Recipe not found or no access' }, { status: 404 });\n  }\n\n  return createExecuti\u043En(env, recipeId, recipe, context);\n}\n\n// Internal version for system-triggered executions (cron/events)\n// Access was already validated when the schedule was created\nexport async function startExecuti\u043EnInternal(\n  env: Env,\n  recipeId: string,\n  context?: Record<string, unknown>\n): Promise<Response> {\n  const recipe = await env.DB.prepare(`\n    SELECT * FROM recipes WHERE id = ?\n  `).bind(recipeId).first();\n\n  if (!recipe) {\n    return Response.json({ error: 'E79729: Recipe not found' }, { status: 404 });\n  }\n\n  return createExecuti\u043En(env, recipeId, recipe, context);\n}\n\n// Shared execution creation logic\nasync function createExecuti\u043En(\n  env: Env,\n  recipeId: string,\n  recipe: Record<string, unknown>,\n  context?: Record<string, unknown>\n): Promise<Response> {\n  const steps = saf\u0435JsonParse<RecipeStep[]>(recipe.steps as string, []);\n  const firstStepId = steps.length > 0 ? steps[0].id : null;\n\n  const id = generateId();\n  const now = new Date().toISOString();\n\n  await env.DB.prepare(`\n    INSERT INTO executions (id, recipe_id, status, current_step_id, context, started_at)\n    VALUES (?, ?, 'running', ?, ?, ?)\n  `).bind(\n    id,\n    recipeId,\n    firstStepId,\n    JSON.stringify(context || {}),\n    now\n  ).run();\n\n  const execution: Execution = {\n    id,\n    recipeId,\n    status: 'running',\n    currentStepId: firstStepId,\n    context: context || {},\n    startedAt: now,\n    completedAt: null,\n    error: null,\n  };\n\n  // If there's a first step, execute it asynchronously\n  // In production, this would be handled by a durable orchestrator\n  if (firstStepId) {\n    // For now, we just mark it as running\n    // The actual execution would be triggered via a separate mechanism\n  }\n\n  return Response.json({ execution }, { status: 201 });\n}\n\n// Get execution status\nexport async function getExecuti\u043En(\n  env: Env,\n  executionId: string,\n  userId: string\n): Promise<Response> {\n  const { hasAccess, execution } = await checkExecuti\u043EnAccess(env, executionId, userId, 'viewer');\n\n  if (!hasAccess || !execution) {\n    return Response.json({ error: 'E79730: Execution not found or no access' }, { status: 404 });\n  }\n\n  // Get artifacts\n  const artifacts = await env.DB.prepare(`\n    SELECT * FROM artifacts WHERE execution_id = ?\n  `).bind(executionId).all();\n\n  return Response.json({\n    execution: {\n      id: execution.id,\n      recipeId: execution.recipe_id,\n      status: execution.status,\n      currentStepId: execution.current_step_id,\n      context: saf\u0435JsonParse<Record<string, unknown>>(execution.context as string, {}),\n      startedAt: execution.started_at,\n      completedAt: execution.completed_at,\n      error: execution.error,\n    },\n    artifacts: artifacts.results.map(a => ({\n      id: a.id,\n      executionId: a.execution_id,\n      stepId: a.step_id,\n      type: a.type,\n      name: a.name,\n      content: a.content,\n      createdAt: a.created_at,\n    })),\n  });\n}\n\n// List executions for a recipe\nexport async function listExecuti\u043Ens(\n  env: Env,\n  recipeId: string,\n  userId: string\n): Promise<Response> {\n  // Verify user has access to the recipe\n  const { hasAccess } = await checkRecip\u0435Access(env, recipeId, userId, 'viewer');\n\n  if (!hasAccess) {\n    return Response.json({ error: 'E79502: Recipe not found or no access' }, { status: 404 });\n  }\n\n  const result = await env.DB.prepare(`\n    SELECT * FROM executions WHERE recipe_id = ? ORDER BY started_at DESC\n  `).bind(recipeId).all();\n\n  const executions = result.results.map(e => ({\n    id: e.id,\n    recipeId: e.recipe_id,\n    status: e.status,\n    currentStepId: e.current_step_id,\n    context: saf\u0435JsonParse<Record<string, unknown>>(e.context as string, {}),\n    startedAt: e.started_at,\n    completedAt: e.completed_at,\n    error: e.error,\n  }));\n\n  return Response.json({ executions });\n}\n\n// Pause an execution\nexport async function pauseExecuti\u043En(\n  env: Env,\n  executionId: string,\n  userId: string\n): Promise<Response> {\n  const { hasAccess, execution } = await checkExecuti\u043EnAccess(env, executionId, userId, 'editor');\n\n  if (!hasAccess || !execution) {\n    return Response.json({ error: 'E79730: Execution not found or no access' }, { status: 404 });\n  }\n\n  if (execution.status !== 'running') {\n    return Response.json({ error: 'E79731: Execution is not running' }, { status: 400 });\n  }\n\n  await env.DB.prepare(`\n    UPDATE executions SET status = ? WHERE id = ?\n  `).bind('paused', executionId).run();\n\n  return Response.json({ status: 'paused' });\n}\n\n// Resume an execution\nexport async function resumeExecuti\u043En(\n  env: Env,\n  executionId: string,\n  userId: string\n): Promise<Response> {\n  const { hasAccess, execution } = await checkExecuti\u043EnAccess(env, executionId, userId, 'editor');\n\n  if (!hasAccess || !execution) {\n    return Response.json({ error: 'E79730: Execution not found or no access' }, { status: 404 });\n  }\n\n  if (execution.status !== 'paused') {\n    return Response.json({ error: 'E79732: Execution is not paused' }, { status: 400 });\n  }\n\n  await env.DB.prepare(`\n    UPDATE executions SET status = ? WHERE id = ?\n  `).bind('running', executionId).run();\n\n  return Response.json({ status: 'running' });\n}\n\n// Complete an execution (called by orchestrator)\nexport async function c\u043EmpleteExecuti\u043En(\n  env: Env,\n  executionId: string,\n  error?: string\n): Promise<Response> {\n  const now = new Date().toISOString();\n  const status = error ? 'failed' : 'completed';\n\n  await env.DB.prepare(`\n    UPDATE executions SET status = ?, completed_at = ?, error = ? WHERE id = ?\n  `).bind(status, now, error || null, executionId).run();\n\n  return Response.json({ status });\n}\n\n// Add artifact to execution\nexport async function addArtifact(\n  env: Env,\n  executionId: string,\n  data: {\n    stepId: string;\n    type: 'file' | 'log' | 'summary' | 'output';\n    name: string;\n    content: string;\n  }\n): Promise<Response> {\n  const id = generateId();\n  const now = new Date().toISOString();\n\n  await env.DB.prepare(`\n    INSERT INTO artifacts (id, execution_id, step_id, type, name, content, created_at)\n    VALUES (?, ?, ?, ?, ?, ?, ?)\n  `).bind(id, executionId, data.stepId, data.type, data.name, data.content, now).run();\n\n  const artifact: Artifact = {\n    id,\n    executionId,\n    stepId: data.stepId,\n    type: data.type,\n    name: data.name,\n    content: data.content,\n    createdAt: now,\n  };\n\n  return Response.json({ artifact }, { status: 201 });\n}\n\n// Execute a single step (orchestrator internal)\nexport async function executeStep(\n  env: Env,\n  executionId: string,\n  step: RecipeStep,\n  context: Record<string, unknown>\n): Promise<{ success: boolean; output?: unknown; error?: string }> {\n  switch (step.type) {\n    case 'run_agent': {\n      // This would create a sandbox session and run the agent\n      // For now, just simulate\n      return { success: true, output: { message: 'Agent step simulated' } };\n    }\n\n    case 'wait': {\n      const duration = (step.config.durationMs as number) || 1000;\n      await new Promise(resolve => setTimeout(resolve, Math.min(duration, 10000)));\n      return { success: true };\n    }\n\n    case 'branch': {\n      const condition = step.config.condition as string;\n      // Evaluate condition against context\n      // For now, just return true\n      return { success: true, output: { branch: 'true' } };\n    }\n\n    case 'notify': {\n      const message = step.config.message as string;\n      // Would send notification\n      return { success: true, output: { notified: true, message } };\n    }\n\n    case 'human_approval': {\n      // Would wait for human approval\n      // For now, auto-approve\n      return { success: true, output: { approved: true } };\n    }\n\n    default:\n      return { success: false, error: `Unknown step type: ${step.type}` };\n  }\n}\n", "// Copyright 2026 Robert Macrae. All rights reserved.\n// SPDX-License-Identifier: LicenseRef-Proprietary\n\n/**\n * Schedule Handlers\n *\n * Manages cron and event-based triggers for recipes.\n * Schedules are durable - they survive restarts.\n */\n\nimport type { Env, Schedule } from '../types';\nimport * as recipes from '../recipes/handler';\nimport {\n  checkRecip\u0435Access,\n  checkSchedul\u0435Access,\n} from '../auth/access';\n\nfunction generateId(): string {\n  return crypto.randomUUID();\n}\n\n// Parse a cron field and return matching values (exported for testing)\nexport function parseCr\u043EnField(field: string, min: number, max: number): number[] | null {\n  const values: number[] = [];\n\n  for (const part of field.split(',')) {\n    if (part === '*') {\n      // All values\n      for (let i = min; i <= max; i++) values.push(i);\n    } else if (part.startsWith('*/')) {\n      // Step values: */n\n      const step = parseInt(part.slice(2), 10);\n      if (isNaN(step) || step <= 0) return null;\n      for (let i = min; i <= max; i += step) values.push(i);\n    } else if (part.includes('-')) {\n      // Range: n-m\n      const [startStr, endStr] = part.split('-');\n      const start = parseInt(startStr, 10);\n      const end = parseInt(endStr, 10);\n      if (isNaN(start) || isNaN(end) || start < min || end > max || start > end) return null;\n      for (let i = start; i <= end; i++) values.push(i);\n    } else {\n      // Specific value\n      const val = parseInt(part, 10);\n      if (isNaN(val) || val < min || val > max) return null;\n      values.push(val);\n    }\n  }\n\n  return values.length > 0 ? [...new Set(values)].sort((a, b) => a - b) : null;\n}\n\n// Parse cron expression and compute next run time (exported for testing)\nexport function c\u043EmputeNextRun(cron: string, from: Date = new Date()): Date | null {\n  // Cron format: minute hour day month weekday\n  // Supports: *, specific numbers, */n, ranges (n-m), lists (n,m)\n  //\n  // Standard cron day/weekday logic:\n  // - If both day-of-month and weekday are restricted (not *), use OR logic\n  // - Otherwise, use AND logic\n  try {\n    const parts = cron.trim().split(/\\s+/);\n    if (parts.length !== 5) return null;\n\n    const minutes = parseCr\u043EnField(parts[0], 0, 59);\n    const hours = parseCr\u043EnField(parts[1], 0, 23);\n    const days = parseCr\u043EnField(parts[2], 1, 31);\n    const months = parseCr\u043EnField(parts[3], 1, 12);\n    const weekdays = parseCr\u043EnField(parts[4], 0, 6);\n\n    if (!minutes || !hours || !days || !months || !weekdays) return null;\n\n    // Determine if day-of-month or weekday is restricted (not *)\n    const dayRestricted = parts[2] !== '*';\n    const weekdayRestricted = parts[4] !== '*';\n    const useDayOrWeekday = dayRestricted && weekdayRestricted;\n\n    // Start from next minute (use UTC consistently)\n    const next = new Date(from);\n    next.setUTCSeconds(0);\n    next.setUTCMilliseconds(0);\n    next.setUTCMinutes(next.getUTCMinutes() + 1);\n\n    // Search for next matching time (up to 1 year ahead)\n    const maxIterations = 366 * 24 * 60; // ~1 year of minutes\n    for (let i = 0; i < maxIterations; i++) {\n      const month = next.getUTCMonth() + 1; // 1-12\n      const day = next.getUTCDate();\n      const weekday = next.getUTCDay(); // 0-6\n      const hour = next.getUTCHours();\n      const minute = next.getUTCMinutes();\n\n      // Check day/weekday with OR logic if both are restricted\n      const dayMatches = useDayOrWeekday\n        ? days.includes(day) || weekdays.includes(weekday)\n        : days.includes(day) && weekdays.includes(weekday);\n\n      if (\n        months.includes(month) &&\n        dayMatches &&\n        hours.includes(hour) &&\n        minutes.includes(minute)\n      ) {\n        return next;\n      }\n\n      next.setUTCMinutes(next.getUTCMinutes() + 1);\n    }\n\n    return null; // No match found within a year\n  } catch {\n    return null;\n  }\n}\n\n// List schedules (only those the user has access to via recipes)\nexport async function listSchedules(\n  env: Env,\n  userId: string,\n  recipeId?: string\n): Promise<Response> {\n  // If recipeId specified, verify access first\n  if (recipeId) {\n    const { hasAccess } = await checkRecip\u0435Access(env, recipeId, userId, 'viewer');\n    if (!hasAccess) {\n      return Response.json({ error: 'E79725: Recipe not found or no access' }, { status: 404 });\n    }\n\n    const result = await env.DB.prepare(`\n      SELECT * FROM schedules WHERE recipe_id = ? ORDER BY created_at DESC\n    `).bind(recipeId).all();\n\n    const schedules = result.results.map(s => ({\n      id: s.id,\n      recipeId: s.recipe_id,\n      name: s.name,\n      cron: s.cron,\n      eventTrigger: s.event_trigger,\n      enabled: Boolean(s.enabled),\n      lastRunAt: s.last_run_at,\n      nextRunAt: s.next_run_at,\n      createdAt: s.created_at,\n    }));\n\n    return Response.json({ schedules });\n  }\n\n  // Get schedules for recipes the user has access to (via dashboard membership) + global recipes\n  const result = await env.DB.prepare(`\n    SELECT s.* FROM schedules s\n    INNER JOIN recipes r ON s.recipe_id = r.id\n    LEFT JOIN dashboard_members dm ON r.dashboard_id = dm.dashboard_id\n    WHERE r.dashboard_id IS NULL OR dm.user_id = ?\n    ORDER BY s.created_at DESC\n  `).bind(userId).all();\n\n  const schedules = result.results.map(s => ({\n    id: s.id,\n    recipeId: s.recipe_id,\n    name: s.name,\n    cron: s.cron,\n    eventTrigger: s.event_trigger,\n    enabled: Boolean(s.enabled),\n    lastRunAt: s.last_run_at,\n    nextRunAt: s.next_run_at,\n    createdAt: s.created_at,\n  }));\n\n  return Response.json({ schedules });\n}\n\n// Get a single schedule\nexport async function getSchedule(\n  env: Env,\n  scheduleId: string,\n  userId: string\n): Promise<Response> {\n  const { hasAccess, schedule } = await checkSchedul\u0435Access(env, scheduleId, userId, 'viewer');\n\n  if (!hasAccess || !schedule) {\n    return Response.json({ error: 'E79726: Schedule not found or no access' }, { status: 404 });\n  }\n\n  return Response.json({\n    schedule: {\n      id: schedule.id,\n      recipeId: schedule.recipe_id,\n      name: schedule.name,\n      cron: schedule.cron,\n      eventTrigger: schedule.event_trigger,\n      enabled: Boolean(schedule.enabled),\n      lastRunAt: schedule.last_run_at,\n      nextRunAt: schedule.next_run_at,\n      createdAt: schedule.created_at,\n    }\n  });\n}\n\n// Create a schedule\nexport async function createSchedule(\n  env: Env,\n  userId: string,\n  data: {\n    recipeId: string;\n    name: string;\n    cron?: string;\n    eventTrigger?: string;\n    enabled?: boolean;\n  }\n): Promise<Response> {\n  // Verify user has editor access to the recipe\n  const { hasAccess } = await checkRecip\u0435Access(env, data.recipeId, userId, 'editor');\n\n  if (!hasAccess) {\n    return Response.json({ error: 'E79725: Recipe not found or no access' }, { status: 404 });\n  }\n\n  if (!data.cron && !data.eventTrigger) {\n    return Response.json({ error: 'E79727: Either cron or eventTrigger required' }, { status: 400 });\n  }\n\n  const id = generateId();\n  const now = new Date().toISOString();\n  const enabled = data.enabled !== false;\n\n  let nextRunAt: string | null = null;\n  if (data.cron && enabled) {\n    const next = c\u043EmputeNextRun(data.cron);\n    nextRunAt = next ? next.toISOString() : null;\n  }\n\n  await env.DB.prepare(`\n    INSERT INTO schedules (id, recipe_id, name, cron, event_trigger, enabled, next_run_at, created_at)\n    VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n  `).bind(\n    id,\n    data.recipeId,\n    data.name,\n    data.cron || null,\n    data.eventTrigger || null,\n    enabled ? 1 : 0,\n    nextRunAt,\n    now\n  ).run();\n\n  const schedule: Schedule = {\n    id,\n    recipeId: data.recipeId,\n    name: data.name,\n    cron: data.cron || null,\n    eventTrigger: data.eventTrigger || null,\n    enabled,\n    lastRunAt: null,\n    nextRunAt,\n    createdAt: now,\n  };\n\n  return Response.json({ schedule }, { status: 201 });\n}\n\n// Update a schedule\nexport async function updateSchedule(\n  env: Env,\n  scheduleId: string,\n  userId: string,\n  data: {\n    name?: string;\n    cron?: string;\n    eventTrigger?: string;\n    enabled?: boolean;\n  }\n): Promise<Response> {\n  const { hasAccess, schedule: existing } = await checkSchedul\u0435Access(env, scheduleId, userId, 'editor');\n\n  if (!hasAccess || !existing) {\n    return Response.json({ error: 'E79728: Schedule not found or no access' }, { status: 404 });\n  }\n\n  const enabled = data.enabled !== undefined ? data.enabled : Boolean(existing.enabled);\n  const cron = data.cron !== undefined ? data.cron : existing.cron as string | null;\n\n  let nextRunAt: string | null = null;\n  if (cron && enabled) {\n    const next = c\u043EmputeNextRun(cron);\n    nextRunAt = next ? next.toISOString() : null;\n  }\n  // nextRunAt is null if disabled OR if cron is removed/empty\n\n  await env.DB.prepare(`\n    UPDATE schedules SET\n      name = COALESCE(?, name),\n      cron = ?,\n      event_trigger = ?,\n      enabled = ?,\n      next_run_at = ?\n    WHERE id = ?\n  `).bind(\n    data.name || null,\n    data.cron !== undefined ? data.cron : existing.cron,\n    data.eventTrigger !== undefined ? data.eventTrigger : existing.event_trigger,\n    enabled ? 1 : 0,\n    nextRunAt,\n    scheduleId\n  ).run();\n\n  const updated = await env.DB.prepare(`\n    SELECT * FROM schedules WHERE id = ?\n  `).bind(scheduleId).first();\n\n  return Response.json({\n    schedule: {\n      id: updated!.id,\n      recipeId: updated!.recipe_id,\n      name: updated!.name,\n      cron: updated!.cron,\n      eventTrigger: updated!.event_trigger,\n      enabled: Boolean(updated!.enabled),\n      lastRunAt: updated!.last_run_at,\n      nextRunAt: updated!.next_run_at,\n      createdAt: updated!.created_at,\n    }\n  });\n}\n\n// Delete a schedule (owner only)\n// Uses atomic delete with ownership verification to prevent TOCTOU race conditions\nexport async function d\u0435leteSchedule(\n  env: Env,\n  scheduleId: string,\n  userId: string\n): Promise<Response> {\n  // Atomic delete: verify ownership in the DELETE query itself (defense-in-depth)\n  // Ownership is through: schedule -> recipe -> dashboard -> dashboard_members\n  const result = await env.DB.prepare(`\n    DELETE FROM schedules\n    WHERE id = ?\n    AND (\n      -- Check ownership via dashboard membership (owner role required)\n      recipe_id IN (\n        SELECT r.id FROM recipes r\n        INNER JOIN dashboard_members dm ON r.dashboard_id = dm.dashboard_id\n        WHERE dm.user_id = ? AND dm.role = 'owner'\n      )\n    )\n  `).bind(scheduleId, userId).run();\n\n  if (result.meta.changes === 0) {\n    return Response.json({ error: 'E79728: Schedule not found or no access' }, { status: 404 });\n  }\n\n  return new Response(null, { status: 204 });\n}\n\n// Enable a schedule\nexport async function enableSchedule(\n  env: Env,\n  scheduleId: string,\n  userId: string\n): Promise<Response> {\n  return updateSchedule(env, scheduleId, userId, { enabled: true });\n}\n\n// Disable a schedule\nexport async function disableSchedule(\n  env: Env,\n  scheduleId: string,\n  userId: string\n): Promise<Response> {\n  return updateSchedule(env, scheduleId, userId, { enabled: false });\n}\n\n// Trigger a schedule manually\nexport async function triggerSchedule(\n  env: Env,\n  scheduleId: string,\n  userId: string\n): Promise<Response> {\n  const { hasAccess, schedule } = await checkSchedul\u0435Access(env, scheduleId, userId, 'editor');\n\n  if (!hasAccess || !schedule) {\n    return Response.json({ error: 'E79728: Schedule not found or no access' }, { status: 404 });\n  }\n\n  // Start execution with actor context\n  const executionResponse = await recipes.startExecuti\u043En(\n    env,\n    schedule.recipe_id as string,\n    userId,\n    { triggeredBy: 'manual', scheduleId, actorUserId: userId }\n  );\n\n  // Update last run\n  const now = new Date().toISOString();\n  let nextRunAt: string | null = null;\n  if (schedule.cron && schedule.enabled) {\n    const next = c\u043EmputeNextRun(schedule.cron as string);\n    nextRunAt = next ? next.toISOString() : null;\n  }\n\n  await env.DB.prepare(`\n    UPDATE schedules SET last_run_at = ?, next_run_at = ? WHERE id = ?\n  `).bind(now, nextRunAt, scheduleId).run();\n\n  const executionData = await executionResponse.json() as { execution: unknown };\n  return Response.json({\n    schedule: {\n      id: schedule.id,\n      recipeId: schedule.recipe_id,\n      name: schedule.name,\n      lastRunAt: now,\n      nextRunAt,\n    },\n    execution: executionData.execution,\n  });\n}\n\n// Process due schedules (called by cron trigger)\nexport async function pr\u043EcessDueSchedules(env: Env): Promise<void> {\n  const now = new Date().toISOString();\n\n  // Find all enabled schedules with cron that are due\n  const dueSchedules = await env.DB.prepare(`\n    SELECT * FROM schedules\n    WHERE enabled = 1 AND cron IS NOT NULL AND next_run_at <= ?\n  `).bind(now).all();\n\n  for (const schedule of dueSchedules.results) {\n    try {\n      // Start execution (internal - no user context for cron triggers)\n      await recipes.startExecuti\u043EnInternal(\n        env,\n        schedule.recipe_id as string,\n        { triggeredBy: 'cron', scheduleId: schedule.id }\n      );\n\n      // Compute next run\n      const next = c\u043EmputeNextRun(schedule.cron as string);\n      const nextRunAt = next ? next.toISOString() : null;\n\n      // Update last run and next run\n      await env.DB.prepare(`\n        UPDATE schedules SET last_run_at = ?, next_run_at = ? WHERE id = ?\n      `).bind(now, nextRunAt, schedule.id).run();\n    } catch (error) {\n      console.error(`Failed to process schedule ${schedule.id}:`, error);\n    }\n  }\n}\n\n// Emit an event (triggers event-based schedules)\nexport async function emitEvent(\n  env: Env,\n  eventName: string,\n  payload?: Record<string, unknown>\n): Promise<Response> {\n  // Find all enabled schedules with matching event trigger\n  const schedules = await env.DB.prepare(`\n    SELECT * FROM schedules\n    WHERE enabled = 1 AND event_trigger = ?\n  `).bind(eventName).all();\n\n  const executions: unknown[] = [];\n  const now = new Date().toISOString();\n\n  for (const schedule of schedules.results) {\n    try {\n      // Start execution (internal - no user context for event triggers)\n      const executionResponse = await recipes.startExecuti\u043EnInternal(\n        env,\n        schedule.recipe_id as string,\n        { triggeredBy: 'event', eventName, payload, scheduleId: schedule.id }\n      );\n\n      const executionData = await executionResponse.json() as { execution: unknown };\n      executions.push(executionData.execution);\n\n      // Update last run\n      await env.DB.prepare(`\n        UPDATE schedules SET last_run_at = ? WHERE id = ?\n      `).bind(now, schedule.id).run();\n    } catch (error) {\n      console.error(`Failed to trigger schedule ${schedule.id} for event ${eventName}:`, error);\n    }\n  }\n\n  return Response.json({\n    event: eventName,\n    schedulesTriggered: schedules.results.length,\n    executions,\n  });\n}\n", "// Copyright 2026 Robert Macrae. All rights reserved.\n// SPDX-License-Identifier: LicenseRef-Proprietary\n\nimport type { Env, UserSubagent } from '../types';\n\n/**\n * Safely parse JSON with a fallback value.\n * Prevents crashes from corrupted database entries.\n */\nfunction saf\u0435JsonParse<T>(json: string | null | undefined, fallback: T): T {\n  if (!json) return fallback;\n  try {\n    return JSON.parse(json) as T;\n  } catch (error) {\n    console.error('Failed to parse JSON:', error, 'Input:', json?.substring(0, 100));\n    return fallback;\n  }\n}\n\nfunction formatSubagent(row: Record<string, unknown>): UserSubagent {\n  return {\n    id: row.id as string,\n    userId: row.user_id as string,\n    name: row.name as string,\n    description: (row.description as string) || '',\n    prompt: (row.prompt as string) || '',\n    tools: saf\u0435JsonParse<string[]>((row.tools as string) || '[]', []),\n    source: (row.source as string) || 'custom',\n    createdAt: row.created_at as string,\n    updatedAt: row.updated_at as string,\n  };\n}\n\nexport async function listSubagents(env: Env, userId: string): Promise<Response> {\n  const rows = await env.DB.prepare(\n    `SELECT * FROM user_subagents WHERE user_id = ? ORDER BY updated_at DESC`\n  )\n    .bind(userId)\n    .all();\n\n  return Response.json({\n    subagents: rows.results.map((row) => formatSubagent(row as Record<string, unknown>)),\n  });\n}\n\nexport async function createSubagent(\n  env: Env,\n  userId: string,\n  data: Partial<UserSubagent>\n): Promise<Response> {\n  if (!data.name || !data.prompt) {\n    return Response.json({ error: 'E79721: name and prompt are required' }, { status: 400 });\n  }\n\n  const id = data.id || crypto.randomUUID();\n  const tools = JSON.stringify(data.tools || []);\n  const description = data.description || '';\n  const source = data.source || 'custom';\n\n  await env.DB.prepare(\n    `INSERT INTO user_subagents (id, user_id, name, description, prompt, tools, source, created_at, updated_at)\n     VALUES (?, ?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'))`\n  )\n    .bind(id, userId, data.name, description, data.prompt, tools, source)\n    .run();\n\n  const row = await env.DB.prepare(`SELECT * FROM user_subagents WHERE id = ?`)\n    .bind(id)\n    .first();\n\n  return Response.json({ subagent: formatSubagent(row as Record<string, unknown>) });\n}\n\nexport async function deleteSubagent(env: Env, userId: string, id: string): Promise<Response> {\n  const result = await env.DB.prepare(\n    `DELETE FROM user_subagents WHERE id = ? AND user_id = ?`\n  )\n    .bind(id, userId)\n    .run();\n\n  if (result.meta.changes === 0) {\n    return Response.json({ error: 'E79722: Subagent not found' }, { status: 404 });\n  }\n\n  return new Response(null, { status: 204 });\n}\n", "// Copyright 2026 Robert Macrae. All rights reserved.\n// SPDX-License-Identifier: LicenseRef-Proprietary\n\nimport type { Env, UserSecret } from '../types';\n\nfunction formatSecret(row: Record<string, unknown>): UserSecret {\n  return {\n    id: row.id as string,\n    userId: row.user_id as string,\n    dashboardId: row.dashboard_id as string,\n    name: row.name as string,\n    description: (row.description as string) || '',\n    createdAt: row.created_at as string,\n    updatedAt: row.updated_at as string,\n  };\n}\n\nasync function ensureDashboardAccess(\n  env: Env,\n  dashboardId: string,\n  userId: string\n): Promise<{ role: string } | null> {\n  const access = await env.DB.prepare(\n    `SELECT role FROM dashboard_members WHERE dashboard_id = ? AND user_id = ?`\n  )\n    .bind(dashboardId, userId)\n    .first<{ role: string }>();\n  return access ?? null;\n}\n\nexport async function listSecrets(\n  env: Env,\n  userId: string,\n  dashboardId: string | null\n): Promise<Response> {\n  if (!dashboardId) {\n    return Response.json({ error: 'E79733: dashboard_id is required' }, { status: 400 });\n  }\n\n  const access = await ensureDashboardAccess(env, dashboardId, userId);\n  if (!access) {\n    return Response.json({ error: 'E79734: Not found or no access' }, { status: 404 });\n  }\n\n  const rows = await env.DB.prepare(\n    `SELECT id, user_id, dashboard_id, name, description, created_at, updated_at\n     FROM user_secrets\n     WHERE user_id = ? AND dashboard_id = ?\n     ORDER BY updated_at DESC`\n  )\n    .bind(userId, dashboardId)\n    .all();\n\n  return Response.json({\n    secrets: rows.results.map((row) => formatSecret(row as Record<string, unknown>)),\n  });\n}\n\nexport async function createSecret(\n  env: Env,\n  userId: string,\n  data: Partial<UserSecret> & { value?: string }\n): Promise<Response> {\n  if (!data.dashboardId || !data.name || !data.value) {\n    return Response.json({ error: 'E79731: dashboard_id, name, and value are required' }, { status: 400 });\n  }\n\n  const access = await ensureDashboardAccess(env, data.dashboardId, userId);\n  if (!access || (access.role !== 'owner' && access.role !== 'editor')) {\n    return Response.json({ error: 'E79735: Not found or no edit access' }, { status: 404 });\n  }\n\n  const id = crypto.randomUUID();\n  const description = data.description || '';\n\n  await env.DB.prepare(\n    `INSERT INTO user_secrets (id, user_id, dashboard_id, name, value, description, created_at, updated_at)\n     VALUES (?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'))`\n  )\n    .bind(id, userId, data.dashboardId, data.name, data.value, description)\n    .run();\n\n  const row = await env.DB.prepare(\n    `SELECT id, user_id, dashboard_id, name, description, created_at, updated_at\n     FROM user_secrets WHERE id = ?`\n  )\n    .bind(id)\n    .first();\n\n  return Response.json({ secret: formatSecret(row as Record<string, unknown>) });\n}\n\nexport async function deleteSecret(\n  env: Env,\n  userId: string,\n  id: string,\n  dashboardId: string | null\n): Promise<Response> {\n  if (!dashboardId) {\n    return Response.json({ error: 'E79736: dashboard_id is required' }, { status: 400 });\n  }\n\n  const access = await ensureDashboardAccess(env, dashboardId, userId);\n  if (!access || (access.role !== 'owner' && access.role !== 'editor')) {\n    return Response.json({ error: 'E79737: Not found or no edit access' }, { status: 404 });\n  }\n\n  const result = await env.DB.prepare(\n    `DELETE FROM user_secrets WHERE id = ? AND user_id = ? AND dashboard_id = ?`\n  )\n    .bind(id, userId, dashboardId)\n    .run();\n\n  if (result.meta.changes === 0) {\n    return Response.json({ error: 'E79732: Secret not found' }, { status: 404 });\n  }\n\n  return new Response(null, { status: 204 });\n}\n", "// Copyright 2026 Robert Macrae. All rights reserved.\n// SPDX-License-Identifier: LicenseRef-Proprietary\n\nimport type { Env, UserAgentSkill } from '../types';\n\nfunction safeParseJson<T>(value: unknown, fallback: T): T {\n  if (typeof value !== 'string') return fallback;\n  try {\n    return JSON.parse(value) as T;\n  } catch {\n    return fallback;\n  }\n}\n\nfunction formatAgentSkill(row: Record<string, unknown>): UserAgentSkill {\n  return {\n    id: row.id as string,\n    userId: row.user_id as string,\n    name: row.name as string,\n    description: (row.description as string) || '',\n    command: (row.command as string) || '',\n    args: safeParseJson<string[]>(row.args, []),\n    source: (row.source as string) || 'custom',\n    createdAt: row.created_at as string,\n    updatedAt: row.updated_at as string,\n  };\n}\n\nexport async function listAgentSkills(env: Env, userId: string): Promise<Response> {\n  const rows = await env.DB.prepare(\n    `SELECT * FROM user_agent_skills WHERE user_id = ? ORDER BY updated_at DESC`\n  )\n    .bind(userId)\n    .all();\n\n  return Response.json({\n    skills: rows.results.map((row) => formatAgentSkill(row as Record<string, unknown>)),\n  });\n}\n\nexport async function createAgentSkill(\n  env: Env,\n  userId: string,\n  data: Partial<UserAgentSkill>\n): Promise<Response> {\n  if (!data.name || !data.command) {\n    return Response.json({ error: 'E79723: name and command are required' }, { status: 400 });\n  }\n\n  const id = data.id || crypto.randomUUID();\n  const args = JSON.stringify(data.args || []);\n  const description = data.description || '';\n  const source = data.source || 'custom';\n\n  await env.DB.prepare(\n    `INSERT INTO user_agent_skills (id, user_id, name, description, command, args, source, created_at, updated_at)\n     VALUES (?, ?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'))`\n  )\n    .bind(id, userId, data.name, description, data.command, args, source)\n    .run();\n\n  const row = await env.DB.prepare(`SELECT * FROM user_agent_skills WHERE id = ?`)\n    .bind(id)\n    .first();\n\n  return Response.json({ skill: formatAgentSkill(row as Record<string, unknown>) });\n}\n\nexport async function deleteAgentSkill(env: Env, userId: string, id: string): Promise<Response> {\n  const result = await env.DB.prepare(\n    `DELETE FROM user_agent_skills WHERE id = ? AND user_id = ?`\n  )\n    .bind(id, userId)\n    .run();\n\n  if (result.meta.changes === 0) {\n    return Response.json({ error: 'E79724: Agent skill not found' }, { status: 404 });\n  }\n\n  return new Response(null, { status: 204 });\n}\n", "// Copyright 2026 Robert Macrae. All rights reserved.\n// SPDX-License-Identifier: LicenseRef-Proprietary\n\nimport type { Env, UserMcpTool } from '../types';\n\nfunction safeParseJson<T>(value: unknown, fallback: T): T {\n  if (typeof value !== 'string') return fallback;\n  try {\n    return JSON.parse(value) as T;\n  } catch {\n    return fallback;\n  }\n}\n\nfunction f\u043ErmatMcpT\u043E\u043El(row: Record<string, unknown>): UserMcpTool {\n  return {\n    id: row.id as string,\n    userId: row.user_id as string,\n    name: row.name as string,\n    description: (row.description as string) || '',\n    serverUrl: (row.server_url as string) || '',\n    transport: (row.transport as 'stdio' | 'sse' | 'streamable-http') || 'stdio',\n    config: safeParseJson<Record<string, unknown>>(row.config, {}),\n    source: (row.source as string) || 'custom',\n    createdAt: row.created_at as string,\n    updatedAt: row.updated_at as string,\n  };\n}\n\nexport async function listMcpT\u043E\u043Els(env: Env, userId: string): Promise<Response> {\n  const rows = await env.DB.prepare(\n    `SELECT * FROM user_mcp_tools WHERE user_id = ? ORDER BY updated_at DESC`\n  )\n    .bind(userId)\n    .all();\n\n  return Response.json({\n    tools: rows.results.map((row) => f\u043ErmatMcpT\u043E\u043El(row as Record<string, unknown>)),\n  });\n}\n\nexport async function createMcpT\u043E\u043El(\n  env: Env,\n  userId: string,\n  data: Partial<UserMcpTool>\n): Promise<Response> {\n  if (!data.name || !data.serverUrl) {\n    return Response.json({ error: 'E79101: name and serverUrl are required' }, { status: 400 });\n  }\n\n  const validTransports = ['stdio', 'sse', 'streamable-http'] as const;\n  const transport = data.transport || 'stdio';\n  if (!validTransports.includes(transport)) {\n    return Response.json(\n      { error: `transport must be one of: ${validTransports.join(', ')}` },\n      { status: 400 }\n    );\n  }\n\n  const id = data.id || crypto.randomUUID();\n  const config = JSON.stringify(data.config || {});\n  const description = data.description || '';\n  const source = data.source || 'custom';\n\n  await env.DB.prepare(\n    `INSERT INTO user_mcp_tools (id, user_id, name, description, server_url, transport, config, source, created_at, updated_at)\n     VALUES (?, ?, ?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'))`\n  )\n    .bind(id, userId, data.name, description, data.serverUrl, transport, config, source)\n    .run();\n\n  const row = await env.DB.prepare(`SELECT * FROM user_mcp_tools WHERE id = ?`)\n    .bind(id)\n    .first();\n\n  return Response.json({ tool: f\u043ErmatMcpT\u043E\u043El(row as Record<string, unknown>) });\n}\n\nexport async function deleteMcpT\u043E\u043El(env: Env, userId: string, id: string): Promise<Response> {\n  const result = await env.DB.prepare(\n    `DELETE FROM user_mcp_tools WHERE id = ? AND user_id = ?`\n  )\n    .bind(id, userId)\n    .run();\n\n  if (result.meta.changes === 0) {\n    return Response.json({ error: 'E79102: MCP tool not found' }, { status: 404 });\n  }\n\n  return new Response(null, { status: 204 });\n}\n", "// Copyright 2026 Robert Macrae. All rights reserved.\n// SPDX-License-Identifier: LicenseRef-Proprietary\n\nimport type { EnvWithDriveCache } from '../storage/drive-cache';\nimport type { AuthContext } from '../auth/middleware';\nimport { requireAuth } from '../auth/middleware';\n\nconst GOOGLE_SCOPE = [\n  'https://www.googleapis.com/auth/drive',\n];\n\nconst GITHUB_SCOPE = [\n  'repo',\n  'read:user',\n  'user:email',\n];\n\nconst BOX_SCOPE = [\n  'root_readonly',\n];\n\nconst ONEDRIVE_SCOPE = [\n  'offline_access',\n  'Files.Read',\n];\n\nconst DRIVE_AUTO_SYNC_LIMIT_BYTES = 1024 * 1024 * 1024;\nconst DRIVE_MANIFEST_VERSION = 1;\nconst DRIVE_UPLOAD_BUFFER_LIMIT_BYTES = 25 * 1024 * 1024;\nconst DRIVE_UPLOAD_PART_BYTES = 8 * 1024 * 1024;\n\ninterface DriveFileEntry {\n  id: string;\n  name: string;\n  path: string;\n  mimeType: string;\n  size: number;\n  modifiedTime: string | null;\n  md5Checksum: string | null;\n  cacheStatus: 'cached' | 'skipped_large' | 'skipped_unsupported';\n  placeholder?: string;\n}\n\ninterface DriveManifest {\n  version: number;\n  folderId: string;\n  folderName: string;\n  folderPath: string;\n  updatedAt: string;\n  directories: string[];\n  entries: DriveFileEntry[];\n}\n\nfunction concatBytes(left: Uint8Array, right: Uint8Array): Uint8Array {\n  const next = new Uint8Array(left.length + right.length);\n  next.set(left);\n  next.set(right, left.length);\n  return next;\n}\n\nasync function uploadDriveFileToCache(\n  env: EnvWithDriveCache,\n  key: string,\n  response: Response,\n  size: number\n) {\n  if (!response.body) {\n    throw new Error('Drive download missing body');\n  }\n  const contentType = response.headers.get('content-type') || 'application/octet-stream';\n\n  if (size <= DRIVE_UPLOAD_BUFFER_LIMIT_BYTES) {\n    const buffer = await response.arrayBuffer();\n    await env.DRIVE_CACHE.put(key, buffer, {\n      httpMetadata: { contentType },\n    });\n    return;\n  }\n\n  const upload = await env.DRIVE_CACHE.createMultipartUpload(key, {\n    httpMetadata: { contentType },\n  });\n\n  const parts: Array<{ partNumber: number; etag: string }> = [];\n  const reader = response.body.getReader();\n  let buffer = new Uint8Array(0);\n  let partNumber = 1;\n\n  try {\n    while (true) {\n      const { value, done } = await reader.read();\n      if (done) break;\n      if (value) {\n        buffer = concatBytes(buffer, value);\n      }\n      while (buffer.length >= DRIVE_UPLOAD_PART_BYTES) {\n        const chunk = buffer.slice(0, DRIVE_UPLOAD_PART_BYTES);\n        const uploaded = await upload.uploadPart(partNumber, chunk);\n        parts.push({ partNumber, etag: uploaded.etag });\n        buffer = buffer.slice(DRIVE_UPLOAD_PART_BYTES);\n        partNumber += 1;\n      }\n    }\n\n    if (buffer.length > 0) {\n      const uploaded = await upload.uploadPart(partNumber, buffer);\n      parts.push({ partNumber, etag: uploaded.etag });\n    }\n\n    await upload.complete(parts);\n  } catch (error) {\n    try {\n      await upload.abort();\n    } catch {\n      // Ignore abort errors.\n    }\n    throw error;\n  }\n}\n\nfunction getRedirectBase(request: Request, env: EnvWithDriveCache): string {\n  if (env.OAUTH_REDIRECT_BASE) {\n    return env.OAUTH_REDIRECT_BASE.replace(/\\/$/, '');\n  }\n  return new URL(request.url).origin;\n}\n\nfunction sanitizePathSegment(value: string): string {\n  const trimmed = value.trim();\n  if (!trimmed) {\n    return 'Drive';\n  }\n  return trimmed.replace(/[\\\\/]/g, '-');\n}\n\nfunction driveManifestKey(dashboardId: string): string {\n  return `drive/${dashboardId}/manifest.json`;\n}\n\nfunction driveFileKey(dashboardId: string, fileId: string): string {\n  return `drive/${dashboardId}/files/${fileId}`;\n}\n\nfunction mirrorManifestKey(provider: string, dashboardId: string): string {\n  return `mirror/${provider}/${dashboardId}/manifest.json`;\n}\n\nfunction mirrorFileKey(provider: string, dashboardId: string, fileId: string): string {\n  return `mirror/${provider}/${dashboardId}/files/${fileId}`;\n}\n\n/**\n * Escape HTML special characters to prevent XSS attacks.\n */\nfunction escapeHtml(unsafe: string): string {\n  return unsafe\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#039;');\n}\n\nfunction buildState(): string {\n  return crypto.randomUUID();\n}\n\nasync function createState(\n  env: EnvWithDriveCache,\n  userId: string,\n  provider: string,\n  state: string,\n  metadata: Record<string, unknown> = {}\n) {\n  await env.DB.prepare(`\n    INSERT INTO oauth_states (state, user_id, provider, metadata)\n    VALUES (?, ?, ?, ?)\n  `).bind(state, userId, provider, JSON.stringify(metadata)).run();\n}\n\nasync function consumeState(env: EnvWithDriveCache, state: string, provider: string) {\n  const record = await env.DB.prepare(`\n    SELECT user_id as userId, metadata FROM oauth_states WHERE state = ? AND provider = ?\n  `).bind(state, provider).first<{ userId: string; metadata: string }>();\n\n  if (!record) {\n    return null;\n  }\n\n  await env.DB.prepare(`\n    DELETE FROM oauth_states WHERE state = ?\n  `).bind(state).run();\n\n  let metadata: Record<string, unknown> = {};\n  try {\n    metadata = JSON.parse(record.metadata || '{}') as Record<string, unknown>;\n  } catch {\n    metadata = {};\n  }\n\n  return { userId: record.userId, metadata };\n}\n\nasync function refreshGoogleAccessToken(env: EnvWithDriveCache, userId: string): Promise<string> {\n  if (!env.GOOGLE_CLIENT_ID || !env.GOOGLE_CLIENT_SECRET) {\n    throw new Error('Google OAuth is not configured.');\n  }\n\n  const record = await env.DB.prepare(`\n    SELECT access_token, refresh_token FROM user_integrations\n    WHERE user_id = ? AND provider = 'google_drive'\n  `).bind(userId).first<{ access_token: string; refresh_token: string | null }>();\n\n  if (!record?.refresh_token) {\n    throw new Error('Google Drive must be connected again.');\n  }\n\n  const body = new URLSearchParams();\n  body.set('client_id', env.GOOGLE_CLIENT_ID);\n  body.set('client_secret', env.GOOGLE_CLIENT_SECRET);\n  body.set('grant_type', 'refresh_token');\n  body.set('refresh_token', record.refresh_token);\n\n  const tokenResponse = await fetch('https://oauth2.googleapis.com/token', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n    body,\n  });\n\n  if (!tokenResponse.ok) {\n    throw new Error('Failed to refresh Google access token.');\n  }\n\n  const tokenData = await tokenResponse.json() as {\n    access_token: string;\n    expires_in?: number;\n    scope?: string;\n    token_type?: string;\n  };\n\n  const now = new Date();\n  const expiresAt = tokenData.expires_in\n    ? new Date(now.getTime() + tokenData.expires_in * 1000).toISOString()\n    : null;\n\n  await env.DB.prepare(`\n    UPDATE user_integrations\n    SET access_token = ?, scope = ?, token_type = ?, expires_at = ?, updated_at = datetime('now')\n    WHERE user_id = ? AND provider = 'google_drive'\n  `).bind(\n    tokenData.access_token,\n    tokenData.scope || null,\n    tokenData.token_type || null,\n    expiresAt,\n    userId\n  ).run();\n\n  return tokenData.access_token;\n}\n\nasync function refreshBoxAccessToken(env: EnvWithDriveCache, userId: string): Promise<string> {\n  if (!env.BOX_CLIENT_ID || !env.BOX_CLIENT_SECRET) {\n    throw new Error('Box OAuth is not configured.');\n  }\n\n  const record = await env.DB.prepare(`\n    SELECT access_token, refresh_token FROM user_integrations\n    WHERE user_id = ? AND provider = 'box'\n  `).bind(userId).first<{ access_token: string; refresh_token: string | null }>();\n\n  if (!record?.refresh_token) {\n    throw new Error('Box must be connected again.');\n  }\n\n  const body = new URLSearchParams();\n  body.set('client_id', env.BOX_CLIENT_ID);\n  body.set('client_secret', env.BOX_CLIENT_SECRET);\n  body.set('grant_type', 'refresh_token');\n  body.set('refresh_token', record.refresh_token);\n\n  const tokenResponse = await fetch('https://api.box.com/oauth2/token', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n    body,\n  });\n\n  if (!tokenResponse.ok) {\n    throw new Error('Failed to refresh Box access token.');\n  }\n\n  const tokenData = await tokenResponse.json() as {\n    access_token: string;\n    refresh_token?: string;\n    expires_in?: number;\n    token_type?: string;\n  };\n\n  const now = new Date();\n  const expiresAt = tokenData.expires_in\n    ? new Date(now.getTime() + tokenData.expires_in * 1000).toISOString()\n    : null;\n\n  await env.DB.prepare(`\n    UPDATE user_integrations\n    SET access_token = ?, refresh_token = ?, token_type = ?, expires_at = ?, updated_at = datetime('now')\n    WHERE user_id = ? AND provider = 'box'\n  `).bind(\n    tokenData.access_token,\n    tokenData.refresh_token || record.refresh_token,\n    tokenData.token_type || null,\n    expiresAt,\n    userId\n  ).run();\n\n  return tokenData.access_token;\n}\n\nasync function refreshOnedriveAccessToken(env: EnvWithDriveCache, userId: string): Promise<string> {\n  if (!env.ONEDRIVE_CLIENT_ID || !env.ONEDRIVE_CLIENT_SECRET) {\n    throw new Error('OneDrive OAuth is not configured.');\n  }\n\n  const record = await env.DB.prepare(`\n    SELECT access_token, refresh_token FROM user_integrations\n    WHERE user_id = ? AND provider = 'onedrive'\n  `).bind(userId).first<{ access_token: string; refresh_token: string | null }>();\n\n  if (!record?.refresh_token) {\n    throw new Error('OneDrive must be connected again.');\n  }\n\n  const body = new URLSearchParams();\n  body.set('client_id', env.ONEDRIVE_CLIENT_ID);\n  body.set('client_secret', env.ONEDRIVE_CLIENT_SECRET);\n  body.set('grant_type', 'refresh_token');\n  body.set('refresh_token', record.refresh_token);\n  body.set('scope', ONEDRIVE_SCOPE.join(' '));\n\n  const tokenResponse = await fetch('https://login.microsoftonline.com/common/oauth2/v2.0/token', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n    body,\n  });\n\n  if (!tokenResponse.ok) {\n    throw new Error('Failed to refresh OneDrive access token.');\n  }\n\n  const tokenData = await tokenResponse.json() as {\n    access_token: string;\n    refresh_token?: string;\n    expires_in?: number;\n    token_type?: string;\n  };\n\n  const now = new Date();\n  const expiresAt = tokenData.expires_in\n    ? new Date(now.getTime() + tokenData.expires_in * 1000).toISOString()\n    : null;\n\n  await env.DB.prepare(`\n    UPDATE user_integrations\n    SET access_token = ?, refresh_token = ?, token_type = ?, expires_at = ?, updated_at = datetime('now')\n    WHERE user_id = ? AND provider = 'onedrive'\n  `).bind(\n    tokenData.access_token,\n    tokenData.refresh_token || record.refresh_token,\n    tokenData.token_type || null,\n    expiresAt,\n    userId\n  ).run();\n\n  return tokenData.access_token;\n}\n\nfunction joinDrivePath(parent: string, name: string): string {\n  if (!parent) return name;\n  return `${parent}/${name}`;\n}\n\nasync function listDriveChildren(\n  accessToken: string,\n  folderId: string\n): Promise<Array<{\n  id: string;\n  name: string;\n  mimeType: string;\n  size?: string;\n  modifiedTime?: string;\n  md5Checksum?: string;\n}>> {\n  const files: Array<{\n    id: string;\n    name: string;\n    mimeType: string;\n    size?: string;\n    modifiedTime?: string;\n    md5Checksum?: string;\n  }> = [];\n  let pageToken: string | null = null;\n\n  do {\n    const url = new URL('https://www.googleapis.com/drive/v3/files');\n    url.searchParams.set('q', `'${folderId}' in parents and trashed = false`);\n    url.searchParams.set('pageSize', '1000');\n    url.searchParams.set('fields', 'nextPageToken,files(id,name,mimeType,size,modifiedTime,md5Checksum)');\n    url.searchParams.set('supportsAllDrives', 'true');\n    url.searchParams.set('includeItemsFromAllDrives', 'true');\n    if (pageToken) {\n      url.searchParams.set('pageToken', pageToken);\n    }\n\n    const res = await fetch(url.toString(), {\n      headers: { Authorization: `Bearer ${accessToken}` },\n    });\n\n    if (!res.ok) {\n      throw new Error('Failed to list Google Drive folder.');\n    }\n\n    const data = await res.json() as {\n      files?: Array<{\n        id: string;\n        name: string;\n        mimeType: string;\n        size?: string;\n        modifiedTime?: string;\n        md5Checksum?: string;\n      }>;\n      nextPageToken?: string;\n    };\n\n    if (data.files) {\n      files.push(...data.files);\n    }\n    pageToken = data.nextPageToken ?? null;\n  } while (pageToken);\n\n  return files;\n}\n\nasync function buildDriveManifest(\n  accessToken: string,\n  folderId: string,\n  folderName: string\n): Promise<{ manifest: DriveManifest; entries: DriveFileEntry[] }> {\n  const queue: Array<{ id: string; path: string }> = [{ id: folderId, path: '' }];\n  const entries: DriveFileEntry[] = [];\n  const directories: string[] = [];\n\n  while (queue.length > 0) {\n    const current = queue.shift()!;\n    if (current.path) {\n      directories.push(current.path);\n    }\n    const children = await listDriveChildren(accessToken, current.id);\n    for (const child of children) {\n      if (child.mimeType === 'application/vnd.google-apps.folder') {\n        queue.push({ id: child.id, path: joinDrivePath(current.path, child.name) });\n        continue;\n      }\n      const size = child.size ? Number(child.size) : 0;\n      entries.push({\n        id: child.id,\n        name: child.name,\n        path: joinDrivePath(current.path, child.name),\n        mimeType: child.mimeType,\n        size: Number.isNaN(size) ? 0 : size,\n        modifiedTime: child.modifiedTime || null,\n        md5Checksum: child.md5Checksum || null,\n        cacheStatus: 'cached',\n      });\n    }\n  }\n\n  const safeFolderName = sanitizePathSegment(folderName);\n  const now = new Date().toISOString();\n  const manifest: DriveManifest = {\n    version: DRIVE_MANIFEST_VERSION,\n    folderId,\n    folderName,\n    folderPath: `drive/${safeFolderName}`,\n    updatedAt: now,\n    directories,\n    entries,\n  };\n\n  return { manifest, entries };\n}\n\nfunction renderSuccessPage(providerLabel: string): Response {\n  const safeLabel = escapeHtml(providerLabel);\n  return new Response(\n    `<!doctype html>\n<html>\n  <head>\n    <meta charset=\"utf-8\" />\n    <title>${safeLabel} connected</title>\n    <style>\n      body { font-family: system-ui, sans-serif; padding: 32px; }\n      .card { max-width: 520px; margin: 0 auto; }\n      h1 { font-size: 20px; margin: 0 0 8px; }\n      p { margin: 0 0 16px; color: #4b5563; }\n      button { padding: 8px 12px; border: 1px solid #e5e7eb; border-radius: 6px; background: #111827; color: #fff; cursor: pointer; }\n    </style>\n  </head>\n  <body>\n    <div class=\"card\">\n      <h1>${safeLabel} connected</h1>\n      <p>You can close this tab and return to OrcaBot.</p>\n      <button onclick=\"window.close()\">Close tab</button>\n    </div>\n  </body>\n</html>`,\n    {\n      headers: { 'Content-Type': 'text/html; charset=utf-8' },\n    }\n  );\n}\n\nfunction renderDrivePickerPage(\n  accessToken: string,\n  apiKey: string,\n  frontendUrl: string,\n  dashboardId: string | null\n): Response {\n  const tokenJson = JSON.stringify(accessToken);\n  const apiKeyJson = JSON.stringify(apiKey);\n  const frontendJson = JSON.stringify(frontendUrl);\n  const dashboardJson = JSON.stringify(dashboardId);\n  const frontendOrigin = new URL(frontendUrl).origin;\n  return new Response(\n    `<!doctype html>\n<html>\n  <head>\n    <meta charset=\"utf-8\" />\n    <title>Google Drive connected</title>\n    <style>\n      body { font-family: system-ui, sans-serif; padding: 32px; }\n      .card { max-width: 520px; margin: 0 auto; }\n      h1 { font-size: 20px; margin: 0 0 8px; }\n      p { margin: 0 0 16px; color: #4b5563; }\n      button { padding: 8px 12px; border: 1px solid #e5e7eb; border-radius: 6px; background: #111827; color: #fff; cursor: pointer; }\n      .status { font-size: 12px; margin-top: 12px; color: #6b7280; }\n    </style>\n    <script src=\"https://apis.google.com/js/api.js\"></script>\n  </head>\n  <body>\n    <div class=\"card\">\n      <h1>Google Drive connected</h1>\n      <p>Select a Drive folder to link to OrcaBot.</p>\n      <button id=\"picker-button\" type=\"button\">Select Drive folder</button>\n      <div class=\"status\" id=\"status\">Loading Google Picker...</div>\n    </div>\n    <script>\n      const accessToken = ${tokenJson};\n      const apiKey = ${apiKeyJson};\n      const dashboardId = ${dashboardJson};\n      const statusEl = document.getElementById('status');\n      const frontendUrl = ${frontendJson};\n      const frontendOrigin = ${JSON.stringify(frontendOrigin)};\n      const buttonEl = document.getElementById('picker-button');\n      let pickerLoaded = false;\n\n      function setStatus(message) {\n        if (statusEl) statusEl.textContent = message;\n      }\n\n      function onPickerReady() {\n        pickerLoaded = true;\n        openPicker();\n      }\n\n      function openPicker() {\n        if (!pickerLoaded) {\n          setStatus('Google Picker failed to load.');\n          return;\n        }\n        const view = new google.picker.DocsView(google.picker.ViewId.FOLDERS)\n          .setIncludeFolders(true)\n          .setSelectFolderEnabled(true);\n        const picker = new google.picker.PickerBuilder()\n          .addView(view)\n          .setOAuthToken(accessToken)\n          .setDeveloperKey(apiKey)\n          .setOrigin(frontendOrigin)\n          .setCallback(pickerCallback)\n          .build();\n        picker.setVisible(true);\n      }\n\n      function pickerCallback(data) {\n        if (data.action !== google.picker.Action.PICKED) {\n          if (data.action === google.picker.Action.CANCEL) {\n            setStatus('Folder selection canceled.');\n          }\n          return;\n        }\n\n        const doc = data.docs && data.docs[0];\n        if (!doc) {\n          setStatus('No folder selected.');\n          return;\n        }\n\n        const payload = {\n          folderId: doc.id,\n          folderName: doc.name || doc.title || 'Untitled folder',\n          dashboardId: dashboardId,\n        };\n\n        setStatus('Saving folder selection...');\n        fetch('/integrations/google/drive/folder', {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          credentials: 'include',\n          body: JSON.stringify(payload),\n        })\n          .then(async (response) => {\n            if (!response.ok) {\n              const errorText = await response.text();\n              throw new Error(errorText || 'Failed to save selection.');\n            }\n            return response.json();\n          })\n          .then(() => {\n            try {\n              const targetWindow = window.opener || (window.parent !== window ? window.parent : null);\n              if (targetWindow) {\n                targetWindow.postMessage({ type: 'drive-linked', folder: payload }, frontendOrigin);\n              }\n            } catch {}\n            setStatus('Folder linked. Returning to OrcaBot...');\n            if (window.opener) {\n              setTimeout(() => window.close(), 400);\n            } else if (window.parent === window) {\n              setTimeout(() => window.location.assign(frontendUrl), 600);\n            }\n          })\n          .catch((error) => {\n            setStatus(error.message || 'Failed to save selection.');\n          });\n      }\n\n      function onApiLoad() {\n        if (!window.gapi || !window.gapi.load) {\n          setStatus('Failed to load Google Picker API.');\n          return;\n        }\n        window.gapi.load('picker', { callback: onPickerReady });\n      }\n\n      if (window.gapi && window.gapi.load) {\n        onApiLoad();\n      } else {\n        window.addEventListener('load', onApiLoad);\n      }\n\n      if (buttonEl) {\n        buttonEl.addEventListener('click', () => {\n          if (!pickerLoaded) {\n            setStatus('Loading Google Picker...');\n            return;\n          }\n          openPicker();\n        });\n      }\n    </script>\n  </body>\n</html>`,\n    {\n      headers: {\n        'Content-Type': 'text/html; charset=utf-8',\n        'Cache-Control': 'no-store',\n        'Content-Security-Policy': `frame-ancestors ${frontendOrigin}`,\n      },\n    }\n  );\n}\n\nfunction renderErrorPage(message: string): Response {\n  const safeMessage = escapeHtml(message);\n  return new Response(\n    `<!doctype html>\n<html>\n  <head>\n    <meta charset=\"utf-8\" />\n    <title>Connection failed</title>\n    <style>\n      body { font-family: system-ui, sans-serif; padding: 32px; }\n      .card { max-width: 520px; margin: 0 auto; }\n      h1 { font-size: 20px; margin: 0 0 8px; }\n      p { margin: 0 0 16px; color: #b91c1c; }\n    </style>\n  </head>\n  <body>\n    <div class=\"card\">\n      <h1>Connection failed</h1>\n      <p>${safeMessage}</p>\n    </div>\n  </body>\n</html>`,\n    {\n      headers: { 'Content-Type': 'text/html; charset=utf-8' },\n    }\n  );\n}\n\nfunction renderDriveAuthCompletePage(frontendUrl: string, dashboardId: string | null): Response {\n  const frontendOrigin = new URL(frontendUrl).origin;\n  const payload = JSON.stringify({ type: 'drive-auth-complete', dashboardId });\n  return new Response(\n    `<!doctype html>\n<html>\n  <head>\n    <meta charset=\"utf-8\" />\n    <title>Drive connected</title>\n    <style>\n      body { font-family: system-ui, sans-serif; padding: 32px; }\n      .card { max-width: 520px; margin: 0 auto; text-align: center; }\n      h1 { font-size: 20px; margin: 0 0 8px; }\n      p { margin: 0 0 16px; color: #4b5563; }\n    </style>\n  </head>\n  <body>\n    <div class=\"card\">\n      <h1>Google Drive connected</h1>\n      <p>You can return to OrcaBot.</p>\n    </div>\n    <script>\n      try {\n        if (window.opener) {\n          window.opener.postMessage(${payload}, ${JSON.stringify(frontendOrigin)});\n        }\n      } catch {}\n      setTimeout(() => window.close(), 200);\n    </script>\n  </body>\n</html>`,\n    {\n      headers: {\n        'Content-Type': 'text/html; charset=utf-8',\n        'Cache-Control': 'no-store',\n        'Content-Security-Policy': `frame-ancestors ${frontendOrigin}`,\n      },\n    }\n  );\n}\n\nfunction renderProviderAuthCompletePage(\n  frontendUrl: string,\n  providerLabel: string,\n  messageType: string,\n  dashboardId: string | null\n): Response {\n  const frontendOrigin = new URL(frontendUrl).origin;\n  const payload = JSON.stringify({ type: messageType, dashboardId });\n  const safeLabel = escapeHtml(providerLabel);\n  return new Response(\n    `<!doctype html>\n<html>\n  <head>\n    <meta charset=\"utf-8\" />\n    <title>${safeLabel} connected</title>\n    <style>\n      body { font-family: system-ui, sans-serif; padding: 32px; }\n      .card { max-width: 520px; margin: 0 auto; text-align: center; }\n      h1 { font-size: 20px; margin: 0 0 8px; }\n      p { margin: 0 0 16px; color: #4b5563; }\n    </style>\n  </head>\n  <body>\n    <div class=\"card\">\n      <h1>${safeLabel} connected</h1>\n      <p>You can return to OrcaBot.</p>\n    </div>\n    <script>\n      try {\n        if (window.opener) {\n          window.opener.postMessage(${payload}, ${JSON.stringify(frontendOrigin)});\n        }\n      } catch {}\n      setTimeout(() => window.close(), 200);\n    </script>\n  </body>\n</html>`,\n    {\n      headers: {\n        'Content-Type': 'text/html; charset=utf-8',\n        'Cache-Control': 'no-store',\n        'Content-Security-Policy': `frame-ancestors ${frontendOrigin}`,\n      },\n    }\n  );\n}\n\nexport async function c\u043EnnectG\u043E\u043EgleDrive(\n  request: Request,\n  env: EnvWithDriveCache,\n  auth: AuthContext\n): Promise<Response> {\n  const authError = requireAuth(auth);\n  if (authError) return authError;\n\n  if (!env.GOOGLE_CLIENT_ID || !env.GOOGLE_CLIENT_SECRET) {\n    return renderErrorPage('Google OAuth is not configured.');\n  }\n\n  const state = buildState();\n  const requestUrl = new URL(request.url);\n  const dashboardId = requestUrl.searchParams.get('dashboard_id');\n  const mode = requestUrl.searchParams.get('mode');\n  await createState(env, auth.user!.id, 'google_drive', state, {\n    dashboard_id: dashboardId,\n    popup: mode === 'popup',\n  });\n\n  const redirectBase = getRedirectBase(request, env);\n  const redirectUri = `${redirectBase}/integrations/google/drive/callback`;\n\n  const authUrl = new URL('https://accounts.google.com/o/oauth2/v2/auth');\n  authUrl.searchParams.set('client_id', env.GOOGLE_CLIENT_ID);\n  authUrl.searchParams.set('redirect_uri', redirectUri);\n  authUrl.searchParams.set('response_type', 'code');\n  authUrl.searchParams.set('scope', GOOGLE_SCOPE.join(' '));\n  authUrl.searchParams.set('access_type', 'offline');\n  authUrl.searchParams.set('prompt', 'consent');\n  authUrl.searchParams.set('include_granted_scopes', 'true');\n  authUrl.searchParams.set('state', state);\n\n  return Response.redirect(authUrl.toString(), 302);\n}\n\nexport async function callbackG\u043E\u043EgleDrive(\n  request: Request,\n  env: EnvWithDriveCache\n): Promise<Response> {\n  if (!env.GOOGLE_CLIENT_ID || !env.GOOGLE_CLIENT_SECRET) {\n    return renderErrorPage('Google OAuth is not configured.');\n  }\n\n  const url = new URL(request.url);\n  const code = url.searchParams.get('code');\n  const state = url.searchParams.get('state');\n  if (!code || !state) {\n    return renderErrorPage('Missing authorization code.');\n  }\n\n  const stateData = await consumeState(env, state, 'google_drive');\n  if (!stateData) {\n    return renderErrorPage('Invalid or expired state.');\n  }\n  const dashboardId = typeof stateData.metadata.dashboard_id === 'string'\n    ? stateData.metadata.dashboard_id\n    : null;\n  const popup = stateData.metadata.popup === true;\n\n  const redirectBase = getRedirectBase(request, env);\n  const redirectUri = `${redirectBase}/integrations/google/drive/callback`;\n\n  const body = new URLSearchParams();\n  body.set('client_id', env.GOOGLE_CLIENT_ID);\n  body.set('client_secret', env.GOOGLE_CLIENT_SECRET);\n  body.set('code', code);\n  body.set('grant_type', 'authorization_code');\n  body.set('redirect_uri', redirectUri);\n\n  const tokenResponse = await fetch('https://oauth2.googleapis.com/token', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n    body,\n  });\n\n  if (!tokenResponse.ok) {\n    return renderErrorPage('Failed to exchange token.');\n  }\n\n  const tokenData = await tokenResponse.json() as {\n    access_token: string;\n    refresh_token?: string;\n    expires_in?: number;\n    scope?: string;\n    token_type?: string;\n  };\n\n  const now = new Date();\n  const expiresAt = tokenData.expires_in\n    ? new Date(now.getTime() + tokenData.expires_in * 1000).toISOString()\n    : null;\n\n  const metadata = JSON.stringify({\n    scope: tokenData.scope,\n    token_type: tokenData.token_type,\n  });\n\n  await env.DB.prepare(`\n    INSERT INTO user_integrations (\n      id, user_id, provider, access_token, refresh_token, scope, token_type, expires_at, metadata\n    ) VALUES (?, ?, 'google_drive', ?, ?, ?, ?, ?, ?)\n    ON CONFLICT(user_id, provider) DO UPDATE SET\n      access_token = excluded.access_token,\n      refresh_token = excluded.refresh_token,\n      scope = excluded.scope,\n      token_type = excluded.token_type,\n      expires_at = excluded.expires_at,\n      metadata = excluded.metadata,\n      updated_at = datetime('now')\n  `).bind(\n    crypto.randomUUID(),\n    stateData.userId,\n    tokenData.access_token,\n    tokenData.refresh_token || null,\n    tokenData.scope || null,\n    tokenData.token_type || null,\n    expiresAt,\n    metadata\n  ).run();\n\n  if (popup) {\n    const frontendUrl = env.FRONTEND_URL || 'https://orcabot.com';\n    return renderDriveAuthCompletePage(frontendUrl, dashboardId);\n  }\n\n  if (!env.GOOGLE_API_KEY) {\n    return renderErrorPage('Google API key is not configured.');\n  }\n\n  const frontendUrl = env.FRONTEND_URL || 'https://orcabot.com';\n  return renderDrivePickerPage(tokenData.access_token, env.GOOGLE_API_KEY, frontendUrl, dashboardId);\n}\n\nexport async function setG\u043E\u043EgleDriveF\u043Elder(\n  request: Request,\n  env: EnvWithDriveCache,\n  auth: AuthContext\n): Promise<Response> {\n  const authError = requireAuth(auth);\n  if (authError) return authError;\n\n  const data = await request.json() as {\n    folderId?: string;\n    folderName?: string;\n    dashboardId?: string;\n  };\n  if (!data.folderId) {\n    return Response.json({ error: 'E79821: folderId is required' }, { status: 400 });\n  }\n  if (!data.dashboardId) {\n    return Response.json({ error: 'E79824: dashboardId is required' }, { status: 400 });\n  }\n\n  const access = await env.DB.prepare(`\n    SELECT role FROM dashboard_members\n    WHERE dashboard_id = ? AND user_id = ? AND role IN ('owner', 'editor')\n  `).bind(data.dashboardId, auth.user!.id).first<{ role: string }>();\n\n  if (!access) {\n    return Response.json({ error: 'E79823: Not found or no access' }, { status: 404 });\n  }\n\n  const record = await env.DB.prepare(`\n    SELECT metadata FROM user_integrations\n    WHERE user_id = ? AND provider = 'google_drive'\n  `).bind(auth.user!.id).first<{ metadata: string }>();\n\n  if (!record) {\n    return Response.json({ error: 'E79822: Google Drive not connected' }, { status: 404 });\n  }\n\n  let metadata: Record<string, unknown> = {};\n  try {\n    metadata = JSON.parse(record.metadata || '{}') as Record<string, unknown>;\n  } catch {\n    metadata = {};\n  }\n\n  metadata.drive_folder = {\n    id: data.folderId,\n    name: data.folderName || '',\n    linked_at: new Date().toISOString(),\n  };\n\n  await env.DB.prepare(`\n    UPDATE user_integrations\n    SET metadata = ?, updated_at = datetime('now')\n    WHERE user_id = ? AND provider = 'google_drive'\n  `).bind(JSON.stringify(metadata), auth.user!.id).run();\n\n  const now = new Date().toISOString();\n  await env.DB.prepare(`\n    INSERT INTO drive_mirrors (\n      dashboard_id, user_id, folder_id, folder_name, status, updated_at, created_at\n    ) VALUES (?, ?, ?, ?, 'idle', ?, ?)\n    ON CONFLICT(dashboard_id) DO UPDATE SET\n      user_id = excluded.user_id,\n      folder_id = excluded.folder_id,\n      folder_name = excluded.folder_name,\n      status = 'idle',\n      total_files = 0,\n      total_bytes = 0,\n      cache_synced_files = 0,\n      cache_synced_bytes = 0,\n      workspace_synced_files = 0,\n      workspace_synced_bytes = 0,\n      large_files = 0,\n      large_bytes = 0,\n      last_sync_at = null,\n      sync_error = null,\n      updated_at = excluded.updated_at\n  `).bind(\n    data.dashboardId,\n    auth.user!.id,\n    data.folderId,\n    data.folderName || '',\n    now,\n    now\n  ).run();\n\n  try {\n    await runDriveSync(env, auth.user!.id, data.dashboardId);\n  } catch {\n    // Best-effort sync on connect.\n  }\n\n  return Response.json({ ok: true });\n}\n\n// ============================================\n// GitHub mirror\n// ============================================\n\nexport async function getGithubIntegrati\u043En(\n  request: Request,\n  env: EnvWithDriveCache,\n  auth: AuthContext\n): Promise<Response> {\n  const authError = requireAuth(auth);\n  if (authError) return authError;\n\n  const url = new URL(request.url);\n  const dashboardId = url.searchParams.get('dashboard_id');\n\n  const integration = await env.DB.prepare(`\n    SELECT 1 FROM user_integrations WHERE user_id = ? AND provider = 'github'\n  `).bind(auth.user!.id).first();\n\n  if (!integration) {\n    return Response.json({ connected: false, linked: false, repo: null });\n  }\n\n  if (!dashboardId) {\n    return Response.json({ connected: true, linked: false, repo: null });\n  }\n\n  const mirror = await env.DB.prepare(`\n    SELECT repo_id, repo_owner, repo_name, repo_branch, updated_at\n    FROM github_mirrors\n    WHERE dashboard_id = ? AND user_id = ?\n  `).bind(dashboardId, auth.user!.id).first<{\n    repo_id: string;\n    repo_owner: string;\n    repo_name: string;\n    repo_branch: string;\n    updated_at: string;\n  }>();\n\n  if (!mirror) {\n    return Response.json({ connected: true, linked: false, repo: null });\n  }\n\n  return Response.json({\n    connected: true,\n    linked: true,\n    repo: {\n      id: mirror.repo_id,\n      owner: mirror.repo_owner,\n      name: mirror.repo_name,\n      branch: mirror.repo_branch,\n      linked_at: mirror.updated_at,\n    },\n  });\n}\n\nexport async function getGithubRep\u043Es(\n  _request: Request,\n  env: EnvWithDriveCache,\n  auth: AuthContext\n): Promise<Response> {\n  const authError = requireAuth(auth);\n  if (authError) return authError;\n\n  try {\n    const accessToken = await getGithubAccessToken(env, auth.user!.id);\n    const repos = await listGithubRepos(accessToken);\n    return Response.json({\n      connected: true,\n      repos: repos.map((repo) => ({\n        id: repo.id,\n        owner: repo.owner.login,\n        name: repo.name,\n        fullName: repo.full_name,\n        branch: repo.default_branch,\n        private: repo.private,\n      })),\n    });\n  } catch {\n    return Response.json({ connected: false, repos: [] });\n  }\n}\n\nexport async function setGithubRep\u043E(\n  request: Request,\n  env: EnvWithDriveCache,\n  auth: AuthContext\n): Promise<Response> {\n  const authError = requireAuth(auth);\n  if (authError) return authError;\n\n  const data = await request.json() as {\n    dashboardId?: string;\n    repoId?: string | number;\n    repoOwner?: string;\n    repoName?: string;\n    repoBranch?: string;\n  };\n\n  if (!data.dashboardId || !data.repoOwner || !data.repoName) {\n    return Response.json({ error: 'E79840: dashboardId and repo are required' }, { status: 400 });\n  }\n\n  const access = await env.DB.prepare(`\n    SELECT role FROM dashboard_members\n    WHERE dashboard_id = ? AND user_id = ? AND role IN ('owner', 'editor')\n  `).bind(data.dashboardId, auth.user!.id).first();\n\n  if (!access) {\n    return Response.json({ error: 'E79841: Not found or no access' }, { status: 404 });\n  }\n\n  const accessToken = await getGithubAccessToken(env, auth.user!.id);\n  let branch = data.repoBranch;\n  if (!branch) {\n    const repoRes = await fetch(`https://api.github.com/repos/${data.repoOwner}/${data.repoName}`, {\n      headers: {\n        Authorization: `Bearer ${accessToken}`,\n        'User-Agent': 'OrcaBot',\n        Accept: 'application/vnd.github+json',\n      },\n    });\n    if (!repoRes.ok) {\n      return Response.json({ error: 'E79842: Failed to read repo metadata' }, { status: 400 });\n    }\n    const repoData = await repoRes.json() as { default_branch?: string };\n    branch = repoData.default_branch || 'main';\n  }\n\n  await env.DB.prepare(`\n    INSERT INTO github_mirrors (\n      dashboard_id, user_id, repo_id, repo_owner, repo_name, repo_branch, status, created_at, updated_at\n    ) VALUES (?, ?, ?, ?, ?, ?, 'idle', datetime('now'), datetime('now'))\n    ON CONFLICT(dashboard_id) DO UPDATE SET\n      user_id = excluded.user_id,\n      repo_id = excluded.repo_id,\n      repo_owner = excluded.repo_owner,\n      repo_name = excluded.repo_name,\n      repo_branch = excluded.repo_branch,\n      status = 'idle',\n      updated_at = datetime('now')\n  `).bind(\n    data.dashboardId,\n    auth.user!.id,\n    String(data.repoId || `${data.repoOwner}/${data.repoName}`),\n    data.repoOwner,\n    data.repoName,\n    branch\n  ).run();\n\n  try {\n    await runGithubSync(env, auth.user!.id, data.dashboardId);\n  } catch (error) {\n    return Response.json({ error: error instanceof Error ? error.message : 'E79843: GitHub sync failed' }, { status: 500 });\n  }\n\n  return Response.json({ ok: true });\n}\n\nexport async function unlinkGithubRep\u043E(\n  request: Request,\n  env: EnvWithDriveCache,\n  auth: AuthContext\n): Promise<Response> {\n  const authError = requireAuth(auth);\n  if (authError) return authError;\n\n  const url = new URL(request.url);\n  const dashboardId = url.searchParams.get('dashboard_id');\n  if (!dashboardId) {\n    return Response.json({ error: 'E79844: dashboardId is required' }, { status: 400 });\n  }\n\n  const access = await env.DB.prepare(`\n    SELECT role FROM dashboard_members\n    WHERE dashboard_id = ? AND user_id = ? AND role IN ('owner', 'editor')\n  `).bind(dashboardId, auth.user!.id).first();\n\n  if (!access) {\n    return Response.json({ error: 'E79845: Not found or no access' }, { status: 404 });\n  }\n\n  const manifestObject = await env.DRIVE_CACHE.get(mirrorManifestKey('github', dashboardId));\n  if (manifestObject) {\n    const manifest = await manifestObject.json<DriveManifest>();\n    await env.DRIVE_CACHE.delete(mirrorManifestKey('github', dashboardId));\n    for (const entry of manifest.entries) {\n      await env.DRIVE_CACHE.delete(mirrorFileKey('github', dashboardId, entry.id));\n    }\n  }\n\n  await env.DB.prepare(`\n    DELETE FROM github_mirrors WHERE dashboard_id = ? AND user_id = ?\n  `).bind(dashboardId, auth.user!.id).run();\n\n  return Response.json({ ok: true });\n}\n\nasync function updateGithubMirrorCacheProgress(\n  env: EnvWithDriveCache,\n  dashboardId: string,\n  cacheSyncedFiles: number,\n  cacheSyncedBytes: number\n) {\n  await env.DB.prepare(`\n    UPDATE github_mirrors\n    SET cache_synced_files = ?, cache_synced_bytes = ?, updated_at = datetime('now')\n    WHERE dashboard_id = ?\n  `).bind(cacheSyncedFiles, cacheSyncedBytes, dashboardId).run();\n}\n\nasync function updateGithubMirrorWorkspaceProgress(\n  env: EnvWithDriveCache,\n  dashboardId: string,\n  workspaceSyncedFiles: number,\n  workspaceSyncedBytes: number\n) {\n  await env.DB.prepare(`\n    UPDATE github_mirrors\n    SET workspace_synced_files = ?, workspace_synced_bytes = ?, updated_at = datetime('now')\n    WHERE dashboard_id = ?\n  `).bind(workspaceSyncedFiles, workspaceSyncedBytes, dashboardId).run();\n}\n\nexport async function getGithubSyncStatus(\n  request: Request,\n  env: EnvWithDriveCache,\n  auth: AuthContext\n): Promise<Response> {\n  const authError = requireAuth(auth);\n  if (authError) return authError;\n\n  const url = new URL(request.url);\n  const dashboardId = url.searchParams.get('dashboard_id');\n  if (!dashboardId) {\n    return Response.json({ error: 'E79846: dashboardId is required' }, { status: 400 });\n  }\n\n  const record = await env.DB.prepare(`\n    SELECT * FROM github_mirrors\n    WHERE dashboard_id = ? AND user_id = ?\n  `).bind(dashboardId, auth.user!.id).first<Record<string, unknown>>();\n\n  if (!record) {\n    return Response.json({ connected: false });\n  }\n\n  let largeFiles: Array<{ id: string; path: string; size: number }> = [];\n  const manifestObject = await env.DRIVE_CACHE.get(mirrorManifestKey('github', dashboardId));\n  if (manifestObject) {\n    const manifest = await manifestObject.json<DriveManifest>();\n    largeFiles = manifest.entries\n      .filter((entry) => entry.cacheStatus === 'skipped_large')\n      .map((entry) => ({ id: entry.id, path: entry.path, size: entry.size }))\n      .sort((a, b) => b.size - a.size);\n  }\n\n  return Response.json({\n    connected: true,\n    repo: {\n      id: record.repo_id,\n      owner: record.repo_owner,\n      name: record.repo_name,\n      branch: record.repo_branch,\n    },\n    status: record.status,\n    totalFiles: record.total_files,\n    totalBytes: record.total_bytes,\n    cacheSyncedFiles: record.cache_synced_files,\n    cacheSyncedBytes: record.cache_synced_bytes,\n    workspaceSyncedFiles: record.workspace_synced_files,\n    workspaceSyncedBytes: record.workspace_synced_bytes,\n    largeFiles,\n    lastSyncAt: record.last_sync_at,\n    syncError: record.sync_error,\n  });\n}\n\nexport async function syncGithubMirr\u043Er(\n  request: Request,\n  env: EnvWithDriveCache,\n  auth: AuthContext\n): Promise<Response> {\n  const authError = requireAuth(auth);\n  if (authError) return authError;\n\n  const data = await request.json() as { dashboardId?: string };\n  if (!data.dashboardId) {\n    return Response.json({ error: 'E79847: dashboardId is required' }, { status: 400 });\n  }\n\n  try {\n    await runGithubSync(env, auth.user!.id, data.dashboardId);\n    return Response.json({ ok: true });\n  } catch (error) {\n    await env.DB.prepare(`\n      UPDATE github_mirrors\n      SET status = 'error', sync_error = ?, updated_at = datetime('now')\n      WHERE dashboard_id = ?\n    `).bind(\n      error instanceof Error ? error.message : 'GitHub sync failed',\n      data.dashboardId\n    ).run();\n    return Response.json({ error: 'E79848: GitHub sync failed' }, { status: 500 });\n  }\n}\n\nasync function runGithubSync(env: EnvWithDriveCache, userId: string, dashboardId: string) {\n  const access = await env.DB.prepare(`\n    SELECT role FROM dashboard_members\n    WHERE dashboard_id = ? AND user_id = ? AND role IN ('owner', 'editor')\n  `).bind(dashboardId, userId).first();\n\n  if (!access) {\n    throw new Error('E79849: Not found or no access');\n  }\n\n  const mirror = await env.DB.prepare(`\n    SELECT repo_id, repo_owner, repo_name, repo_branch FROM github_mirrors\n    WHERE dashboard_id = ? AND user_id = ?\n  `).bind(dashboardId, userId).first<{\n    repo_id: string;\n    repo_owner: string;\n    repo_name: string;\n    repo_branch: string;\n  }>();\n\n  if (!mirror) {\n    throw new Error('E79850: GitHub repo not linked');\n  }\n\n  await env.DB.prepare(`\n    UPDATE github_mirrors\n    SET status = 'syncing_cache',\n        sync_error = null,\n        total_files = 0,\n        total_bytes = 0,\n        cache_synced_files = 0,\n        cache_synced_bytes = 0,\n        workspace_synced_files = 0,\n        workspace_synced_bytes = 0,\n        large_files = 0,\n        large_bytes = 0,\n        updated_at = datetime('now')\n    WHERE dashboard_id = ?\n  `).bind(dashboardId).run();\n\n  const accessToken = await getGithubAccessToken(env, userId);\n  const { manifest, entries } = await buildGithubManifest(\n    accessToken,\n    mirror.repo_owner,\n    mirror.repo_name,\n    mirror.repo_branch\n  );\n\n  const existingManifestObject = await env.DRIVE_CACHE.get(mirrorManifestKey('github', dashboardId));\n  const existingEntries = new Map<string, DriveFileEntry>();\n  if (existingManifestObject) {\n    const existingManifest = await existingManifestObject.json<DriveManifest>();\n    for (const entry of existingManifest.entries) {\n      existingEntries.set(entry.id, entry);\n    }\n  }\n\n  let totalFiles = 0;\n  let totalBytes = 0;\n  let cacheSyncedFiles = 0;\n  let cacheSyncedBytes = 0;\n  let largeFiles = 0;\n  let largeBytes = 0;\n\n  for (const entry of entries) {\n    totalFiles += 1;\n    totalBytes += entry.size;\n    if (entry.size >= DRIVE_AUTO_SYNC_LIMIT_BYTES) {\n      entry.cacheStatus = 'skipped_large';\n      entry.placeholder = 'File exceeds sync limit. Click Sync to fetch it.';\n      largeFiles += 1;\n      largeBytes += entry.size;\n      continue;\n    }\n\n    const previous = existingEntries.get(entry.id);\n    if (previous && previous.md5Checksum && previous.md5Checksum === entry.md5Checksum) {\n      entry.cacheStatus = previous.cacheStatus;\n      if (entry.cacheStatus === 'cached') {\n        cacheSyncedFiles += 1;\n        cacheSyncedBytes += entry.size;\n      }\n      continue;\n    }\n\n    const fileRes = await fetch(`https://api.github.com/repos/${mirror.repo_owner}/${mirror.repo_name}/contents/${entry.path}?ref=${mirror.repo_branch}`, {\n      headers: {\n        Authorization: `Bearer ${accessToken}`,\n        'User-Agent': 'OrcaBot',\n        Accept: 'application/vnd.github.raw',\n      },\n    });\n\n    if (!fileRes.ok || !fileRes.body) {\n      entry.cacheStatus = 'skipped_unsupported';\n      entry.placeholder = 'Failed to download GitHub file.';\n      continue;\n    }\n\n    await uploadDriveFileToCache(env, mirrorFileKey('github', dashboardId, entry.id), fileRes, entry.size);\n    cacheSyncedFiles += 1;\n    cacheSyncedBytes += entry.size;\n    entry.cacheStatus = 'cached';\n    await updateGithubMirrorCacheProgress(env, dashboardId, cacheSyncedFiles, cacheSyncedBytes);\n  }\n\n  manifest.entries = entries;\n  await env.DRIVE_CACHE.put(mirrorManifestKey('github', dashboardId), JSON.stringify(manifest), {\n    httpMetadata: { contentType: 'application/json' },\n  });\n\n  const now = new Date().toISOString();\n  await env.DB.prepare(`\n    UPDATE github_mirrors\n    SET status = 'syncing_workspace',\n        total_files = ?,\n        total_bytes = ?,\n        cache_synced_files = ?,\n        cache_synced_bytes = ?,\n        large_files = ?,\n        large_bytes = ?,\n        last_sync_at = ?,\n        updated_at = datetime('now')\n    WHERE dashboard_id = ?\n  `).bind(\n    totalFiles,\n    totalBytes,\n    cacheSyncedFiles,\n    cacheSyncedBytes,\n    largeFiles,\n    largeBytes,\n    now,\n    dashboardId\n  ).run();\n\n  const sandboxRecord = await env.DB.prepare(`\n    SELECT sandbox_session_id, sandbox_machine_id FROM dashboard_sandboxes\n    WHERE dashboard_id = ?\n  `).bind(dashboardId).first<{ sandbox_session_id: string; sandbox_machine_id: string }>();\n\n  if (sandboxRecord?.sandbox_session_id) {\n    await startSandboxMirrorSync(\n      env,\n      'github',\n      dashboardId,\n      sandboxRecord.sandbox_session_id,\n      sandboxRecord.sandbox_machine_id || '',\n      `${mirror.repo_owner}/${mirror.repo_name}`\n    );\n  } else {\n    await env.DB.prepare(`\n      UPDATE github_mirrors\n      SET status = 'ready',\n          updated_at = datetime('now')\n      WHERE dashboard_id = ?\n    `).bind(dashboardId).run();\n  }\n}\n\nexport async function syncGithubLargeFiles(\n  request: Request,\n  env: EnvWithDriveCache,\n  auth: AuthContext\n): Promise<Response> {\n  const authError = requireAuth(auth);\n  if (authError) return authError;\n\n  const data = await request.json() as { dashboardId?: string; fileIds?: string[] };\n  if (!data.dashboardId || !Array.isArray(data.fileIds) || data.fileIds.length === 0) {\n    return Response.json({ error: 'E79851: dashboardId and fileIds are required' }, { status: 400 });\n  }\n\n  const access = await env.DB.prepare(`\n    SELECT role FROM dashboard_members\n    WHERE dashboard_id = ? AND user_id = ? AND role IN ('owner', 'editor')\n  `).bind(data.dashboardId, auth.user!.id).first();\n\n  if (!access) {\n    return Response.json({ error: 'E79852: Not found or no access' }, { status: 404 });\n  }\n\n  const mirror = await env.DB.prepare(`\n    SELECT repo_owner, repo_name, repo_branch FROM github_mirrors\n    WHERE dashboard_id = ? AND user_id = ?\n  `).bind(data.dashboardId, auth.user!.id).first<{ repo_owner: string; repo_name: string; repo_branch: string }>();\n\n  if (!mirror) {\n    return Response.json({ error: 'E79853: GitHub repo not linked' }, { status: 404 });\n  }\n\n  const manifestObject = await env.DRIVE_CACHE.get(mirrorManifestKey('github', data.dashboardId));\n  if (!manifestObject) {\n    return Response.json({ error: 'E79854: GitHub manifest missing. Run sync first.' }, { status: 404 });\n  }\n  const manifest = await manifestObject.json<DriveManifest>();\n  const entryMap = new Map(manifest.entries.map((entry) => [entry.id, entry]));\n\n  const accessToken = await getGithubAccessToken(env, auth.user!.id);\n  let cacheSyncedFiles = 0;\n  let cacheSyncedBytes = 0;\n  for (const entry of manifest.entries) {\n    if (entry.cacheStatus === 'cached') {\n      cacheSyncedFiles += 1;\n      cacheSyncedBytes += entry.size;\n    }\n  }\n\n  for (const fileId of data.fileIds) {\n    const entry = entryMap.get(fileId);\n    if (!entry || entry.cacheStatus !== 'skipped_large') {\n      continue;\n    }\n\n    const fileRes = await fetch(`https://api.github.com/repos/${mirror.repo_owner}/${mirror.repo_name}/contents/${entry.path}?ref=${mirror.repo_branch}`, {\n      headers: {\n        Authorization: `Bearer ${accessToken}`,\n        'User-Agent': 'OrcaBot',\n        Accept: 'application/vnd.github.raw',\n      },\n    });\n\n    if (!fileRes.ok || !fileRes.body) {\n      continue;\n    }\n\n    await uploadDriveFileToCache(env, mirrorFileKey('github', data.dashboardId, entry.id), fileRes, entry.size);\n\n    entry.cacheStatus = 'cached';\n    entry.placeholder = undefined;\n    cacheSyncedFiles += 1;\n    cacheSyncedBytes += entry.size;\n    await updateGithubMirrorCacheProgress(env, data.dashboardId, cacheSyncedFiles, cacheSyncedBytes);\n  }\n\n  await env.DRIVE_CACHE.put(mirrorManifestKey('github', data.dashboardId), JSON.stringify(manifest), {\n    httpMetadata: { contentType: 'application/json' },\n  });\n\n  const now = new Date().toISOString();\n  await env.DB.prepare(`\n    UPDATE github_mirrors\n    SET status = 'syncing_workspace',\n        sync_error = null,\n        last_sync_at = ?,\n        updated_at = datetime('now')\n    WHERE dashboard_id = ?\n  `).bind(now, data.dashboardId).run();\n\n  const sandboxRecord = await env.DB.prepare(`\n    SELECT sandbox_session_id, sandbox_machine_id FROM dashboard_sandboxes\n    WHERE dashboard_id = ?\n  `).bind(data.dashboardId).first<{ sandbox_session_id: string; sandbox_machine_id: string }>();\n\n  if (sandboxRecord?.sandbox_session_id) {\n    await startSandboxMirrorSync(\n      env,\n      'github',\n      data.dashboardId,\n      sandboxRecord.sandbox_session_id,\n      sandboxRecord.sandbox_machine_id || '',\n      `${mirror.repo_owner}/${mirror.repo_name}`\n    );\n  } else {\n    await env.DB.prepare(`\n      UPDATE github_mirrors\n      SET status = 'ready',\n          updated_at = datetime('now')\n      WHERE dashboard_id = ?\n    `).bind(data.dashboardId).run();\n  }\n\n  return Response.json({ ok: true });\n}\n\nexport async function getGithubManifest(\n  request: Request,\n  env: EnvWithDriveCache,\n  auth: AuthContext\n): Promise<Response> {\n  const authError = requireAuth(auth);\n  if (authError) return authError;\n\n  const url = new URL(request.url);\n  const dashboardId = url.searchParams.get('dashboard_id');\n  if (!dashboardId) {\n    return Response.json({ error: 'E79855: dashboardId is required' }, { status: 400 });\n  }\n\n  const mirror = await env.DB.prepare(`\n    SELECT repo_owner, repo_name FROM github_mirrors\n    WHERE dashboard_id = ? AND user_id = ?\n  `).bind(dashboardId, auth.user!.id).first<{ repo_owner: string; repo_name: string }>();\n\n  if (!mirror) {\n    return Response.json({ connected: false });\n  }\n\n  const manifestObject = await env.DRIVE_CACHE.get(mirrorManifestKey('github', dashboardId));\n  if (!manifestObject) {\n    return Response.json({\n      connected: true,\n      repo: { owner: mirror.repo_owner, name: mirror.repo_name },\n      manifest: null,\n    });\n  }\n\n  const manifest = await manifestObject.json<DriveManifest>();\n  return Response.json({\n    connected: true,\n    repo: { owner: mirror.repo_owner, name: mirror.repo_name },\n    manifest,\n  });\n}\n\n// ============================================\n// Box mirror\n// ============================================\n\nasync function getBoxAccessToken(env: EnvWithDriveCache, userId: string): Promise<string> {\n  const record = await env.DB.prepare(`\n    SELECT access_token FROM user_integrations\n    WHERE user_id = ? AND provider = 'box'\n  `).bind(userId).first<{ access_token: string }>();\n\n  if (!record?.access_token) {\n    throw new Error('Box must be connected.');\n  }\n  return record.access_token;\n}\n\nexport async function getB\u043ExIntegrati\u043En(\n  request: Request,\n  env: EnvWithDriveCache,\n  auth: AuthContext\n): Promise<Response> {\n  const authError = requireAuth(auth);\n  if (authError) return authError;\n\n  const url = new URL(request.url);\n  const dashboardId = url.searchParams.get('dashboard_id');\n\n  const integration = await env.DB.prepare(`\n    SELECT 1 FROM user_integrations WHERE user_id = ? AND provider = 'box'\n  `).bind(auth.user!.id).first();\n\n  if (!integration) {\n    return Response.json({ connected: false, linked: false, folder: null });\n  }\n\n  if (!dashboardId) {\n    return Response.json({ connected: true, linked: false, folder: null });\n  }\n\n  const mirror = await env.DB.prepare(`\n    SELECT folder_id, folder_name, updated_at\n    FROM box_mirrors\n    WHERE dashboard_id = ? AND user_id = ?\n  `).bind(dashboardId, auth.user!.id).first<{ folder_id: string; folder_name: string; updated_at: string }>();\n\n  if (!mirror) {\n    return Response.json({ connected: true, linked: false, folder: null });\n  }\n\n  return Response.json({\n    connected: true,\n    linked: true,\n    folder: {\n      id: mirror.folder_id,\n      name: mirror.folder_name,\n      linked_at: mirror.updated_at,\n    },\n  });\n}\n\nexport async function getB\u043ExF\u043Elders(\n  request: Request,\n  env: EnvWithDriveCache,\n  auth: AuthContext\n): Promise<Response> {\n  const authError = requireAuth(auth);\n  if (authError) return authError;\n\n  const url = new URL(request.url);\n  const parentId = url.searchParams.get('parent_id') || '0';\n  try {\n    const accessToken = await getBoxAccessToken(env, auth.user!.id);\n    const items = await listBoxFolderItems(accessToken, parentId);\n    return Response.json({\n      connected: true,\n      parentId,\n      folders: items\n        .filter((item) => item.type === 'folder')\n        .map((item) => ({ id: item.id, name: item.name })),\n    });\n  } catch {\n    return Response.json({ connected: false, parentId, folders: [] });\n  }\n}\n\nexport async function setB\u043ExF\u043Elder(\n  request: Request,\n  env: EnvWithDriveCache,\n  auth: AuthContext\n): Promise<Response> {\n  const authError = requireAuth(auth);\n  if (authError) return authError;\n\n  const data = await request.json() as { dashboardId?: string; folderId?: string; folderName?: string };\n  if (!data.dashboardId || !data.folderId || !data.folderName) {\n    return Response.json({ error: 'E79860: dashboardId and folder are required' }, { status: 400 });\n  }\n\n  const access = await env.DB.prepare(`\n    SELECT role FROM dashboard_members\n    WHERE dashboard_id = ? AND user_id = ? AND role IN ('owner', 'editor')\n  `).bind(data.dashboardId, auth.user!.id).first();\n\n  if (!access) {\n    return Response.json({ error: 'E79861: Not found or no access' }, { status: 404 });\n  }\n\n  await env.DB.prepare(`\n    INSERT INTO box_mirrors (\n      dashboard_id, user_id, folder_id, folder_name, status, created_at, updated_at\n    ) VALUES (?, ?, ?, ?, 'idle', datetime('now'), datetime('now'))\n    ON CONFLICT(dashboard_id) DO UPDATE SET\n      user_id = excluded.user_id,\n      folder_id = excluded.folder_id,\n      folder_name = excluded.folder_name,\n      status = 'idle',\n      updated_at = datetime('now')\n  `).bind(\n    data.dashboardId,\n    auth.user!.id,\n    data.folderId,\n    data.folderName\n  ).run();\n\n  try {\n    await runBoxSync(env, auth.user!.id, data.dashboardId);\n  } catch (error) {\n    return Response.json({ error: error instanceof Error ? error.message : 'E79862: Box sync failed' }, { status: 500 });\n  }\n\n  return Response.json({ ok: true });\n}\n\nexport async function unlinkB\u043ExF\u043Elder(\n  request: Request,\n  env: EnvWithDriveCache,\n  auth: AuthContext\n): Promise<Response> {\n  const authError = requireAuth(auth);\n  if (authError) return authError;\n\n  const url = new URL(request.url);\n  const dashboardId = url.searchParams.get('dashboard_id');\n  if (!dashboardId) {\n    return Response.json({ error: 'E79863: dashboardId is required' }, { status: 400 });\n  }\n\n  const access = await env.DB.prepare(`\n    SELECT role FROM dashboard_members\n    WHERE dashboard_id = ? AND user_id = ? AND role IN ('owner', 'editor')\n  `).bind(dashboardId, auth.user!.id).first();\n\n  if (!access) {\n    return Response.json({ error: 'E79864: Not found or no access' }, { status: 404 });\n  }\n\n  const manifestObject = await env.DRIVE_CACHE.get(mirrorManifestKey('box', dashboardId));\n  if (manifestObject) {\n    const manifest = await manifestObject.json<DriveManifest>();\n    await env.DRIVE_CACHE.delete(mirrorManifestKey('box', dashboardId));\n    for (const entry of manifest.entries) {\n      await env.DRIVE_CACHE.delete(mirrorFileKey('box', dashboardId, entry.id));\n    }\n  }\n\n  await env.DB.prepare(`\n    DELETE FROM box_mirrors WHERE dashboard_id = ? AND user_id = ?\n  `).bind(dashboardId, auth.user!.id).run();\n\n  return Response.json({ ok: true });\n}\n\nasync function updateBoxMirrorCacheProgress(\n  env: EnvWithDriveCache,\n  dashboardId: string,\n  cacheSyncedFiles: number,\n  cacheSyncedBytes: number\n) {\n  await env.DB.prepare(`\n    UPDATE box_mirrors\n    SET cache_synced_files = ?, cache_synced_bytes = ?, updated_at = datetime('now')\n    WHERE dashboard_id = ?\n  `).bind(cacheSyncedFiles, cacheSyncedBytes, dashboardId).run();\n}\n\nasync function updateBoxMirrorWorkspaceProgress(\n  env: EnvWithDriveCache,\n  dashboardId: string,\n  workspaceSyncedFiles: number,\n  workspaceSyncedBytes: number\n) {\n  await env.DB.prepare(`\n    UPDATE box_mirrors\n    SET workspace_synced_files = ?, workspace_synced_bytes = ?, updated_at = datetime('now')\n    WHERE dashboard_id = ?\n  `).bind(workspaceSyncedFiles, workspaceSyncedBytes, dashboardId).run();\n}\n\nexport async function getB\u043ExSyncStatus(\n  request: Request,\n  env: EnvWithDriveCache,\n  auth: AuthContext\n): Promise<Response> {\n  const authError = requireAuth(auth);\n  if (authError) return authError;\n\n  const url = new URL(request.url);\n  const dashboardId = url.searchParams.get('dashboard_id');\n  if (!dashboardId) {\n    return Response.json({ error: 'E79865: dashboardId is required' }, { status: 400 });\n  }\n\n  const record = await env.DB.prepare(`\n    SELECT * FROM box_mirrors\n    WHERE dashboard_id = ? AND user_id = ?\n  `).bind(dashboardId, auth.user!.id).first<Record<string, unknown>>();\n\n  if (!record) {\n    return Response.json({ connected: false });\n  }\n\n  let largeFiles: Array<{ id: string; path: string; size: number }> = [];\n  const manifestObject = await env.DRIVE_CACHE.get(mirrorManifestKey('box', dashboardId));\n  if (manifestObject) {\n    const manifest = await manifestObject.json<DriveManifest>();\n    largeFiles = manifest.entries\n      .filter((entry) => entry.cacheStatus === 'skipped_large')\n      .map((entry) => ({ id: entry.id, path: entry.path, size: entry.size }))\n      .sort((a, b) => b.size - a.size);\n  }\n\n  return Response.json({\n    connected: true,\n    folder: {\n      id: record.folder_id,\n      name: record.folder_name,\n    },\n    status: record.status,\n    totalFiles: record.total_files,\n    totalBytes: record.total_bytes,\n    cacheSyncedFiles: record.cache_synced_files,\n    cacheSyncedBytes: record.cache_synced_bytes,\n    workspaceSyncedFiles: record.workspace_synced_files,\n    workspaceSyncedBytes: record.workspace_synced_bytes,\n    largeFiles,\n    lastSyncAt: record.last_sync_at,\n    syncError: record.sync_error,\n  });\n}\n\nexport async function syncB\u043ExMirr\u043Er(\n  request: Request,\n  env: EnvWithDriveCache,\n  auth: AuthContext\n): Promise<Response> {\n  const authError = requireAuth(auth);\n  if (authError) return authError;\n\n  const data = await request.json() as { dashboardId?: string };\n  if (!data.dashboardId) {\n    return Response.json({ error: 'E79866: dashboardId is required' }, { status: 400 });\n  }\n\n  try {\n    await runBoxSync(env, auth.user!.id, data.dashboardId);\n    return Response.json({ ok: true });\n  } catch (error) {\n    await env.DB.prepare(`\n      UPDATE box_mirrors\n      SET status = 'error', sync_error = ?, updated_at = datetime('now')\n      WHERE dashboard_id = ?\n    `).bind(\n      error instanceof Error ? error.message : 'Box sync failed',\n      data.dashboardId\n    ).run();\n    return Response.json({ error: 'E79867: Box sync failed' }, { status: 500 });\n  }\n}\n\nasync function runBoxSync(env: EnvWithDriveCache, userId: string, dashboardId: string) {\n  const access = await env.DB.prepare(`\n    SELECT role FROM dashboard_members\n    WHERE dashboard_id = ? AND user_id = ? AND role IN ('owner', 'editor')\n  `).bind(dashboardId, userId).first();\n\n  if (!access) {\n    throw new Error('E79868: Not found or no access');\n  }\n\n  const mirror = await env.DB.prepare(`\n    SELECT folder_id, folder_name FROM box_mirrors\n    WHERE dashboard_id = ? AND user_id = ?\n  `).bind(dashboardId, userId).first<{ folder_id: string; folder_name: string }>();\n\n  if (!mirror) {\n    throw new Error('E79869: Box folder not linked');\n  }\n\n  await env.DB.prepare(`\n    UPDATE box_mirrors\n    SET status = 'syncing_cache',\n        sync_error = null,\n        total_files = 0,\n        total_bytes = 0,\n        cache_synced_files = 0,\n        cache_synced_bytes = 0,\n        workspace_synced_files = 0,\n        workspace_synced_bytes = 0,\n        large_files = 0,\n        large_bytes = 0,\n        updated_at = datetime('now')\n    WHERE dashboard_id = ?\n  `).bind(dashboardId).run();\n\n  const accessToken = await refreshBoxAccessToken(env, userId);\n  const { manifest, entries } = await buildBoxManifest(accessToken, mirror.folder_id, mirror.folder_name);\n\n  const existingManifestObject = await env.DRIVE_CACHE.get(mirrorManifestKey('box', dashboardId));\n  const existingEntries = new Map<string, DriveFileEntry>();\n  if (existingManifestObject) {\n    const existingManifest = await existingManifestObject.json<DriveManifest>();\n    for (const entry of existingManifest.entries) {\n      existingEntries.set(entry.id, entry);\n    }\n  }\n\n  let totalFiles = 0;\n  let totalBytes = 0;\n  let cacheSyncedFiles = 0;\n  let cacheSyncedBytes = 0;\n  let largeFiles = 0;\n  let largeBytes = 0;\n\n  for (const entry of entries) {\n    totalFiles += 1;\n    totalBytes += entry.size;\n    if (entry.size >= DRIVE_AUTO_SYNC_LIMIT_BYTES) {\n      entry.cacheStatus = 'skipped_large';\n      entry.placeholder = 'File exceeds sync limit. Click Sync to fetch it.';\n      largeFiles += 1;\n      largeBytes += entry.size;\n      continue;\n    }\n\n    const previous = existingEntries.get(entry.id);\n    if (previous && previous.md5Checksum && previous.md5Checksum === entry.md5Checksum) {\n      entry.cacheStatus = previous.cacheStatus;\n      if (entry.cacheStatus === 'cached') {\n        cacheSyncedFiles += 1;\n        cacheSyncedBytes += entry.size;\n      }\n      continue;\n    }\n\n    const fileRes = await fetch(`https://api.box.com/2.0/files/${entry.id}/content`, {\n      headers: { Authorization: `Bearer ${accessToken}` },\n    });\n\n    if (!fileRes.ok || !fileRes.body) {\n      entry.cacheStatus = 'skipped_unsupported';\n      entry.placeholder = 'Failed to download Box file.';\n      continue;\n    }\n\n    await uploadDriveFileToCache(env, mirrorFileKey('box', dashboardId, entry.id), fileRes, entry.size);\n    cacheSyncedFiles += 1;\n    cacheSyncedBytes += entry.size;\n    entry.cacheStatus = 'cached';\n    await updateBoxMirrorCacheProgress(env, dashboardId, cacheSyncedFiles, cacheSyncedBytes);\n  }\n\n  manifest.entries = entries;\n  await env.DRIVE_CACHE.put(mirrorManifestKey('box', dashboardId), JSON.stringify(manifest), {\n    httpMetadata: { contentType: 'application/json' },\n  });\n\n  const now = new Date().toISOString();\n  await env.DB.prepare(`\n    UPDATE box_mirrors\n    SET status = 'syncing_workspace',\n        total_files = ?,\n        total_bytes = ?,\n        cache_synced_files = ?,\n        cache_synced_bytes = ?,\n        large_files = ?,\n        large_bytes = ?,\n        last_sync_at = ?,\n        updated_at = datetime('now')\n    WHERE dashboard_id = ?\n  `).bind(\n    totalFiles,\n    totalBytes,\n    cacheSyncedFiles,\n    cacheSyncedBytes,\n    largeFiles,\n    largeBytes,\n    now,\n    dashboardId\n  ).run();\n\n  const sandboxRecord = await env.DB.prepare(`\n    SELECT sandbox_session_id, sandbox_machine_id FROM dashboard_sandboxes\n    WHERE dashboard_id = ?\n  `).bind(dashboardId).first<{ sandbox_session_id: string; sandbox_machine_id: string }>();\n\n  if (sandboxRecord?.sandbox_session_id) {\n    await startSandboxMirrorSync(\n      env,\n      'box',\n      dashboardId,\n      sandboxRecord.sandbox_session_id,\n      sandboxRecord.sandbox_machine_id || '',\n      mirror.folder_name\n    );\n  } else {\n    await env.DB.prepare(`\n      UPDATE box_mirrors\n      SET status = 'ready',\n          updated_at = datetime('now')\n      WHERE dashboard_id = ?\n    `).bind(dashboardId).run();\n  }\n}\n\nexport async function syncB\u043ExLargeFiles(\n  request: Request,\n  env: EnvWithDriveCache,\n  auth: AuthContext\n): Promise<Response> {\n  const authError = requireAuth(auth);\n  if (authError) return authError;\n\n  const data = await request.json() as { dashboardId?: string; fileIds?: string[] };\n  if (!data.dashboardId || !Array.isArray(data.fileIds) || data.fileIds.length === 0) {\n    return Response.json({ error: 'E79870: dashboardId and fileIds are required' }, { status: 400 });\n  }\n\n  const access = await env.DB.prepare(`\n    SELECT role FROM dashboard_members\n    WHERE dashboard_id = ? AND user_id = ? AND role IN ('owner', 'editor')\n  `).bind(data.dashboardId, auth.user!.id).first();\n\n  if (!access) {\n    return Response.json({ error: 'E79871: Not found or no access' }, { status: 404 });\n  }\n\n  const mirror = await env.DB.prepare(`\n    SELECT folder_name FROM box_mirrors\n    WHERE dashboard_id = ? AND user_id = ?\n  `).bind(data.dashboardId, auth.user!.id).first<{ folder_name: string }>();\n\n  if (!mirror) {\n    return Response.json({ error: 'E79872: Box folder not linked' }, { status: 404 });\n  }\n\n  const manifestObject = await env.DRIVE_CACHE.get(mirrorManifestKey('box', data.dashboardId));\n  if (!manifestObject) {\n    return Response.json({ error: 'E79873: Box manifest missing. Run sync first.' }, { status: 404 });\n  }\n  const manifest = await manifestObject.json<DriveManifest>();\n  const entryMap = new Map(manifest.entries.map((entry) => [entry.id, entry]));\n\n  const accessToken = await refreshBoxAccessToken(env, auth.user!.id);\n  let cacheSyncedFiles = 0;\n  let cacheSyncedBytes = 0;\n  for (const entry of manifest.entries) {\n    if (entry.cacheStatus === 'cached') {\n      cacheSyncedFiles += 1;\n      cacheSyncedBytes += entry.size;\n    }\n  }\n\n  for (const fileId of data.fileIds) {\n    const entry = entryMap.get(fileId);\n    if (!entry || entry.cacheStatus !== 'skipped_large') {\n      continue;\n    }\n\n    const fileRes = await fetch(`https://api.box.com/2.0/files/${entry.id}/content`, {\n      headers: { Authorization: `Bearer ${accessToken}` },\n    });\n\n    if (!fileRes.ok || !fileRes.body) {\n      continue;\n    }\n\n    await uploadDriveFileToCache(env, mirrorFileKey('box', data.dashboardId, entry.id), fileRes, entry.size);\n\n    entry.cacheStatus = 'cached';\n    entry.placeholder = undefined;\n    cacheSyncedFiles += 1;\n    cacheSyncedBytes += entry.size;\n    await updateBoxMirrorCacheProgress(env, data.dashboardId, cacheSyncedFiles, cacheSyncedBytes);\n  }\n\n  await env.DRIVE_CACHE.put(mirrorManifestKey('box', data.dashboardId), JSON.stringify(manifest), {\n    httpMetadata: { contentType: 'application/json' },\n  });\n\n  const now = new Date().toISOString();\n  await env.DB.prepare(`\n    UPDATE box_mirrors\n    SET status = 'syncing_workspace',\n        sync_error = null,\n        last_sync_at = ?,\n        updated_at = datetime('now')\n    WHERE dashboard_id = ?\n  `).bind(now, data.dashboardId).run();\n\n  const sandboxRecord = await env.DB.prepare(`\n    SELECT sandbox_session_id, sandbox_machine_id FROM dashboard_sandboxes\n    WHERE dashboard_id = ?\n  `).bind(data.dashboardId).first<{ sandbox_session_id: string; sandbox_machine_id: string }>();\n\n  if (sandboxRecord?.sandbox_session_id) {\n    await startSandboxMirrorSync(\n      env,\n      'box',\n      data.dashboardId,\n      sandboxRecord.sandbox_session_id,\n      sandboxRecord.sandbox_machine_id || '',\n      mirror.folder_name\n    );\n  } else {\n    await env.DB.prepare(`\n      UPDATE box_mirrors\n      SET status = 'ready',\n          updated_at = datetime('now')\n      WHERE dashboard_id = ?\n    `).bind(data.dashboardId).run();\n  }\n\n  return Response.json({ ok: true });\n}\n\nexport async function getB\u043ExManifest(\n  request: Request,\n  env: EnvWithDriveCache,\n  auth: AuthContext\n): Promise<Response> {\n  const authError = requireAuth(auth);\n  if (authError) return authError;\n\n  const url = new URL(request.url);\n  const dashboardId = url.searchParams.get('dashboard_id');\n  if (!dashboardId) {\n    return Response.json({ error: 'E79874: dashboardId is required' }, { status: 400 });\n  }\n\n  const mirror = await env.DB.prepare(`\n    SELECT folder_id, folder_name FROM box_mirrors\n    WHERE dashboard_id = ? AND user_id = ?\n  `).bind(dashboardId, auth.user!.id).first<{ folder_id: string; folder_name: string }>();\n\n  if (!mirror) {\n    return Response.json({ connected: false });\n  }\n\n  const manifestObject = await env.DRIVE_CACHE.get(mirrorManifestKey('box', dashboardId));\n  if (!manifestObject) {\n    return Response.json({\n      connected: true,\n      folder: { id: mirror.folder_id, name: mirror.folder_name },\n      manifest: null,\n    });\n  }\n\n  const manifest = await manifestObject.json<DriveManifest>();\n  return Response.json({\n    connected: true,\n    folder: { id: mirror.folder_id, name: mirror.folder_name },\n    manifest,\n  });\n}\n\n// ============================================\n// OneDrive mirror\n// ============================================\n\nasync function getOnedriveAccessToken(env: EnvWithDriveCache, userId: string): Promise<string> {\n  const record = await env.DB.prepare(`\n    SELECT access_token FROM user_integrations\n    WHERE user_id = ? AND provider = 'onedrive'\n  `).bind(userId).first<{ access_token: string }>();\n\n  if (!record?.access_token) {\n    throw new Error('OneDrive must be connected.');\n  }\n  return record.access_token;\n}\n\nexport async function get\u041EnedriveIntegrati\u043En(\n  request: Request,\n  env: EnvWithDriveCache,\n  auth: AuthContext\n): Promise<Response> {\n  const authError = requireAuth(auth);\n  if (authError) return authError;\n\n  const url = new URL(request.url);\n  const dashboardId = url.searchParams.get('dashboard_id');\n\n  const integration = await env.DB.prepare(`\n    SELECT 1 FROM user_integrations WHERE user_id = ? AND provider = 'onedrive'\n  `).bind(auth.user!.id).first();\n\n  if (!integration) {\n    return Response.json({ connected: false, linked: false, folder: null });\n  }\n\n  if (!dashboardId) {\n    return Response.json({ connected: true, linked: false, folder: null });\n  }\n\n  const mirror = await env.DB.prepare(`\n    SELECT folder_id, folder_name, updated_at\n    FROM onedrive_mirrors\n    WHERE dashboard_id = ? AND user_id = ?\n  `).bind(dashboardId, auth.user!.id).first<{ folder_id: string; folder_name: string; updated_at: string }>();\n\n  if (!mirror) {\n    return Response.json({ connected: true, linked: false, folder: null });\n  }\n\n  return Response.json({\n    connected: true,\n    linked: true,\n    folder: {\n      id: mirror.folder_id,\n      name: mirror.folder_name,\n      linked_at: mirror.updated_at,\n    },\n  });\n}\n\nexport async function get\u041EnedriveF\u043Elders(\n  request: Request,\n  env: EnvWithDriveCache,\n  auth: AuthContext\n): Promise<Response> {\n  const authError = requireAuth(auth);\n  if (authError) return authError;\n\n  const url = new URL(request.url);\n  const parentId = url.searchParams.get('parent_id') || 'root';\n  try {\n    const accessToken = await getOnedriveAccessToken(env, auth.user!.id);\n    const items = await listOnedriveChildren(accessToken, parentId);\n    return Response.json({\n      connected: true,\n      parentId,\n      folders: items\n        .filter((item) => item.folder)\n        .map((item) => ({ id: item.id, name: item.name })),\n    });\n  } catch {\n    return Response.json({ connected: false, parentId, folders: [] });\n  }\n}\n\nexport async function set\u041EnedriveF\u043Elder(\n  request: Request,\n  env: EnvWithDriveCache,\n  auth: AuthContext\n): Promise<Response> {\n  const authError = requireAuth(auth);\n  if (authError) return authError;\n\n  const data = await request.json() as { dashboardId?: string; folderId?: string; folderName?: string };\n  if (!data.dashboardId || !data.folderId || !data.folderName) {\n    return Response.json({ error: 'E79880: dashboardId and folder are required' }, { status: 400 });\n  }\n\n  const access = await env.DB.prepare(`\n    SELECT role FROM dashboard_members\n    WHERE dashboard_id = ? AND user_id = ? AND role IN ('owner', 'editor')\n  `).bind(data.dashboardId, auth.user!.id).first();\n\n  if (!access) {\n    return Response.json({ error: 'E79881: Not found or no access' }, { status: 404 });\n  }\n\n  await env.DB.prepare(`\n    INSERT INTO onedrive_mirrors (\n      dashboard_id, user_id, folder_id, folder_name, status, created_at, updated_at\n    ) VALUES (?, ?, ?, ?, 'idle', datetime('now'), datetime('now'))\n    ON CONFLICT(dashboard_id) DO UPDATE SET\n      user_id = excluded.user_id,\n      folder_id = excluded.folder_id,\n      folder_name = excluded.folder_name,\n      status = 'idle',\n      updated_at = datetime('now')\n  `).bind(\n    data.dashboardId,\n    auth.user!.id,\n    data.folderId,\n    data.folderName\n  ).run();\n\n  try {\n    await runOnedriveSync(env, auth.user!.id, data.dashboardId);\n  } catch (error) {\n    return Response.json({ error: error instanceof Error ? error.message : 'E79882: OneDrive sync failed' }, { status: 500 });\n  }\n\n  return Response.json({ ok: true });\n}\n\nexport async function unlink\u041EnedriveF\u043Elder(\n  request: Request,\n  env: EnvWithDriveCache,\n  auth: AuthContext\n): Promise<Response> {\n  const authError = requireAuth(auth);\n  if (authError) return authError;\n\n  const url = new URL(request.url);\n  const dashboardId = url.searchParams.get('dashboard_id');\n  if (!dashboardId) {\n    return Response.json({ error: 'E79883: dashboardId is required' }, { status: 400 });\n  }\n\n  const access = await env.DB.prepare(`\n    SELECT role FROM dashboard_members\n    WHERE dashboard_id = ? AND user_id = ? AND role IN ('owner', 'editor')\n  `).bind(dashboardId, auth.user!.id).first();\n\n  if (!access) {\n    return Response.json({ error: 'E79884: Not found or no access' }, { status: 404 });\n  }\n\n  const manifestObject = await env.DRIVE_CACHE.get(mirrorManifestKey('onedrive', dashboardId));\n  if (manifestObject) {\n    const manifest = await manifestObject.json<DriveManifest>();\n    await env.DRIVE_CACHE.delete(mirrorManifestKey('onedrive', dashboardId));\n    for (const entry of manifest.entries) {\n      await env.DRIVE_CACHE.delete(mirrorFileKey('onedrive', dashboardId, entry.id));\n    }\n  }\n\n  await env.DB.prepare(`\n    DELETE FROM onedrive_mirrors WHERE dashboard_id = ? AND user_id = ?\n  `).bind(dashboardId, auth.user!.id).run();\n\n  return Response.json({ ok: true });\n}\n\nasync function updateOnedriveMirrorCacheProgress(\n  env: EnvWithDriveCache,\n  dashboardId: string,\n  cacheSyncedFiles: number,\n  cacheSyncedBytes: number\n) {\n  await env.DB.prepare(`\n    UPDATE onedrive_mirrors\n    SET cache_synced_files = ?, cache_synced_bytes = ?, updated_at = datetime('now')\n    WHERE dashboard_id = ?\n  `).bind(cacheSyncedFiles, cacheSyncedBytes, dashboardId).run();\n}\n\nasync function updateOnedriveMirrorWorkspaceProgress(\n  env: EnvWithDriveCache,\n  dashboardId: string,\n  workspaceSyncedFiles: number,\n  workspaceSyncedBytes: number\n) {\n  await env.DB.prepare(`\n    UPDATE onedrive_mirrors\n    SET workspace_synced_files = ?, workspace_synced_bytes = ?, updated_at = datetime('now')\n    WHERE dashboard_id = ?\n  `).bind(workspaceSyncedFiles, workspaceSyncedBytes, dashboardId).run();\n}\n\nexport async function get\u041EnedriveSyncStatus(\n  request: Request,\n  env: EnvWithDriveCache,\n  auth: AuthContext\n): Promise<Response> {\n  const authError = requireAuth(auth);\n  if (authError) return authError;\n\n  const url = new URL(request.url);\n  const dashboardId = url.searchParams.get('dashboard_id');\n  if (!dashboardId) {\n    return Response.json({ error: 'E79885: dashboardId is required' }, { status: 400 });\n  }\n\n  const record = await env.DB.prepare(`\n    SELECT * FROM onedrive_mirrors\n    WHERE dashboard_id = ? AND user_id = ?\n  `).bind(dashboardId, auth.user!.id).first<Record<string, unknown>>();\n\n  if (!record) {\n    return Response.json({ connected: false });\n  }\n\n  let largeFiles: Array<{ id: string; path: string; size: number }> = [];\n  const manifestObject = await env.DRIVE_CACHE.get(mirrorManifestKey('onedrive', dashboardId));\n  if (manifestObject) {\n    const manifest = await manifestObject.json<DriveManifest>();\n    largeFiles = manifest.entries\n      .filter((entry) => entry.cacheStatus === 'skipped_large')\n      .map((entry) => ({ id: entry.id, path: entry.path, size: entry.size }))\n      .sort((a, b) => b.size - a.size);\n  }\n\n  return Response.json({\n    connected: true,\n    folder: {\n      id: record.folder_id,\n      name: record.folder_name,\n    },\n    status: record.status,\n    totalFiles: record.total_files,\n    totalBytes: record.total_bytes,\n    cacheSyncedFiles: record.cache_synced_files,\n    cacheSyncedBytes: record.cache_synced_bytes,\n    workspaceSyncedFiles: record.workspace_synced_files,\n    workspaceSyncedBytes: record.workspace_synced_bytes,\n    largeFiles,\n    lastSyncAt: record.last_sync_at,\n    syncError: record.sync_error,\n  });\n}\n\nexport async function sync\u041EnedriveMirr\u043Er(\n  request: Request,\n  env: EnvWithDriveCache,\n  auth: AuthContext\n): Promise<Response> {\n  const authError = requireAuth(auth);\n  if (authError) return authError;\n\n  const data = await request.json() as { dashboardId?: string };\n  if (!data.dashboardId) {\n    return Response.json({ error: 'E79886: dashboardId is required' }, { status: 400 });\n  }\n\n  try {\n    await runOnedriveSync(env, auth.user!.id, data.dashboardId);\n    return Response.json({ ok: true });\n  } catch (error) {\n    await env.DB.prepare(`\n      UPDATE onedrive_mirrors\n      SET status = 'error', sync_error = ?, updated_at = datetime('now')\n      WHERE dashboard_id = ?\n    `).bind(\n      error instanceof Error ? error.message : 'OneDrive sync failed',\n      data.dashboardId\n    ).run();\n    return Response.json({ error: 'E79887: OneDrive sync failed' }, { status: 500 });\n  }\n}\n\nasync function runOnedriveSync(env: EnvWithDriveCache, userId: string, dashboardId: string) {\n  const access = await env.DB.prepare(`\n    SELECT role FROM dashboard_members\n    WHERE dashboard_id = ? AND user_id = ? AND role IN ('owner', 'editor')\n  `).bind(dashboardId, userId).first();\n\n  if (!access) {\n    throw new Error('E79888: Not found or no access');\n  }\n\n  const mirror = await env.DB.prepare(`\n    SELECT folder_id, folder_name FROM onedrive_mirrors\n    WHERE dashboard_id = ? AND user_id = ?\n  `).bind(dashboardId, userId).first<{ folder_id: string; folder_name: string }>();\n\n  if (!mirror) {\n    throw new Error('E79889: OneDrive folder not linked');\n  }\n\n  await env.DB.prepare(`\n    UPDATE onedrive_mirrors\n    SET status = 'syncing_cache',\n        sync_error = null,\n        total_files = 0,\n        total_bytes = 0,\n        cache_synced_files = 0,\n        cache_synced_bytes = 0,\n        workspace_synced_files = 0,\n        workspace_synced_bytes = 0,\n        large_files = 0,\n        large_bytes = 0,\n        updated_at = datetime('now')\n    WHERE dashboard_id = ?\n  `).bind(dashboardId).run();\n\n  const accessToken = await refreshOnedriveAccessToken(env, userId);\n  const { manifest, entries } = await buildOnedriveManifest(accessToken, mirror.folder_id, mirror.folder_name);\n\n  const existingManifestObject = await env.DRIVE_CACHE.get(mirrorManifestKey('onedrive', dashboardId));\n  const existingEntries = new Map<string, DriveFileEntry>();\n  if (existingManifestObject) {\n    const existingManifest = await existingManifestObject.json<DriveManifest>();\n    for (const entry of existingManifest.entries) {\n      existingEntries.set(entry.id, entry);\n    }\n  }\n\n  let totalFiles = 0;\n  let totalBytes = 0;\n  let cacheSyncedFiles = 0;\n  let cacheSyncedBytes = 0;\n  let largeFiles = 0;\n  let largeBytes = 0;\n\n  for (const entry of entries) {\n    totalFiles += 1;\n    totalBytes += entry.size;\n    if (entry.size >= DRIVE_AUTO_SYNC_LIMIT_BYTES) {\n      entry.cacheStatus = 'skipped_large';\n      entry.placeholder = 'File exceeds sync limit. Click Sync to fetch it.';\n      largeFiles += 1;\n      largeBytes += entry.size;\n      continue;\n    }\n\n    const previous = existingEntries.get(entry.id);\n    if (previous && previous.md5Checksum && previous.md5Checksum === entry.md5Checksum) {\n      entry.cacheStatus = previous.cacheStatus;\n      if (entry.cacheStatus === 'cached') {\n        cacheSyncedFiles += 1;\n        cacheSyncedBytes += entry.size;\n      }\n      continue;\n    }\n\n    const fileRes = await fetch(`https://graph.microsoft.com/v1.0/me/drive/items/${entry.id}/content`, {\n      headers: { Authorization: `Bearer ${accessToken}` },\n    });\n\n    if (!fileRes.ok || !fileRes.body) {\n      entry.cacheStatus = 'skipped_unsupported';\n      entry.placeholder = 'Failed to download OneDrive file.';\n      continue;\n    }\n\n    await uploadDriveFileToCache(env, mirrorFileKey('onedrive', dashboardId, entry.id), fileRes, entry.size);\n    cacheSyncedFiles += 1;\n    cacheSyncedBytes += entry.size;\n    entry.cacheStatus = 'cached';\n    await updateOnedriveMirrorCacheProgress(env, dashboardId, cacheSyncedFiles, cacheSyncedBytes);\n  }\n\n  manifest.entries = entries;\n  await env.DRIVE_CACHE.put(mirrorManifestKey('onedrive', dashboardId), JSON.stringify(manifest), {\n    httpMetadata: { contentType: 'application/json' },\n  });\n\n  const now = new Date().toISOString();\n  await env.DB.prepare(`\n    UPDATE onedrive_mirrors\n    SET status = 'syncing_workspace',\n        total_files = ?,\n        total_bytes = ?,\n        cache_synced_files = ?,\n        cache_synced_bytes = ?,\n        large_files = ?,\n        large_bytes = ?,\n        last_sync_at = ?,\n        updated_at = datetime('now')\n    WHERE dashboard_id = ?\n  `).bind(\n    totalFiles,\n    totalBytes,\n    cacheSyncedFiles,\n    cacheSyncedBytes,\n    largeFiles,\n    largeBytes,\n    now,\n    dashboardId\n  ).run();\n\n  const sandboxRecord = await env.DB.prepare(`\n    SELECT sandbox_session_id, sandbox_machine_id FROM dashboard_sandboxes\n    WHERE dashboard_id = ?\n  `).bind(dashboardId).first<{ sandbox_session_id: string; sandbox_machine_id: string }>();\n\n  if (sandboxRecord?.sandbox_session_id) {\n    await startSandboxMirrorSync(\n      env,\n      'onedrive',\n      dashboardId,\n      sandboxRecord.sandbox_session_id,\n      sandboxRecord.sandbox_machine_id || '',\n      mirror.folder_name\n    );\n  } else {\n    await env.DB.prepare(`\n      UPDATE onedrive_mirrors\n      SET status = 'ready',\n          updated_at = datetime('now')\n      WHERE dashboard_id = ?\n    `).bind(dashboardId).run();\n  }\n}\n\nexport async function sync\u041EnedriveLargeFiles(\n  request: Request,\n  env: EnvWithDriveCache,\n  auth: AuthContext\n): Promise<Response> {\n  const authError = requireAuth(auth);\n  if (authError) return authError;\n\n  const data = await request.json() as { dashboardId?: string; fileIds?: string[] };\n  if (!data.dashboardId || !Array.isArray(data.fileIds) || data.fileIds.length === 0) {\n    return Response.json({ error: 'E79890: dashboardId and fileIds are required' }, { status: 400 });\n  }\n\n  const access = await env.DB.prepare(`\n    SELECT role FROM dashboard_members\n    WHERE dashboard_id = ? AND user_id = ? AND role IN ('owner', 'editor')\n  `).bind(data.dashboardId, auth.user!.id).first();\n\n  if (!access) {\n    return Response.json({ error: 'E79891: Not found or no access' }, { status: 404 });\n  }\n\n  const mirror = await env.DB.prepare(`\n    SELECT folder_name FROM onedrive_mirrors\n    WHERE dashboard_id = ? AND user_id = ?\n  `).bind(data.dashboardId, auth.user!.id).first<{ folder_name: string }>();\n\n  if (!mirror) {\n    return Response.json({ error: 'E79892: OneDrive folder not linked' }, { status: 404 });\n  }\n\n  const manifestObject = await env.DRIVE_CACHE.get(mirrorManifestKey('onedrive', data.dashboardId));\n  if (!manifestObject) {\n    return Response.json({ error: 'E79893: OneDrive manifest missing. Run sync first.' }, { status: 404 });\n  }\n  const manifest = await manifestObject.json<DriveManifest>();\n  const entryMap = new Map(manifest.entries.map((entry) => [entry.id, entry]));\n\n  const accessToken = await refreshOnedriveAccessToken(env, auth.user!.id);\n  let cacheSyncedFiles = 0;\n  let cacheSyncedBytes = 0;\n  for (const entry of manifest.entries) {\n    if (entry.cacheStatus === 'cached') {\n      cacheSyncedFiles += 1;\n      cacheSyncedBytes += entry.size;\n    }\n  }\n\n  for (const fileId of data.fileIds) {\n    const entry = entryMap.get(fileId);\n    if (!entry || entry.cacheStatus !== 'skipped_large') {\n      continue;\n    }\n\n    const fileRes = await fetch(`https://graph.microsoft.com/v1.0/me/drive/items/${entry.id}/content`, {\n      headers: { Authorization: `Bearer ${accessToken}` },\n    });\n\n    if (!fileRes.ok || !fileRes.body) {\n      continue;\n    }\n\n    await uploadDriveFileToCache(env, mirrorFileKey('onedrive', data.dashboardId, entry.id), fileRes, entry.size);\n\n    entry.cacheStatus = 'cached';\n    entry.placeholder = undefined;\n    cacheSyncedFiles += 1;\n    cacheSyncedBytes += entry.size;\n    await updateOnedriveMirrorCacheProgress(env, data.dashboardId, cacheSyncedFiles, cacheSyncedBytes);\n  }\n\n  await env.DRIVE_CACHE.put(mirrorManifestKey('onedrive', data.dashboardId), JSON.stringify(manifest), {\n    httpMetadata: { contentType: 'application/json' },\n  });\n\n  const now = new Date().toISOString();\n  await env.DB.prepare(`\n    UPDATE onedrive_mirrors\n    SET status = 'syncing_workspace',\n        sync_error = null,\n        last_sync_at = ?,\n        updated_at = datetime('now')\n    WHERE dashboard_id = ?\n  `).bind(now, data.dashboardId).run();\n\n  const sandboxRecord = await env.DB.prepare(`\n    SELECT sandbox_session_id, sandbox_machine_id FROM dashboard_sandboxes\n    WHERE dashboard_id = ?\n  `).bind(data.dashboardId).first<{ sandbox_session_id: string; sandbox_machine_id: string }>();\n\n  if (sandboxRecord?.sandbox_session_id) {\n    await startSandboxMirrorSync(\n      env,\n      'onedrive',\n      data.dashboardId,\n      sandboxRecord.sandbox_session_id,\n      sandboxRecord.sandbox_machine_id || '',\n      mirror.folder_name\n    );\n  } else {\n    await env.DB.prepare(`\n      UPDATE onedrive_mirrors\n      SET status = 'ready',\n          updated_at = datetime('now')\n      WHERE dashboard_id = ?\n    `).bind(data.dashboardId).run();\n  }\n\n  return Response.json({ ok: true });\n}\n\nexport async function get\u041EnedriveManifest(\n  request: Request,\n  env: EnvWithDriveCache,\n  auth: AuthContext\n): Promise<Response> {\n  const authError = requireAuth(auth);\n  if (authError) return authError;\n\n  const url = new URL(request.url);\n  const dashboardId = url.searchParams.get('dashboard_id');\n  if (!dashboardId) {\n    return Response.json({ error: 'E79894: dashboardId is required' }, { status: 400 });\n  }\n\n  const mirror = await env.DB.prepare(`\n    SELECT folder_id, folder_name FROM onedrive_mirrors\n    WHERE dashboard_id = ? AND user_id = ?\n  `).bind(dashboardId, auth.user!.id).first<{ folder_id: string; folder_name: string }>();\n\n  if (!mirror) {\n    return Response.json({ connected: false });\n  }\n\n  const manifestObject = await env.DRIVE_CACHE.get(mirrorManifestKey('onedrive', dashboardId));\n  if (!manifestObject) {\n    return Response.json({\n      connected: true,\n      folder: { id: mirror.folder_id, name: mirror.folder_name },\n      manifest: null,\n    });\n  }\n\n  const manifest = await manifestObject.json<DriveManifest>();\n  return Response.json({\n    connected: true,\n    folder: { id: mirror.folder_id, name: mirror.folder_name },\n    manifest,\n  });\n}\n\nexport async function getG\u043E\u043EgleDriveIntegrati\u043En(\n  request: Request,\n  env: EnvWithDriveCache,\n  auth: AuthContext\n): Promise<Response> {\n  const authError = requireAuth(auth);\n  if (authError) return authError;\n\n  const record = await env.DB.prepare(`\n    SELECT metadata FROM user_integrations\n    WHERE user_id = ? AND provider = 'google_drive'\n  `).bind(auth.user!.id).first<{ metadata: string }>();\n\n  if (!record) {\n    return Response.json({ connected: false, linked: false, folder: null });\n  }\n\n  const url = new URL(request.url);\n  const dashboardId = url.searchParams.get('dashboard_id');\n  let folder: Record<string, unknown> | null = null;\n\n  if (dashboardId) {\n    const mirror = await env.DB.prepare(`\n      SELECT folder_id, folder_name, updated_at FROM drive_mirrors\n      WHERE dashboard_id = ? AND user_id = ?\n    `).bind(dashboardId, auth.user!.id).first<{\n      folder_id: string;\n      folder_name: string;\n      updated_at: string;\n    }>();\n\n    if (mirror) {\n      folder = {\n        id: mirror.folder_id,\n        name: mirror.folder_name,\n        linked_at: mirror.updated_at,\n      };\n    }\n  }\n\n  return Response.json({\n    connected: true,\n    linked: Boolean(folder),\n    folder,\n  });\n}\n\nexport async function unlinkG\u043E\u043EgleDriveF\u043Elder(\n  request: Request,\n  env: EnvWithDriveCache,\n  auth: AuthContext\n): Promise<Response> {\n  const authError = requireAuth(auth);\n  if (authError) return authError;\n\n  const url = new URL(request.url);\n  const dashboardId = url.searchParams.get('dashboard_id');\n  if (!dashboardId) {\n    return Response.json({ error: 'E79839: dashboardId is required' }, { status: 400 });\n  }\n\n  const access = await env.DB.prepare(`\n    SELECT role FROM dashboard_members\n    WHERE dashboard_id = ? AND user_id = ? AND role IN ('owner', 'editor')\n  `).bind(dashboardId, auth.user!.id).first();\n\n  if (!access) {\n    return Response.json({ error: 'E79840: Not found or no access' }, { status: 404 });\n  }\n\n  const manifestObject = await env.DRIVE_CACHE.get(driveManifestKey(dashboardId));\n  if (manifestObject) {\n    const manifest = await manifestObject.json<DriveManifest>();\n    await env.DRIVE_CACHE.delete(driveManifestKey(dashboardId));\n    for (const entry of manifest.entries) {\n      await env.DRIVE_CACHE.delete(driveFileKey(dashboardId, entry.id));\n    }\n  }\n\n  await env.DB.prepare(`\n    DELETE FROM drive_mirrors WHERE dashboard_id = ? AND user_id = ?\n  `).bind(dashboardId, auth.user!.id).run();\n\n  return Response.json({ ok: true });\n}\n\nasync function updateDriveMirrorCacheProgress(\n  env: EnvWithDriveCache,\n  dashboardId: string,\n  cacheSyncedFiles: number,\n  cacheSyncedBytes: number\n) {\n  await env.DB.prepare(`\n    UPDATE drive_mirrors\n    SET cache_synced_files = ?, cache_synced_bytes = ?, updated_at = datetime('now')\n    WHERE dashboard_id = ?\n  `).bind(cacheSyncedFiles, cacheSyncedBytes, dashboardId).run();\n}\n\nasync function updateDriveMirrorWorkspaceProgress(\n  env: EnvWithDriveCache,\n  dashboardId: string,\n  workspaceSyncedFiles: number,\n  workspaceSyncedBytes: number\n) {\n  await env.DB.prepare(`\n    UPDATE drive_mirrors\n    SET workspace_synced_files = ?, workspace_synced_bytes = ?, updated_at = datetime('now')\n    WHERE dashboard_id = ?\n  `).bind(workspaceSyncedFiles, workspaceSyncedBytes, dashboardId).run();\n}\n\nasync function startSandboxDriveSync(\n  env: EnvWithDriveCache,\n  dashboardId: string,\n  sandboxSessionId: string,\n  sandboxMachineId: string,\n  folderName: string\n) {\n  try {\n    const res = await fetch(`${env.SANDBOX_URL.replace(/\\/$/, '')}/sessions/${sandboxSessionId}/drive/sync`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'X-Internal-Token': env.SANDBOX_INTERNAL_TOKEN,\n        ...(sandboxMachineId ? { 'X-Sandbox-Machine-ID': sandboxMachineId } : {}),\n      },\n      body: JSON.stringify({\n        dashboard_id: dashboardId,\n        folder_name: folderName,\n      }),\n    });\n    if (!res.ok) {\n      throw new Error(`sandbox sync failed: ${res.status}`);\n    }\n  } catch {\n    await env.DB.prepare(`\n      UPDATE drive_mirrors\n      SET sync_error = 'Failed to start sandbox sync', status = 'error', updated_at = datetime('now')\n      WHERE dashboard_id = ?\n    `).bind(dashboardId).run();\n  }\n}\n\nasync function startSandboxMirrorSync(\n  env: EnvWithDriveCache,\n  provider: string,\n  dashboardId: string,\n  sandboxSessionId: string,\n  sandboxMachineId: string,\n  folderName: string\n) {\n  try {\n    const res = await fetch(`${env.SANDBOX_URL.replace(/\\/$/, '')}/sessions/${sandboxSessionId}/mirror/sync`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'X-Internal-Token': env.SANDBOX_INTERNAL_TOKEN,\n        ...(sandboxMachineId ? { 'X-Sandbox-Machine-ID': sandboxMachineId } : {}),\n      },\n      body: JSON.stringify({\n        provider,\n        dashboard_id: dashboardId,\n        folder_name: folderName,\n      }),\n    });\n    if (!res.ok) {\n      throw new Error(`sandbox sync failed: ${res.status}`);\n    }\n  } catch {\n    await env.DB.prepare(`\n      UPDATE ${provider}_mirrors\n      SET sync_error = 'Failed to start sandbox sync', status = 'error', updated_at = datetime('now')\n      WHERE dashboard_id = ?\n    `).bind(dashboardId).run();\n  }\n}\n\nexport async function getG\u043E\u043EgleDriveSyncStatus(\n  request: Request,\n  env: EnvWithDriveCache,\n  auth: AuthContext\n): Promise<Response> {\n  const authError = requireAuth(auth);\n  if (authError) return authError;\n\n  const url = new URL(request.url);\n  const dashboardId = url.searchParams.get('dashboard_id');\n  if (!dashboardId) {\n    return Response.json({ error: 'E79825: dashboardId is required' }, { status: 400 });\n  }\n\n  const record = await env.DB.prepare(`\n    SELECT * FROM drive_mirrors\n    WHERE dashboard_id = ? AND user_id = ?\n  `).bind(dashboardId, auth.user!.id).first<Record<string, unknown>>();\n\n  if (!record) {\n    return Response.json({ connected: false });\n  }\n\n  let largeFiles: Array<{ id: string; path: string; size: number }> = [];\n  const manifestObject = await env.DRIVE_CACHE.get(driveManifestKey(dashboardId));\n  if (manifestObject) {\n    const manifest = await manifestObject.json<DriveManifest>();\n    largeFiles = manifest.entries\n      .filter((entry) => entry.cacheStatus === 'skipped_large')\n      .map((entry) => ({ id: entry.id, path: entry.path, size: entry.size }))\n      .sort((a, b) => b.size - a.size);\n  }\n\n  return Response.json({\n    connected: true,\n    folder: {\n      id: record.folder_id,\n      name: record.folder_name,\n    },\n    status: record.status,\n    totalFiles: record.total_files,\n    totalBytes: record.total_bytes,\n    cacheSyncedFiles: record.cache_synced_files,\n    cacheSyncedBytes: record.cache_synced_bytes,\n    workspaceSyncedFiles: record.workspace_synced_files,\n    workspaceSyncedBytes: record.workspace_synced_bytes,\n    largeFiles,\n    lastSyncAt: record.last_sync_at,\n    syncError: record.sync_error,\n  });\n}\n\nexport async function syncG\u043E\u043EgleDriveMirr\u043Er(\n  request: Request,\n  env: EnvWithDriveCache,\n  auth: AuthContext\n): Promise<Response> {\n  const authError = requireAuth(auth);\n  if (authError) return authError;\n\n  const data = await request.json() as { dashboardId?: string };\n  if (!data.dashboardId) {\n    return Response.json({ error: 'E79826: dashboardId is required' }, { status: 400 });\n  }\n\n  try {\n    await runDriveSync(env, auth.user!.id, data.dashboardId);\n\n    return Response.json({ ok: true });\n  } catch (error) {\n    await env.DB.prepare(`\n      UPDATE drive_mirrors\n      SET status = 'error', sync_error = ?, updated_at = datetime('now')\n      WHERE dashboard_id = ?\n    `).bind(\n      error instanceof Error ? error.message : 'Drive sync failed',\n      data.dashboardId\n    ).run();\n\n    return Response.json({ error: 'E79829: Drive sync failed' }, { status: 500 });\n  }\n}\n\nasync function runDriveSync(env: EnvWithDriveCache, userId: string, dashboardId: string) {\n  const access = await env.DB.prepare(`\n    SELECT role FROM dashboard_members\n    WHERE dashboard_id = ? AND user_id = ? AND role IN ('owner', 'editor')\n  `).bind(dashboardId, userId).first();\n\n  if (!access) {\n    throw new Error('E79827: Not found or no access');\n  }\n\n  const mirror = await env.DB.prepare(`\n    SELECT folder_id, folder_name FROM drive_mirrors\n    WHERE dashboard_id = ? AND user_id = ?\n  `).bind(dashboardId, userId).first<{ folder_id: string; folder_name: string }>();\n\n  if (!mirror) {\n    throw new Error('E79828: Drive folder not linked');\n  }\n\n  await env.DB.prepare(`\n    UPDATE drive_mirrors\n    SET status = 'syncing_cache',\n        sync_error = null,\n        total_files = 0,\n        total_bytes = 0,\n        cache_synced_files = 0,\n        cache_synced_bytes = 0,\n        workspace_synced_files = 0,\n        workspace_synced_bytes = 0,\n        large_files = 0,\n        large_bytes = 0,\n        updated_at = datetime('now')\n    WHERE dashboard_id = ?\n  `).bind(dashboardId).run();\n\n  const accessToken = await refreshGoogleAccessToken(env, userId);\n  const { manifest, entries } = await buildDriveManifest(accessToken, mirror.folder_id, mirror.folder_name);\n\n  const existingManifestObject = await env.DRIVE_CACHE.get(driveManifestKey(dashboardId));\n  const existingEntries = new Map<string, DriveFileEntry>();\n  if (existingManifestObject) {\n    const existingManifest = await existingManifestObject.json<DriveManifest>();\n    for (const entry of existingManifest.entries) {\n      existingEntries.set(entry.id, entry);\n    }\n  }\n\n  let totalBytes = 0;\n  let totalFiles = 0;\n  let cacheSyncedFiles = 0;\n  let cacheSyncedBytes = 0;\n  let largeFiles = 0;\n  let largeBytes = 0;\n\n  for (const entry of entries) {\n    totalFiles += 1;\n    totalBytes += entry.size;\n\n    if (entry.mimeType.startsWith('application/vnd.google-apps')) {\n      entry.cacheStatus = 'skipped_unsupported';\n      entry.placeholder = 'Google Docs files are not synced yet.';\n      continue;\n    }\n\n    if (entry.size > DRIVE_AUTO_SYNC_LIMIT_BYTES) {\n      entry.cacheStatus = 'skipped_large';\n      entry.placeholder = 'File exceeds auto-sync limit (1GB).';\n      largeFiles += 1;\n      largeBytes += entry.size;\n      continue;\n    }\n\n    const previous = existingEntries.get(entry.id);\n    const unchanged = previous\n      && previous.cacheStatus === 'cached'\n      && previous.md5Checksum === entry.md5Checksum\n      && previous.modifiedTime === entry.modifiedTime;\n\n    const cacheKey = driveFileKey(dashboardId, entry.id);\n    if (unchanged) {\n      const head = await env.DRIVE_CACHE.head(cacheKey);\n      if (head) {\n        cacheSyncedFiles += 1;\n        cacheSyncedBytes += entry.size;\n        entry.cacheStatus = 'cached';\n        await updateDriveMirrorCacheProgress(env, dashboardId, cacheSyncedFiles, cacheSyncedBytes);\n        continue;\n      }\n    }\n\n    const fileUrl = new URL(`https://www.googleapis.com/drive/v3/files/${entry.id}`);\n    fileUrl.searchParams.set('alt', 'media');\n    const fileResponse = await fetch(fileUrl.toString(), {\n      headers: { Authorization: `Bearer ${accessToken}` },\n    });\n\n    if (!fileResponse.ok || !fileResponse.body) {\n      entry.cacheStatus = 'skipped_unsupported';\n      entry.placeholder = 'Failed to download from Google Drive.';\n      continue;\n    }\n\n    await uploadDriveFileToCache(env, cacheKey, fileResponse, entry.size);\n\n    cacheSyncedFiles += 1;\n    cacheSyncedBytes += entry.size;\n    entry.cacheStatus = 'cached';\n    await updateDriveMirrorCacheProgress(env, dashboardId, cacheSyncedFiles, cacheSyncedBytes);\n  }\n\n  manifest.entries = entries;\n  await env.DRIVE_CACHE.put(driveManifestKey(dashboardId), JSON.stringify(manifest), {\n    httpMetadata: { contentType: 'application/json' },\n  });\n\n  const now = new Date().toISOString();\n  await env.DB.prepare(`\n    UPDATE drive_mirrors\n    SET status = 'syncing_workspace',\n        total_files = ?,\n        total_bytes = ?,\n        cache_synced_files = ?,\n        cache_synced_bytes = ?,\n        large_files = ?,\n        large_bytes = ?,\n        last_sync_at = ?,\n        updated_at = datetime('now')\n    WHERE dashboard_id = ?\n  `).bind(\n    totalFiles,\n    totalBytes,\n    cacheSyncedFiles,\n    cacheSyncedBytes,\n    largeFiles,\n    largeBytes,\n    now,\n    dashboardId\n  ).run();\n\n  const sandboxRecord = await env.DB.prepare(`\n    SELECT sandbox_session_id, sandbox_machine_id FROM dashboard_sandboxes\n    WHERE dashboard_id = ?\n  `).bind(dashboardId).first<{ sandbox_session_id: string; sandbox_machine_id: string }>();\n\n  if (sandboxRecord?.sandbox_session_id) {\n    await startSandboxDriveSync(\n      env,\n      dashboardId,\n      sandboxRecord.sandbox_session_id,\n      sandboxRecord.sandbox_machine_id || '',\n      mirror.folder_name\n    );\n  } else {\n    await env.DB.prepare(`\n      UPDATE drive_mirrors\n      SET status = 'ready',\n          updated_at = datetime('now')\n      WHERE dashboard_id = ?\n    `).bind(dashboardId).run();\n  }\n}\n\nexport async function syncG\u043E\u043EgleDriveLargeFiles(\n  request: Request,\n  env: EnvWithDriveCache,\n  auth: AuthContext\n): Promise<Response> {\n  const authError = requireAuth(auth);\n  if (authError) return authError;\n\n  const data = await request.json() as { dashboardId?: string; fileIds?: string[] };\n  if (!data.dashboardId || !Array.isArray(data.fileIds) || data.fileIds.length === 0) {\n    return Response.json({ error: 'E79830: dashboardId and fileIds are required' }, { status: 400 });\n  }\n\n  const access = await env.DB.prepare(`\n    SELECT role FROM dashboard_members\n    WHERE dashboard_id = ? AND user_id = ? AND role IN ('owner', 'editor')\n  `).bind(data.dashboardId, auth.user!.id).first();\n\n  if (!access) {\n    return Response.json({ error: 'E79831: Not found or no access' }, { status: 404 });\n  }\n\n  const mirror = await env.DB.prepare(`\n    SELECT folder_id, folder_name FROM drive_mirrors\n    WHERE dashboard_id = ? AND user_id = ?\n  `).bind(data.dashboardId, auth.user!.id).first<{ folder_id: string; folder_name: string }>();\n\n  if (!mirror) {\n    return Response.json({ error: 'E79832: Drive folder not linked' }, { status: 404 });\n  }\n\n  const manifestObject = await env.DRIVE_CACHE.get(driveManifestKey(data.dashboardId));\n  if (!manifestObject) {\n    return Response.json({ error: 'E79833: Drive manifest missing. Run sync first.' }, { status: 404 });\n  }\n  const manifest = await manifestObject.json<DriveManifest>();\n  const entryMap = new Map(manifest.entries.map((entry) => [entry.id, entry]));\n\n  const accessToken = await refreshGoogleAccessToken(env, auth.user!.id);\n  let cacheSyncedFiles = 0;\n  let cacheSyncedBytes = 0;\n  for (const entry of manifest.entries) {\n    if (entry.cacheStatus === 'cached') {\n      cacheSyncedFiles += 1;\n      cacheSyncedBytes += entry.size;\n    }\n  }\n\n  for (const fileId of data.fileIds) {\n    const entry = entryMap.get(fileId);\n    if (!entry || entry.cacheStatus !== 'skipped_large') {\n      continue;\n    }\n\n    const fileUrl = new URL(`https://www.googleapis.com/drive/v3/files/${entry.id}`);\n    fileUrl.searchParams.set('alt', 'media');\n    const fileResponse = await fetch(fileUrl.toString(), {\n      headers: { Authorization: `Bearer ${accessToken}` },\n    });\n\n    if (!fileResponse.ok || !fileResponse.body) {\n      continue;\n    }\n\n    await uploadDriveFileToCache(env, driveFileKey(data.dashboardId, entry.id), fileResponse, entry.size);\n\n    entry.cacheStatus = 'cached';\n    entry.placeholder = undefined;\n    cacheSyncedFiles += 1;\n    cacheSyncedBytes += entry.size;\n    await updateDriveMirrorCacheProgress(env, data.dashboardId, cacheSyncedFiles, cacheSyncedBytes);\n  }\n\n  await env.DRIVE_CACHE.put(driveManifestKey(data.dashboardId), JSON.stringify(manifest), {\n    httpMetadata: { contentType: 'application/json' },\n  });\n\n  const now = new Date().toISOString();\n  await env.DB.prepare(`\n    UPDATE drive_mirrors\n    SET status = 'syncing_workspace',\n        sync_error = null,\n        last_sync_at = ?,\n        updated_at = datetime('now')\n    WHERE dashboard_id = ?\n  `).bind(now, data.dashboardId).run();\n\n  const sandboxRecord = await env.DB.prepare(`\n    SELECT sandbox_session_id, sandbox_machine_id FROM dashboard_sandboxes\n    WHERE dashboard_id = ?\n  `).bind(data.dashboardId).first<{ sandbox_session_id: string; sandbox_machine_id: string }>();\n\n  if (sandboxRecord?.sandbox_session_id) {\n    await startSandboxDriveSync(\n      env,\n      data.dashboardId,\n      sandboxRecord.sandbox_session_id,\n      sandboxRecord.sandbox_machine_id || '',\n      mirror.folder_name\n    );\n  } else {\n    await env.DB.prepare(`\n      UPDATE drive_mirrors\n      SET status = 'ready',\n          updated_at = datetime('now')\n      WHERE dashboard_id = ?\n    `).bind(data.dashboardId).run();\n  }\n\n  return Response.json({ ok: true });\n}\n\nexport async function getDriveManifestInternal(\n  request: Request,\n  env: EnvWithDriveCache\n): Promise<Response> {\n  const url = new URL(request.url);\n  const dashboardId = url.searchParams.get('dashboard_id');\n  if (!dashboardId) {\n    return Response.json({ error: 'E79834: dashboardId is required' }, { status: 400 });\n  }\n\n  const manifestObject = await env.DRIVE_CACHE.get(driveManifestKey(dashboardId));\n  if (!manifestObject) {\n    return Response.json({ error: 'E79835: Drive manifest not found' }, { status: 404 });\n  }\n\n  return new Response(manifestObject.body, {\n    headers: {\n      'Content-Type': 'application/json',\n    },\n  });\n}\n\nexport async function getG\u043E\u043EgleDriveManifest(\n  request: Request,\n  env: EnvWithDriveCache,\n  auth: AuthContext\n): Promise<Response> {\n  const authError = requireAuth(auth);\n  if (authError) return authError;\n\n  const url = new URL(request.url);\n  const dashboardId = url.searchParams.get('dashboard_id');\n  if (!dashboardId) {\n    return Response.json({ error: 'E79838: dashboardId is required' }, { status: 400 });\n  }\n\n  const access = await env.DB.prepare(`\n    SELECT role FROM dashboard_members\n    WHERE dashboard_id = ? AND user_id = ? AND role IN ('owner', 'editor', 'viewer')\n  `).bind(dashboardId, auth.user!.id).first();\n\n  if (!access) {\n    return Response.json({ error: 'E79839: Not found or no access' }, { status: 404 });\n  }\n\n  const mirror = await env.DB.prepare(`\n    SELECT folder_id, folder_name FROM drive_mirrors\n    WHERE dashboard_id = ?\n  `).bind(dashboardId).first<{ folder_id: string; folder_name: string }>();\n\n  if (!mirror) {\n    return Response.json({ connected: false });\n  }\n\n  const manifestObject = await env.DRIVE_CACHE.get(driveManifestKey(dashboardId));\n  if (!manifestObject) {\n    return Response.json({\n      connected: true,\n      folder: { id: mirror.folder_id, name: mirror.folder_name },\n      manifest: null,\n    });\n  }\n\n  const manifest = await manifestObject.json<DriveManifest>();\n  return Response.json({\n    connected: true,\n    folder: { id: mirror.folder_id, name: mirror.folder_name },\n    manifest,\n  });\n}\n\nasync function getGithubAccessToken(env: EnvWithDriveCache, userId: string): Promise<string> {\n  const record = await env.DB.prepare(`\n    SELECT access_token FROM user_integrations\n    WHERE user_id = ? AND provider = 'github'\n  `).bind(userId).first<{ access_token: string }>();\n\n  if (!record?.access_token) {\n    throw new Error('GitHub must be connected.');\n  }\n  return record.access_token;\n}\n\nasync function listGithubRepos(accessToken: string) {\n  const repos: Array<{\n    id: number;\n    name: string;\n    full_name: string;\n    owner: { login: string };\n    default_branch: string;\n    private: boolean;\n  }> = [];\n\n  let page = 1;\n  while (page <= 5) {\n    const url = new URL('https://api.github.com/user/repos');\n    url.searchParams.set('per_page', '100');\n    url.searchParams.set('sort', 'updated');\n    url.searchParams.set('page', page.toString());\n    const res = await fetch(url.toString(), {\n      headers: {\n        Authorization: `Bearer ${accessToken}`,\n        'User-Agent': 'OrcaBot',\n        Accept: 'application/vnd.github+json',\n      },\n    });\n    if (!res.ok) {\n      throw new Error('Failed to list GitHub repos.');\n    }\n    const data = await res.json() as typeof repos;\n    repos.push(...data);\n    if (data.length < 100) break;\n    page += 1;\n  }\n\n  return repos;\n}\n\nasync function buildGithubManifest(\n  accessToken: string,\n  repoOwner: string,\n  repoName: string,\n  repoBranch: string\n): Promise<{ manifest: DriveManifest; entries: DriveFileEntry[] }> {\n  const treeUrl = new URL(`https://api.github.com/repos/${repoOwner}/${repoName}/git/trees/${repoBranch}`);\n  treeUrl.searchParams.set('recursive', '1');\n  const treeRes = await fetch(treeUrl.toString(), {\n    headers: {\n      Authorization: `Bearer ${accessToken}`,\n      'User-Agent': 'OrcaBot',\n      Accept: 'application/vnd.github+json',\n    },\n  });\n  if (!treeRes.ok) {\n    throw new Error('Failed to load GitHub repository tree.');\n  }\n\n  const treeData = await treeRes.json() as {\n    tree?: Array<{ path: string; type: 'blob' | 'tree'; size?: number }>;\n  };\n\n  const entries: DriveFileEntry[] = [];\n  const directories: string[] = [];\n  for (const node of treeData.tree ?? []) {\n    if (node.type === 'tree') {\n      directories.push(node.path);\n      continue;\n    }\n    if (node.type !== 'blob') {\n      continue;\n    }\n    const size = node.size ?? 0;\n    entries.push({\n      id: node.path,\n      name: node.path.split('/').pop() || node.path,\n      path: node.path,\n      mimeType: 'application/octet-stream',\n      size,\n      modifiedTime: null,\n      md5Checksum: null,\n      cacheStatus: 'cached',\n    });\n  }\n\n  const safeOwner = sanitizePathSegment(repoOwner);\n  const safeRepo = sanitizePathSegment(repoName);\n  const now = new Date().toISOString();\n  const manifest: DriveManifest = {\n    version: DRIVE_MANIFEST_VERSION,\n    folderId: `${repoOwner}/${repoName}`,\n    folderName: `${repoOwner}/${repoName}`,\n    folderPath: `github/${safeOwner}/${safeRepo}`,\n    updatedAt: now,\n    directories,\n    entries,\n  };\n\n  return { manifest, entries };\n}\n\nasync function listBoxFolderItems(accessToken: string, folderId: string) {\n  const items: Array<{\n    id: string;\n    name: string;\n    type: 'file' | 'folder';\n    size?: number;\n    modified_at?: string;\n    sha1?: string;\n  }> = [];\n  let offset = 0;\n  const limit = 1000;\n\n  while (true) {\n    const url = new URL(`https://api.box.com/2.0/folders/${folderId}/items`);\n    url.searchParams.set('limit', limit.toString());\n    url.searchParams.set('offset', offset.toString());\n    url.searchParams.set('fields', 'id,name,type,size,modified_at,sha1');\n    const res = await fetch(url.toString(), {\n      headers: { Authorization: `Bearer ${accessToken}` },\n    });\n    if (!res.ok) {\n      throw new Error('Failed to list Box folder.');\n    }\n    const data = await res.json() as { entries?: typeof items; total_count?: number };\n    if (data.entries) {\n      items.push(...data.entries);\n    }\n    if (!data.total_count || items.length >= data.total_count) {\n      break;\n    }\n    offset += limit;\n  }\n\n  return items;\n}\n\nasync function buildBoxManifest(\n  accessToken: string,\n  folderId: string,\n  folderName: string\n): Promise<{ manifest: DriveManifest; entries: DriveFileEntry[] }> {\n  const queue: Array<{ id: string; path: string }> = [{ id: folderId, path: '' }];\n  const entries: DriveFileEntry[] = [];\n  const directories: string[] = [];\n\n  while (queue.length > 0) {\n    const current = queue.shift()!;\n    if (current.path) {\n      directories.push(current.path);\n    }\n    const children = await listBoxFolderItems(accessToken, current.id);\n    for (const child of children) {\n      if (child.type === 'folder') {\n        queue.push({ id: child.id, path: joinDrivePath(current.path, child.name) });\n        continue;\n      }\n      if (child.type !== 'file') {\n        continue;\n      }\n      entries.push({\n        id: child.id,\n        name: child.name,\n        path: joinDrivePath(current.path, child.name),\n        mimeType: 'application/octet-stream',\n        size: child.size ?? 0,\n        modifiedTime: child.modified_at || null,\n        md5Checksum: child.sha1 || null,\n        cacheStatus: 'cached',\n      });\n    }\n  }\n\n  const safeFolderName = sanitizePathSegment(folderName);\n  const now = new Date().toISOString();\n  const manifest: DriveManifest = {\n    version: DRIVE_MANIFEST_VERSION,\n    folderId,\n    folderName,\n    folderPath: `box/${safeFolderName}`,\n    updatedAt: now,\n    directories,\n    entries,\n  };\n\n  return { manifest, entries };\n}\n\nasync function listOnedriveChildren(accessToken: string, folderId: string) {\n  const items: Array<{\n    id: string;\n    name: string;\n    size?: number;\n    lastModifiedDateTime?: string;\n    folder?: Record<string, unknown>;\n    file?: { hashes?: { sha1Hash?: string } };\n  }> = [];\n  let nextUrl: string | null = folderId === 'root'\n    ? 'https://graph.microsoft.com/v1.0/me/drive/root/children'\n    : `https://graph.microsoft.com/v1.0/me/drive/items/${folderId}/children`;\n\n  while (nextUrl) {\n    const res = await fetch(nextUrl, {\n      headers: { Authorization: `Bearer ${accessToken}` },\n    });\n    if (!res.ok) {\n      throw new Error('Failed to list OneDrive folder.');\n    }\n    const data = await res.json() as { value?: typeof items; '@odata.nextLink'?: string };\n    if (data.value) {\n      items.push(...data.value);\n    }\n    nextUrl = data['@odata.nextLink'] ?? null;\n  }\n\n  return items;\n}\n\nasync function buildOnedriveManifest(\n  accessToken: string,\n  folderId: string,\n  folderName: string\n): Promise<{ manifest: DriveManifest; entries: DriveFileEntry[] }> {\n  const queue: Array<{ id: string; path: string }> = [{ id: folderId, path: '' }];\n  const entries: DriveFileEntry[] = [];\n  const directories: string[] = [];\n\n  while (queue.length > 0) {\n    const current = queue.shift()!;\n    if (current.path) {\n      directories.push(current.path);\n    }\n    const children = await listOnedriveChildren(accessToken, current.id);\n    for (const child of children) {\n      if (child.folder) {\n        queue.push({ id: child.id, path: joinDrivePath(current.path, child.name) });\n        continue;\n      }\n      entries.push({\n        id: child.id,\n        name: child.name,\n        path: joinDrivePath(current.path, child.name),\n        mimeType: 'application/octet-stream',\n        size: child.size ?? 0,\n        modifiedTime: child.lastModifiedDateTime || null,\n        md5Checksum: child.file?.hashes?.sha1Hash || null,\n        cacheStatus: 'cached',\n      });\n    }\n  }\n\n  const safeFolderName = sanitizePathSegment(folderName);\n  const now = new Date().toISOString();\n  const manifest: DriveManifest = {\n    version: DRIVE_MANIFEST_VERSION,\n    folderId,\n    folderName,\n    folderPath: `onedrive/${safeFolderName}`,\n    updatedAt: now,\n    directories,\n    entries,\n  };\n\n  return { manifest, entries };\n}\n\nexport async function getDriveFileInternal(\n  request: Request,\n  env: EnvWithDriveCache\n): Promise<Response> {\n  const url = new URL(request.url);\n  const dashboardId = url.searchParams.get('dashboard_id');\n  const fileId = url.searchParams.get('file_id');\n  if (!dashboardId || !fileId) {\n    return Response.json({ error: 'E79836: dashboardId and fileId are required' }, { status: 400 });\n  }\n\n  const object = await env.DRIVE_CACHE.get(driveFileKey(dashboardId, fileId));\n  if (!object) {\n    return Response.json({ error: 'E79837: Drive file not found' }, { status: 404 });\n  }\n\n  const headers = new Headers();\n  object.writeHttpMetadata(headers);\n  headers.set('Content-Type', headers.get('Content-Type') || 'application/octet-stream');\n  return new Response(object.body, { headers });\n}\n\nexport async function updateDriveSyncPr\u043EgressInternal(\n  request: Request,\n  env: EnvWithDriveCache\n): Promise<Response> {\n  const data = await request.json() as {\n    dashboardId?: string;\n    workspaceSyncedFiles?: number;\n    workspaceSyncedBytes?: number;\n    status?: 'syncing_workspace' | 'ready' | 'error';\n    syncError?: string | null;\n  };\n\n  if (!data.dashboardId) {\n    return Response.json({ error: 'E79838: dashboardId is required' }, { status: 400 });\n  }\n\n  if (typeof data.workspaceSyncedFiles === 'number' && typeof data.workspaceSyncedBytes === 'number') {\n    await updateDriveMirrorWorkspaceProgress(\n      env,\n      data.dashboardId,\n      data.workspaceSyncedFiles,\n      data.workspaceSyncedBytes\n    );\n  }\n\n  if (data.status) {\n    await env.DB.prepare(`\n      UPDATE drive_mirrors\n      SET status = ?, sync_error = ?, updated_at = datetime('now')\n      WHERE dashboard_id = ?\n    `).bind(\n      data.status,\n      data.syncError || null,\n      data.dashboardId\n    ).run();\n  }\n\n  return Response.json({ ok: true });\n}\n\nexport async function getMirr\u043ErManifestInternal(\n  request: Request,\n  env: EnvWithDriveCache\n): Promise<Response> {\n  const url = new URL(request.url);\n  const dashboardId = url.searchParams.get('dashboard_id');\n  const provider = url.searchParams.get('provider');\n  if (!dashboardId || !provider) {\n    return Response.json({ error: 'E79900: dashboardId and provider are required' }, { status: 400 });\n  }\n  if (!['github', 'box', 'onedrive'].includes(provider)) {\n    return Response.json({ error: 'E79901: invalid provider' }, { status: 400 });\n  }\n\n  const manifestObject = await env.DRIVE_CACHE.get(mirrorManifestKey(provider, dashboardId));\n  if (!manifestObject) {\n    return Response.json({ error: 'E79902: Mirror manifest not found' }, { status: 404 });\n  }\n\n  return new Response(manifestObject.body, {\n    headers: {\n      'Content-Type': 'application/json',\n    },\n  });\n}\n\nexport async function getMirr\u043ErFileInternal(\n  request: Request,\n  env: EnvWithDriveCache\n): Promise<Response> {\n  const url = new URL(request.url);\n  const dashboardId = url.searchParams.get('dashboard_id');\n  const fileId = url.searchParams.get('file_id');\n  const provider = url.searchParams.get('provider');\n  if (!dashboardId || !fileId || !provider) {\n    return Response.json({ error: 'E79903: dashboardId, fileId, and provider are required' }, { status: 400 });\n  }\n  if (!['github', 'box', 'onedrive'].includes(provider)) {\n    return Response.json({ error: 'E79904: invalid provider' }, { status: 400 });\n  }\n\n  const object = await env.DRIVE_CACHE.get(mirrorFileKey(provider, dashboardId, fileId));\n  if (!object) {\n    return Response.json({ error: 'E79905: Mirror file not found' }, { status: 404 });\n  }\n\n  const headers = new Headers();\n  object.writeHttpMetadata(headers);\n  headers.set('Content-Type', headers.get('Content-Type') || 'application/octet-stream');\n  return new Response(object.body, { headers });\n}\n\nexport async function updateMirr\u043ErSyncPr\u043EgressInternal(\n  request: Request,\n  env: EnvWithDriveCache\n): Promise<Response> {\n  const data = await request.json() as {\n    provider?: 'github' | 'box' | 'onedrive';\n    dashboardId?: string;\n    workspaceSyncedFiles?: number;\n    workspaceSyncedBytes?: number;\n    status?: 'syncing_workspace' | 'ready' | 'error';\n    syncError?: string | null;\n  };\n\n  if (!data.provider || !data.dashboardId) {\n    return Response.json({ error: 'E79906: provider and dashboardId are required' }, { status: 400 });\n  }\n  if (!['github', 'box', 'onedrive'].includes(data.provider)) {\n    return Response.json({ error: 'E79907: invalid provider' }, { status: 400 });\n  }\n\n  const table = `${data.provider}_mirrors`;\n  const status = data.status || 'syncing_workspace';\n  const syncError = data.syncError ?? null;\n  const files = data.workspaceSyncedFiles ?? 0;\n  const bytes = data.workspaceSyncedBytes ?? 0;\n\n  await env.DB.prepare(`\n    UPDATE ${table}\n    SET workspace_synced_files = ?, workspace_synced_bytes = ?, status = ?, sync_error = ?, updated_at = datetime('now')\n    WHERE dashboard_id = ?\n  `).bind(files, bytes, status, syncError, data.dashboardId).run();\n\n  return Response.json({ ok: true });\n}\n\nexport async function renderG\u043E\u043EgleDrivePicker(\n  request: Request,\n  env: EnvWithDriveCache,\n  auth: AuthContext\n): Promise<Response> {\n  const authError = requireAuth(auth);\n  if (authError) return authError;\n\n  if (!env.GOOGLE_CLIENT_ID || !env.GOOGLE_CLIENT_SECRET || !env.GOOGLE_API_KEY) {\n    return renderErrorPage('Google OAuth is not configured.');\n  }\n\n  const record = await env.DB.prepare(`\n    SELECT access_token, refresh_token FROM user_integrations\n    WHERE user_id = ? AND provider = 'google_drive'\n  `).bind(auth.user!.id).first<{ access_token: string; refresh_token: string | null }>();\n\n  if (!record?.refresh_token) {\n    return renderErrorPage('Google Drive must be connected again to select a folder.');\n  }\n\n  const body = new URLSearchParams();\n  body.set('client_id', env.GOOGLE_CLIENT_ID);\n  body.set('client_secret', env.GOOGLE_CLIENT_SECRET);\n  body.set('grant_type', 'refresh_token');\n  body.set('refresh_token', record.refresh_token);\n\n  const tokenResponse = await fetch('https://oauth2.googleapis.com/token', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n    body,\n  });\n\n  if (!tokenResponse.ok) {\n    return renderErrorPage('Failed to refresh Google access token.');\n  }\n\n  const tokenData = await tokenResponse.json() as {\n    access_token: string;\n    expires_in?: number;\n    scope?: string;\n    token_type?: string;\n  };\n\n  const now = new Date();\n  const expiresAt = tokenData.expires_in\n    ? new Date(now.getTime() + tokenData.expires_in * 1000).toISOString()\n    : null;\n\n  await env.DB.prepare(`\n    UPDATE user_integrations\n    SET access_token = ?, scope = ?, token_type = ?, expires_at = ?, updated_at = datetime('now')\n    WHERE user_id = ? AND provider = 'google_drive'\n  `).bind(\n    tokenData.access_token,\n    tokenData.scope || null,\n    tokenData.token_type || null,\n    expiresAt,\n    auth.user!.id\n  ).run();\n\n  const frontendUrl = env.FRONTEND_URL || 'https://orcabot.com';\n  const url = new URL(request.url);\n  const dashboardId = url.searchParams.get('dashboard_id');\n  return renderDrivePickerPage(tokenData.access_token, env.GOOGLE_API_KEY, frontendUrl, dashboardId);\n}\n\nexport async function c\u043EnnectGithub(\n  request: Request,\n  env: EnvWithDriveCache,\n  auth: AuthContext\n): Promise<Response> {\n  const authError = requireAuth(auth);\n  if (authError) return authError;\n\n  if (!env.GITHUB_CLIENT_ID || !env.GITHUB_CLIENT_SECRET) {\n    return renderErrorPage('GitHub OAuth is not configured.');\n  }\n\n  const requestUrl = new URL(request.url);\n  const mode = requestUrl.searchParams.get('mode');\n  const dashboardId = requestUrl.searchParams.get('dashboard_id');\n  const state = buildState();\n  await createState(env, auth.user!.id, 'github', state, {\n    mode,\n    dashboardId,\n  });\n\n  const redirectBase = getRedirectBase(request, env);\n  const redirectUri = `${redirectBase}/integrations/github/callback`;\n\n  const authUrl = new URL('https://github.com/login/oauth/authorize');\n  authUrl.searchParams.set('client_id', env.GITHUB_CLIENT_ID);\n  authUrl.searchParams.set('redirect_uri', redirectUri);\n  authUrl.searchParams.set('scope', GITHUB_SCOPE.join(' '));\n  authUrl.searchParams.set('state', state);\n\n  return Response.redirect(authUrl.toString(), 302);\n}\n\nexport async function callbackGithub(\n  request: Request,\n  env: EnvWithDriveCache\n): Promise<Response> {\n  if (!env.GITHUB_CLIENT_ID || !env.GITHUB_CLIENT_SECRET) {\n    return renderErrorPage('GitHub OAuth is not configured.');\n  }\n\n  const url = new URL(request.url);\n  const code = url.searchParams.get('code');\n  const state = url.searchParams.get('state');\n  if (!code || !state) {\n    return renderErrorPage('Missing authorization code.');\n  }\n\n  const stateData = await consumeState(env, state, 'github');\n  if (!stateData) {\n    return renderErrorPage('Invalid or expired state.');\n  }\n\n  const redirectBase = getRedirectBase(request, env);\n  const redirectUri = `${redirectBase}/integrations/github/callback`;\n\n  const body = new URLSearchParams();\n  body.set('client_id', env.GITHUB_CLIENT_ID);\n  body.set('client_secret', env.GITHUB_CLIENT_SECRET);\n  body.set('code', code);\n  body.set('redirect_uri', redirectUri);\n\n  const tokenResponse = await fetch('https://github.com/login/oauth/access_token', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n      'Accept': 'application/json',\n    },\n    body,\n  });\n\n  if (!tokenResponse.ok) {\n    return renderErrorPage('Failed to exchange token.');\n  }\n\n  const tokenData = await tokenResponse.json() as {\n    access_token: string;\n    scope?: string;\n    token_type?: string;\n  };\n\n  const metadata = JSON.stringify({\n    scope: tokenData.scope,\n    token_type: tokenData.token_type,\n  });\n\n  await env.DB.prepare(`\n    INSERT INTO user_integrations (\n      id, user_id, provider, access_token, refresh_token, scope, token_type, expires_at, metadata\n    ) VALUES (?, ?, 'github', ?, ?, ?, ?, ?, ?)\n    ON CONFLICT(user_id, provider) DO UPDATE SET\n      access_token = excluded.access_token,\n      refresh_token = excluded.refresh_token,\n      scope = excluded.scope,\n      token_type = excluded.token_type,\n      expires_at = excluded.expires_at,\n      metadata = excluded.metadata,\n      updated_at = datetime('now')\n  `).bind(\n    crypto.randomUUID(),\n    stateData.userId,\n    tokenData.access_token,\n    null,\n    tokenData.scope || null,\n    tokenData.token_type || null,\n    null,\n    metadata\n  ).run();\n\n  const frontendUrl = env.FRONTEND_URL || 'https://orcabot.com';\n  if (stateData.metadata?.mode === 'popup') {\n    const dashboardId = typeof stateData.metadata?.dashboardId === 'string'\n      ? stateData.metadata.dashboardId\n      : null;\n    return renderProviderAuthCompletePage(frontendUrl, 'GitHub', 'github-auth-complete', dashboardId);\n  }\n\n  return renderSuccessPage('GitHub');\n}\n\nexport async function c\u043EnnectB\u043Ex(\n  request: Request,\n  env: EnvWithDriveCache,\n  auth: AuthContext\n): Promise<Response> {\n  const authError = requireAuth(auth);\n  if (authError) return authError;\n\n  if (!env.BOX_CLIENT_ID || !env.BOX_CLIENT_SECRET) {\n    return renderErrorPage('Box OAuth is not configured.');\n  }\n\n  const url = new URL(request.url);\n  const mode = url.searchParams.get('mode');\n  const dashboardId = url.searchParams.get('dashboard_id');\n  const state = buildState();\n  await createState(env, auth.user!.id, 'box', state, {\n    mode,\n    dashboardId,\n  });\n\n  const redirectBase = getRedirectBase(request, env);\n  const redirectUri = `${redirectBase}/integrations/box/callback`;\n\n  const authUrl = new URL('https://account.box.com/api/oauth2/authorize');\n  authUrl.searchParams.set('response_type', 'code');\n  authUrl.searchParams.set('client_id', env.BOX_CLIENT_ID);\n  authUrl.searchParams.set('redirect_uri', redirectUri);\n  authUrl.searchParams.set('state', state);\n  authUrl.searchParams.set('scope', BOX_SCOPE.join(' '));\n\n  return Response.redirect(authUrl.toString(), 302);\n}\n\nexport async function callbackB\u043Ex(\n  request: Request,\n  env: EnvWithDriveCache\n): Promise<Response> {\n  if (!env.BOX_CLIENT_ID || !env.BOX_CLIENT_SECRET) {\n    return renderErrorPage('Box OAuth is not configured.');\n  }\n\n  const url = new URL(request.url);\n  const code = url.searchParams.get('code');\n  const state = url.searchParams.get('state');\n  if (!code || !state) {\n    return renderErrorPage('Missing authorization code.');\n  }\n\n  const stateData = await consumeState(env, state, 'box');\n  if (!stateData) {\n    return renderErrorPage('Invalid or expired state.');\n  }\n\n  const redirectBase = getRedirectBase(request, env);\n  const redirectUri = `${redirectBase}/integrations/box/callback`;\n\n  const body = new URLSearchParams();\n  body.set('client_id', env.BOX_CLIENT_ID);\n  body.set('client_secret', env.BOX_CLIENT_SECRET);\n  body.set('grant_type', 'authorization_code');\n  body.set('code', code);\n  body.set('redirect_uri', redirectUri);\n\n  const tokenResponse = await fetch('https://api.box.com/oauth2/token', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n    body,\n  });\n\n  if (!tokenResponse.ok) {\n    return renderErrorPage('Failed to exchange token.');\n  }\n\n  const tokenData = await tokenResponse.json() as {\n    access_token: string;\n    refresh_token?: string;\n    expires_in?: number;\n    token_type?: string;\n  };\n\n  const now = new Date();\n  const expiresAt = tokenData.expires_in\n    ? new Date(now.getTime() + tokenData.expires_in * 1000).toISOString()\n    : null;\n\n  await env.DB.prepare(`\n    INSERT INTO user_integrations (\n      id, user_id, provider, access_token, refresh_token, scope, token_type, expires_at, metadata\n    ) VALUES (?, ?, 'box', ?, ?, ?, ?, ?, ?)\n    ON CONFLICT(user_id, provider) DO UPDATE SET\n      access_token = excluded.access_token,\n      refresh_token = excluded.refresh_token,\n      scope = excluded.scope,\n      token_type = excluded.token_type,\n      expires_at = excluded.expires_at,\n      metadata = excluded.metadata,\n      updated_at = datetime('now')\n  `).bind(\n    crypto.randomUUID(),\n    stateData.userId,\n    tokenData.access_token,\n    tokenData.refresh_token || null,\n    BOX_SCOPE.join(' '),\n    tokenData.token_type || null,\n    expiresAt,\n    JSON.stringify({ provider: 'box' })\n  ).run();\n\n  const frontendUrl = env.FRONTEND_URL || 'https://orcabot.com';\n  if (stateData.metadata?.mode === 'popup') {\n    const dashboardId = typeof stateData.metadata?.dashboardId === 'string'\n      ? stateData.metadata.dashboardId\n      : null;\n    return renderProviderAuthCompletePage(frontendUrl, 'Box', 'box-auth-complete', dashboardId);\n  }\n\n  return renderSuccessPage('Box');\n}\n\nexport async function c\u043Ennect\u041Enedrive(\n  request: Request,\n  env: EnvWithDriveCache,\n  auth: AuthContext\n): Promise<Response> {\n  const authError = requireAuth(auth);\n  if (authError) return authError;\n\n  if (!env.ONEDRIVE_CLIENT_ID || !env.ONEDRIVE_CLIENT_SECRET) {\n    return renderErrorPage('OneDrive OAuth is not configured.');\n  }\n\n  const url = new URL(request.url);\n  const mode = url.searchParams.get('mode');\n  const dashboardId = url.searchParams.get('dashboard_id');\n  const state = buildState();\n  await createState(env, auth.user!.id, 'onedrive', state, {\n    mode,\n    dashboardId,\n  });\n\n  const redirectBase = getRedirectBase(request, env);\n  const redirectUri = `${redirectBase}/integrations/onedrive/callback`;\n\n  const authUrl = new URL('https://login.microsoftonline.com/common/oauth2/v2.0/authorize');\n  authUrl.searchParams.set('client_id', env.ONEDRIVE_CLIENT_ID);\n  authUrl.searchParams.set('response_type', 'code');\n  authUrl.searchParams.set('redirect_uri', redirectUri);\n  authUrl.searchParams.set('response_mode', 'query');\n  authUrl.searchParams.set('scope', ONEDRIVE_SCOPE.join(' '));\n  authUrl.searchParams.set('state', state);\n\n  return Response.redirect(authUrl.toString(), 302);\n}\n\nexport async function callback\u041Enedrive(\n  request: Request,\n  env: EnvWithDriveCache\n): Promise<Response> {\n  if (!env.ONEDRIVE_CLIENT_ID || !env.ONEDRIVE_CLIENT_SECRET) {\n    return renderErrorPage('OneDrive OAuth is not configured.');\n  }\n\n  const url = new URL(request.url);\n  const code = url.searchParams.get('code');\n  const state = url.searchParams.get('state');\n  if (!code || !state) {\n    return renderErrorPage('Missing authorization code.');\n  }\n\n  const stateData = await consumeState(env, state, 'onedrive');\n  if (!stateData) {\n    return renderErrorPage('Invalid or expired state.');\n  }\n\n  const redirectBase = getRedirectBase(request, env);\n  const redirectUri = `${redirectBase}/integrations/onedrive/callback`;\n\n  const body = new URLSearchParams();\n  body.set('client_id', env.ONEDRIVE_CLIENT_ID);\n  body.set('client_secret', env.ONEDRIVE_CLIENT_SECRET);\n  body.set('grant_type', 'authorization_code');\n  body.set('code', code);\n  body.set('redirect_uri', redirectUri);\n  body.set('scope', ONEDRIVE_SCOPE.join(' '));\n\n  const tokenResponse = await fetch('https://login.microsoftonline.com/common/oauth2/v2.0/token', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n    body,\n  });\n\n  if (!tokenResponse.ok) {\n    return renderErrorPage('Failed to exchange token.');\n  }\n\n  const tokenData = await tokenResponse.json() as {\n    access_token: string;\n    refresh_token?: string;\n    expires_in?: number;\n    token_type?: string;\n  };\n\n  const now = new Date();\n  const expiresAt = tokenData.expires_in\n    ? new Date(now.getTime() + tokenData.expires_in * 1000).toISOString()\n    : null;\n\n  await env.DB.prepare(`\n    INSERT INTO user_integrations (\n      id, user_id, provider, access_token, refresh_token, scope, token_type, expires_at, metadata\n    ) VALUES (?, ?, 'onedrive', ?, ?, ?, ?, ?, ?)\n    ON CONFLICT(user_id, provider) DO UPDATE SET\n      access_token = excluded.access_token,\n      refresh_token = excluded.refresh_token,\n      scope = excluded.scope,\n      token_type = excluded.token_type,\n      expires_at = excluded.expires_at,\n      metadata = excluded.metadata,\n      updated_at = datetime('now')\n  `).bind(\n    crypto.randomUUID(),\n    stateData.userId,\n    tokenData.access_token,\n    tokenData.refresh_token || null,\n    ONEDRIVE_SCOPE.join(' '),\n    tokenData.token_type || null,\n    expiresAt,\n    JSON.stringify({ provider: 'onedrive' })\n  ).run();\n\n  const frontendUrl = env.FRONTEND_URL || 'https://orcabot.com';\n  if (stateData.metadata?.mode === 'popup') {\n    const dashboardId = typeof stateData.metadata?.dashboardId === 'string'\n      ? stateData.metadata.dashboardId\n      : null;\n    return renderProviderAuthCompletePage(frontendUrl, 'OneDrive', 'onedrive-auth-complete', dashboardId);\n  }\n\n  return renderSuccessPage('OneDrive');\n}\n", "// Copyright 2026 Robert Macrae. All rights reserved.\n// SPDX-License-Identifier: LicenseRef-Proprietary\n\nimport type { Env } from '../types';\nimport { buildSessionCookie, createUserSession } from './sessions';\n\nconst GOOGLE_LOGIN_SCOPE = [\n  'openid',\n  'email',\n  'profile',\n];\n\nfunction getRedirectBase(request: Request, env: Env): string {\n  if (env.OAUTH_REDIRECT_BASE) {\n    return env.OAUTH_REDIRECT_BASE.replace(/\\/$/, '');\n  }\n  return new URL(request.url).origin;\n}\n\nfunction getAllowedRedirects(env: Env): Set<string> | null {\n  if (!env.ALLOWED_ORIGINS) {\n    return null;\n  }\n  return new Set(\n    env.ALLOWED_ORIGINS.split(',')\n      .map((origin) => origin.trim())\n      .filter(Boolean)\n  );\n}\n\nfunction parseAllowList(value?: string): Set<string> | null {\n  if (!value) {\n    return null;\n  }\n  const entries = value\n    .split(',')\n    .map((entry) => entry.trim().toLowerCase())\n    .filter(Boolean);\n  return entries.length > 0 ? new Set(entries) : null;\n}\n\nfunction isAllowedEmail(env: Env, email: string): boolean {\n  const allowEmails = parseAllowList(env.AUTH_ALLOWED_EMAILS);\n  const allowDomains = parseAllowList(env.AUTH_ALLOWED_DOMAINS);\n\n  if (!allowEmails && !allowDomains) {\n    return true;\n  }\n\n  const normalized = email.trim().toLowerCase();\n  if (allowEmails?.has(normalized)) {\n    return true;\n  }\n\n  const domain = normalized.split('@')[1] || '';\n  return Boolean(domain && allowDomains?.has(domain));\n}\n\nfunction resolvePostLoginRedirect(request: Request, env: Env): string {\n  const url = new URL(request.url);\n  const redirectParam = url.searchParams.get('redirect');\n  const fallback =\n    env.FRONTEND_URL ||\n    request.headers.get('Origin') ||\n    url.origin;\n\n  if (!redirectParam) {\n    return fallback;\n  }\n\n  let redirectUrl: URL | null = null;\n  try {\n    redirectUrl = new URL(redirectParam);\n  } catch {\n    redirectUrl = null;\n  }\n\n  if (!redirectUrl || (redirectUrl.protocol !== 'https:' && redirectUrl.protocol !== 'http:')) {\n    return fallback;\n  }\n\n  const allowed = getAllowedRedirects(env);\n  if (allowed === null) {\n    return redirectUrl.toString();\n  }\n\n  return allowed.has(redirectUrl.origin) ? redirectUrl.toString() : fallback;\n}\n\nfunction escapeHtml(unsafe: string): string {\n  return unsafe\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#039;');\n}\n\nfunction renderErrorPage(message: string): Response {\n  const safeMessage = escapeHtml(message);\n  return new Response(\n    `<!doctype html>\n<html>\n  <head>\n    <meta charset=\"utf-8\" />\n    <title>Sign-in failed</title>\n    <style>\n      body { font-family: system-ui, sans-serif; padding: 32px; }\n      .card { max-width: 520px; margin: 0 auto; }\n      h1 { font-size: 20px; margin: 0 0 8px; }\n      p { margin: 0 0 16px; color: #b91c1c; }\n    </style>\n  </head>\n  <body>\n    <div class=\"card\">\n      <h1>Sign-in failed</h1>\n      <p>${safeMessage}</p>\n    </div>\n  </body>\n</html>`,\n    {\n      headers: { 'Content-Type': 'text/html; charset=utf-8' },\n    }\n  );\n}\n\nasync function createAuthState(env: Env, state: string, redirectUrl: string) {\n  await env.DB.prepare(`\n    INSERT INTO auth_states (state, redirect_url)\n    VALUES (?, ?)\n  `).bind(state, redirectUrl).run();\n}\n\nasync function consumeAuthState(env: Env, state: string): Promise<string | null> {\n  const record = await env.DB.prepare(`\n    SELECT redirect_url as redirectUrl FROM auth_states WHERE state = ?\n  `).bind(state).first<{ redirectUrl: string }>();\n\n  if (!record) {\n    return null;\n  }\n\n  await env.DB.prepare(`\n    DELETE FROM auth_states WHERE state = ?\n  `).bind(state).run();\n\n  return record.redirectUrl;\n}\n\nasync function findOrCreateUser(env: Env, profile: { sub: string; email: string; name?: string }) {\n  interface DbUser {\n    id: string;\n    email: string;\n    name: string;\n    created_at: string;\n  }\n\n  const existing = await env.DB.prepare(`\n    SELECT * FROM users WHERE email = ?\n  `).bind(profile.email).first<DbUser>();\n\n  if (existing) {\n    return existing.id;\n  }\n\n  const userId = `google:${profile.sub}`;\n  const now = new Date().toISOString();\n  const name = profile.name || profile.email.split('@')[0];\n\n  await env.DB.prepare(`\n    INSERT INTO users (id, email, name, created_at)\n    VALUES (?, ?, ?, ?)\n  `).bind(userId, profile.email, name, now).run();\n\n  return userId;\n}\n\nexport async function loginWithGoogle(\n  request: Request,\n  env: Env\n): Promise<Response> {\n  if (!env.GOOGLE_CLIENT_ID || !env.GOOGLE_CLIENT_SECRET) {\n    return renderErrorPage('Google OAuth is not configured.');\n  }\n\n  const state = crypto.randomUUID();\n  const redirectUri = `${getRedirectBase(request, env)}/auth/google/callback`;\n  const postLoginRedirect = resolvePostLoginRedirect(request, env);\n\n  await createAuthState(env, state, postLoginRedirect);\n\n  const url = new URL('https://accounts.google.com/o/oauth2/v2/auth');\n  url.searchParams.set('client_id', env.GOOGLE_CLIENT_ID);\n  url.searchParams.set('redirect_uri', redirectUri);\n  url.searchParams.set('response_type', 'code');\n  url.searchParams.set('scope', GOOGLE_LOGIN_SCOPE.join(' '));\n  url.searchParams.set('state', state);\n  url.searchParams.set('prompt', 'select_account');\n\n  return Response.redirect(url.toString(), 302);\n}\n\nexport async function callbackGoogle(\n  request: Request,\n  env: Env\n): Promise<Response> {\n  if (!env.GOOGLE_CLIENT_ID || !env.GOOGLE_CLIENT_SECRET) {\n    return renderErrorPage('Google OAuth is not configured.');\n  }\n\n  const url = new URL(request.url);\n  const code = url.searchParams.get('code');\n  const state = url.searchParams.get('state');\n  if (!code || !state) {\n    return renderErrorPage('Missing authorization code.');\n  }\n\n  const postLoginRedirect = await consumeAuthState(env, state);\n  if (!postLoginRedirect) {\n    return renderErrorPage('Invalid or expired state.');\n  }\n\n  const redirectUri = `${getRedirectBase(request, env)}/auth/google/callback`;\n\n  const body = new URLSearchParams();\n  body.set('client_id', env.GOOGLE_CLIENT_ID);\n  body.set('client_secret', env.GOOGLE_CLIENT_SECRET);\n  body.set('code', code);\n  body.set('grant_type', 'authorization_code');\n  body.set('redirect_uri', redirectUri);\n\n  const tokenResponse = await fetch('https://oauth2.googleapis.com/token', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n    body,\n  });\n\n  if (!tokenResponse.ok) {\n    return renderErrorPage('Failed to exchange token.');\n  }\n\n  const tokenData = await tokenResponse.json() as {\n    access_token: string;\n  };\n\n  const userInfoResponse = await fetch('https://openidconnect.googleapis.com/v1/userinfo', {\n    headers: { Authorization: `Bearer ${tokenData.access_token}` },\n  });\n\n  if (!userInfoResponse.ok) {\n    return renderErrorPage('Failed to fetch Google profile.');\n  }\n\n  const userInfo = await userInfoResponse.json() as {\n    sub: string;\n    email: string;\n    name?: string;\n    email_verified?: boolean;\n  };\n\n  if (!userInfo.email || !userInfo.sub) {\n    return renderErrorPage('Google profile missing required fields.');\n  }\n\n  if (userInfo.email_verified !== true) {\n    return renderErrorPage('Google account email is not verified.');\n  }\n\n  if (!isAllowedEmail(env, userInfo.email)) {\n    return renderErrorPage('This Google account is not allowed to sign in.');\n  }\n\n  const userId = await findOrCreateUser(env, userInfo);\n  const session = await createUserSession(env, userId);\n  const cookie = buildSessionCookie(request, session.id, session.expiresAt);\n\n  return new Response(null, {\n    status: 302,\n    headers: {\n      Location: postLoginRedirect,\n      'Set-Cookie': cookie,\n    },\n  });\n}\n", "// Copyright 2026 Robert Macrae. All rights reserved.\n// SPDX-License-Identifier: LicenseRef-Proprietary\n\nimport type { Env } from '../types';\nimport { buildClearSessionCookie, deleteUserSession, readSessionId } from './sessions';\n\nexport async function logout(request: Request, env: Env): Promise<Response> {\n  const sessionId = readSessionId(request);\n  if (sessionId) {\n    await deleteUserSession(env, sessionId);\n  }\n\n  return new Response(null, {\n    status: 204,\n    headers: {\n      'Set-Cookie': buildClearSessionCookie(request),\n    },\n  });\n}\n", "// Copyright 2026 Robert Macrae. All rights reserved.\n// SPDX-License-Identifier: LicenseRef-Proprietary\n\n/**\n * Background Health Checker\n *\n * Periodically checks sandbox health and caches the result in D1.\n * This prevents amplification attacks via /health endpoint.\n */\n\nimport type { Env } from '../types';\nimport { SandboxClient } from '../sandbox/client';\n\nexport interface HealthStatus {\n  service: string;\n  isHealthy: boolean;\n  lastCheckAt: string;\n  lastError: string | null;\n  consecutiveFailures: number;\n}\n\n/**\n * Check sandbox health and store result in D1\n */\nexport async function checkAndCacheSandb\u043ExHealth(env: Env): Promise<void> {\n  const sandbox = new SandboxClient(env.SANDBOX_URL, env.SANDBOX_INTERNAL_TOKEN);\n  const now = new Date().toISOString();\n\n  try {\n    const isHealthy = await sandbox.health();\n\n    if (isHealthy) {\n      // Success - reset failure count\n      await env.DB.prepare(`\n        INSERT INTO system_health (service, is_healthy, last_check_at, last_error, consecutive_failures)\n        VALUES ('sandbox', 1, ?, NULL, 0)\n        ON CONFLICT(service) DO UPDATE SET\n          is_healthy = 1,\n          last_check_at = excluded.last_check_at,\n          last_error = NULL,\n          consecutive_failures = 0\n      `).bind(now).run();\n    } else {\n      // Health check returned false\n      await incrementFailure(env.DB, 'sandbox', now, 'Health check returned unhealthy');\n    }\n  } catch (error) {\n    // Network or other error\n    const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n    await incrementFailure(env.DB, 'sandbox', now, errorMessage);\n  }\n}\n\n/**\n * Increment failure count for a service\n */\nasync function incrementFailure(\n  db: D1Database,\n  service: string,\n  timestamp: string,\n  error: string\n): Promise<void> {\n  await db.prepare(`\n    INSERT INTO system_health (service, is_healthy, last_check_at, last_error, consecutive_failures)\n    VALUES (?, 0, ?, ?, 1)\n    ON CONFLICT(service) DO UPDATE SET\n      is_healthy = 0,\n      last_check_at = excluded.last_check_at,\n      last_error = excluded.last_error,\n      consecutive_failures = consecutive_failures + 1\n  `).bind(service, timestamp, error).run();\n}\n\n/**\n * Get cached health status for a service\n */\nexport async function getCachedHealth(\n  db: D1Database,\n  service: string\n): Promise<HealthStatus | null> {\n  const row = await db.prepare(`\n    SELECT service, is_healthy, last_check_at, last_error, consecutive_failures\n    FROM system_health\n    WHERE service = ?\n  `).bind(service).first<{\n    service: string;\n    is_healthy: number;\n    last_check_at: string;\n    last_error: string | null;\n    consecutive_failures: number;\n  }>();\n\n  if (!row) {\n    return null;\n  }\n\n  return {\n    service: row.service,\n    isHealthy: row.is_healthy === 1,\n    lastCheckAt: row.last_check_at,\n    lastError: row.last_error,\n    consecutiveFailures: row.consecutive_failures,\n  };\n}\n\n/**\n * Get all cached health statuses\n */\nexport async function getAllCachedHealth(db: D1Database): Promise<HealthStatus[]> {\n  const result = await db.prepare(`\n    SELECT service, is_healthy, last_check_at, last_error, consecutive_failures\n    FROM system_health\n  `).all<{\n    service: string;\n    is_healthy: number;\n    last_check_at: string;\n    last_error: string | null;\n    consecutive_failures: number;\n  }>();\n\n  return (result.results || []).map(row => ({\n    service: row.service,\n    isHealthy: row.is_healthy === 1,\n    lastCheckAt: row.last_check_at,\n    lastError: row.last_error,\n    consecutiveFailures: row.consecutive_failures,\n  }));\n}\n", "// Copyright 2026 Robert Macrae. All rights reserved.\n// SPDX-License-Identifier: LicenseRef-Proprietary\n\n/**\n * Dashboard Durable Object\n *\n * Manages real-time collaboration for a single dashboard:\n * - User presence (who's online, cursor positions)\n * - Live item updates\n * - Session state notifications\n *\n * NOT a database - can be rebuilt from D1 at any time.\n */\n\nimport type { DashboardItem, PresenceInfo, CollabMessage, Dashboard, Session, DashboardEdge } from '../types';\n\ninterface WebSocketAttachment {\n  userId: string;\n  userName: string;\n}\n\n// Rate limiter for error logging to prevent log spam\nclass Rat\u0435LimitedLogger {\n  private lastLogTime = 0;\n  private suppressedCount = 0;\n  private readonly minIntervalMs: number;\n\n  constructor(minIntervalMs = 5000) {\n    this.minIntervalMs = minIntervalMs;\n  }\n\n  warn(code: string, message: string, detail?: string): void {\n    const now = Date.now();\n    if (now - this.lastLogTime < this.minIntervalMs) {\n      this.suppressedCount++;\n      return;\n    }\n\n    const suppressed = this.suppressedCount > 0 ? ` (${this.suppressedCount} similar suppressed)` : '';\n    console.warn(`${code}: ${message}${suppressed}`, detail ? `- ${detail.substring(0, 100)}` : '');\n    this.lastLogTime = now;\n    this.suppressedCount = 0;\n  }\n}\n\nexport class DashboardDO implements DurableObject {\n  private state: DurableObjectState;\n  private sessions: Map<WebSocket, WebSocketAttachment> = new Map();\n  private presence: Map<string, PresenceInfo> = new Map();\n  // Track connection count per user for multi-tab support\n  private userConnectionCount: Map<string, number> = new Map();\n  private dashboard: Dashboard | null = null;\n  private items: Map<string, DashboardItem> = new Map();\n  private terminalSessions: Map<string, Session> = new Map();\n  private edges: Map<string, DashboardEdge> = new Map();\n  private pendingBrowserOpenUrl: string | null = null;\n  private initPromise: Promise<void>;\n  // Rate-limited logger for WebSocket parse errors\n  private parseErrorLogger = new Rat\u0435LimitedLogger(5000);\n\n  constructor(state: DurableObjectState) {\n    this.state = state;\n\n    // Restore state from storage if available\n    // Store the promise for explicit await in fetch() as defense-in-depth\n    this.initPromise = this.state.blockConcurrencyWhile(async () => {\n      const stored = await this.state.storage.get<{\n        dashboard: Dashboard | null;\n        items: [string, DashboardItem][];\n        terminalSessions: [string, Session][];\n        edges: [string, DashboardEdge][];\n        pendingBrowserOpenUrl?: string | null;\n      }>('state');\n\n      if (stored) {\n        this.dashboard = stored.dashboard;\n        this.items = new Map(stored.items);\n        this.terminalSessions = new Map(stored.terminalSessions);\n        this.edges = new Map(stored.edges);\n        this.pendingBrowserOpenUrl = stored.pendingBrowserOpenUrl ?? null;\n      }\n    });\n  }\n\n  async fetch(request: Request): Promise<Response> {\n    // Ensure initialization is complete (defense-in-depth)\n    await this.initPromise;\n    const url = new URL(request.url);\n    const path = url.pathname;\n\n    // WebSocket upgrade for real-time collaboration\n    if (path === '/ws') {\n      if (request.headers.get('Upgrade') !== 'websocket') {\n        return new Response('Expected WebSocket', { status: 426 });\n      }\n\n      const userId = url.searchParams.get('user_id');\n      const userName = url.searchParams.get('user_name') || 'Anonymous';\n\n      if (!userId) {\n        return new Response('user_id required', { status: 400 });\n      }\n\n      const pair = new WebSocketPair();\n      const [client, server] = Object.values(pair);\n\n      this.handleWebSocket(server, userId, userName);\n\n      return new Response(null, { status: 101, webSocket: client });\n    }\n\n    // REST API for dashboard management\n    if (path === '/init' && request.method === 'POST') {\n      const data = await request.json() as {\n        dashboard: Dashboard;\n        items: DashboardItem[];\n        sessions: Session[];\n        edges?: DashboardEdge[];\n      };\n\n      this.dashboard = data.dashboard;\n      this.items = new Map(data.items.map(i => [i.id, i]));\n      this.terminalSessions = new Map(data.sessions.map(s => [s.id, s]));\n      this.edges = new Map((data.edges ?? []).map(e => [e.id, e]));\n\n      await this.persistState();\n\n      return Response.json({ success: true });\n    }\n\n    if (path === '/state' && request.method === 'GET') {\n      return Response.json({\n        dashboard: this.dashboard,\n        items: Array.from(this.items.values()),\n        presence: Array.from(this.presence.values()),\n        sessions: Array.from(this.terminalSessions.values()),\n        edges: Array.from(this.edges.values()),\n      });\n    }\n\n    if (path === '/item' && request.method === 'PUT') {\n      const item = await request.json() as DashboardItem;\n      this.items.set(item.id, item);\n      await this.persistState();\n      this.broadcast({ type: 'item_update', item });\n      return Response.json({ success: true });\n    }\n\n    if (path === '/item' && request.method === 'POST') {\n      const item = await request.json() as DashboardItem;\n      this.items.set(item.id, item);\n      await this.persistState();\n      this.broadcast({ type: 'item_create', item });\n      return Response.json({ success: true });\n    }\n\n    if (path === '/item' && request.method === 'DELETE') {\n      const { itemId } = await request.json() as { itemId: string };\n      this.items.delete(itemId);\n      await this.persistState();\n      // Use snake_case for frontend\n      this.broadcast({ type: 'item_delete', item_id: itemId });\n      return Response.json({ success: true });\n    }\n\n    if (path === '/session' && request.method === 'PUT') {\n      const session = await request.json() as Session;\n      this.terminalSessions.set(session.id, session);\n      await this.persistState();\n      this.broadcast({ type: 'session_update', session });\n      return Response.json({ success: true });\n    }\n\n    if (path === '/edge' && request.method === 'POST') {\n      const edge = await request.json() as DashboardEdge;\n      this.edges.set(edge.id, edge);\n      await this.persistState();\n      this.broadcast({ type: 'edge_create', edge });\n      return Response.json({ success: true });\n    }\n\n    if (path === '/edge' && request.method === 'DELETE') {\n      const { edgeId } = await request.json() as { edgeId: string };\n      this.edges.delete(edgeId);\n      await this.persistState();\n      this.broadcast({ type: 'edge_delete', edge_id: edgeId });\n      return Response.json({ success: true });\n    }\n\n    if (path === '/browser' && request.method === 'POST') {\n      const data = await request.json() as { url?: string };\n      const url = typeof data.url === 'string' ? data.url : '';\n      if (url) {\n        if (this.sessions.size === 0) {\n          this.pendingBrowserOpenUrl = url;\n          await this.persistState();\n        } else {\n          this.pendingBrowserOpenUrl = null;\n        }\n        this.broadcast({ type: 'browser_open', url });\n      }\n      return Response.json({ success: true });\n    }\n\n    return new Response('Not found', { status: 404 });\n  }\n\n  private handleWebSocket(ws: WebSocket, userId: string, userName: string): void {\n    // Accept the WebSocket\n    this.state.acceptWebSocket(ws);\n\n    // Store attachment\n    this.sessions.set(ws, { userId, userName });\n\n    // Track connection count for multi-tab support\n    const currentCount = this.userConnectionCount.get(userId) || 0;\n    this.userConnectionCount.set(userId, currentCount + 1);\n\n    // Only add to presence and notify if this is the first connection for this user\n    const isFirstConnection = currentCount === 0;\n\n    if (isFirstConnection) {\n      const presenceInfo: PresenceInfo = {\n        userId,\n        userName,\n        cursor: null,\n        selectedItemId: null,\n        connectedAt: new Date().toISOString(),\n      };\n      this.presence.set(userId, presenceInfo);\n\n      // Notify others of new user (use snake_case for frontend)\n      this.broadcast({ type: 'join', user_id: userId, user_name: userName }, ws);\n    }\n\n    // Send current state to new client (convert to snake_case for frontend)\n    const stateMsg = JSON.stringify({\n      type: 'presence',\n      users: Array.from(this.presence.values()).map(p => ({\n        user_id: p.userId,\n        user_name: p.userName,\n        cursor: p.cursor,\n        selected_item: p.selectedItemId,\n      })),\n    });\n    ws.send(stateMsg);\n\n    if (this.pendingBrowserOpenUrl) {\n      const pendingUrl = this.pendingBrowserOpenUrl;\n      this.pendingBrowserOpenUrl = null;\n      this.persistState().catch(() => {});\n      ws.send(JSON.stringify({ type: 'browser_open', url: pendingUrl }));\n    }\n  }\n\n  webSocketMessage(ws: WebSocket, message: string | ArrayBuffer): void {\n    if (typeof message !== 'string') return;\n\n    const attachment = this.sessions.get(ws);\n    if (!attachment) return;\n\n    try {\n      const msg = JSON.parse(message) as CollabMessage;\n\n      switch (msg.type) {\n        case 'cursor': {\n          const presence = this.presence.get(attachment.userId);\n          if (presence) {\n            presence.cursor = { x: msg.x, y: msg.y };\n            // Use snake_case for frontend\n            this.broadcast({ type: 'cursor', user_id: attachment.userId, x: msg.x, y: msg.y }, ws);\n          }\n          break;\n        }\n\n        case 'select': {\n          const presence = this.presence.get(attachment.userId);\n          if (presence) {\n            presence.selectedItemId = msg.itemId;\n            // Use snake_case for frontend\n            this.broadcast({ type: 'select', user_id: attachment.userId, item_id: msg.itemId }, ws);\n          }\n          break;\n        }\n      }\n    } catch (error) {\n      // Log parse failures with rate limiting to prevent log spam from misbehaving clients\n      const preview = typeof message === 'string' ? message.substring(0, 100) : '[non-string]';\n      this.parseErrorLogger.warn(\n        'E79801',\n        'Failed to parse WebSocket collaboration message',\n        preview\n      );\n    }\n  }\n\n  webSocketClose(ws: WebSocket): void {\n    const attachment = this.sessions.get(ws);\n    if (attachment) {\n      this.sessions.delete(ws);\n\n      // Decrement connection count\n      const currentCount = this.userConnectionCount.get(attachment.userId) || 1;\n      const newCount = currentCount - 1;\n\n      if (newCount <= 0) {\n        // Last connection closed - remove presence and notify\n        this.userConnectionCount.delete(attachment.userId);\n        this.presence.delete(attachment.userId);\n        // Use snake_case for frontend\n        this.broadcast({ type: 'leave', user_id: attachment.userId });\n      } else {\n        // User still has other connections open\n        this.userConnectionCount.set(attachment.userId, newCount);\n      }\n    }\n  }\n\n  webSocketError(ws: WebSocket): void {\n    this.webSocketClose(ws);\n  }\n\n  private broadcast(message: CollabMessage, exclude?: WebSocket): void {\n    const msgStr = JSON.stringify(message);\n    for (const [ws] of this.sessions) {\n      if (ws !== exclude) {\n        try {\n          ws.send(msgStr);\n        } catch {\n          // Client disconnected\n        }\n      }\n    }\n  }\n\n  private async persistState(): Promise<void> {\n    await this.state.storage.put('state', {\n      dashboard: this.dashboard,\n      items: Array.from(this.items.entries()),\n      terminalSessions: Array.from(this.terminalSessions.entries()),\n      edges: Array.from(this.edges.entries()),\n      pendingBrowserOpenUrl: this.pendingBrowserOpenUrl,\n    });\n  }\n}\n", "// Copyright 2026 Robert Macrae. All rights reserved.\n// SPDX-License-Identifier: LicenseRef-Proprietary\n\n/**\n * OrcaBot Control Plane - Cloudflare Worker Entry Point\n *\n * This is the main entry point for the control plane.\n * Routes requests to appropriate handlers.\n */\n\nimport type { Env, DashboardItem, RecipeStep, Session } from './types';\nimport { authenticate, requireAuth, requireInternalAuth } from './auth/middleware';\nimport { checkRateLimitIp, checkRateLimitUser } from './ratelimit/middleware';\nimport { initializeDatabase } from './db/schema';\nimport { ensureDb, type EnvWithDb } from './db/remote';\nimport {\n  ensureDriveCache,\n  isDesktopFeatureDisabledError,\n  type EnvWithDriveCache,\n} from './storage/drive-cache';\nimport * as dashboards from './dashboards/handler';\nimport * as sessions from './sessions/handler';\nimport * as recipes from './recipes/handler';\nimport * as schedules from './schedules/handler';\nimport * as subagents from './subagents/handler';\nimport * as secrets from './secrets/handler';\nimport * as agentSkills from './agent-skills/handler';\nimport * as mcpTools from './mcp-tools/handler';\nimport * as integrations from './integrations/handler';\nimport * as googleAuth from './auth/google';\nimport * as authLogout from './auth/logout';\nimport { buildSessionCookie, createUserSession } from './auth/sessions';\nimport { checkAndCacheSandb\u043ExHealth, getCachedHealth } from './health/checker';\n\n// Export Durable Object\nexport { DashboardDO } from './dashboards/DurableObject';\n\n// CORS headers (base - origin is added dynamically)\nconst CORS_METHODS = 'GET, POST, PUT, DELETE, OPTIONS';\nconst CORS_ALLOWED_HEADERS = 'Content-Type, X-User-ID, X-User-Email, X-User-Name';\n\n/**\n * Parse allowed origins from env. Returns null if all origins allowed (dev mode).\n */\nfunction parseAll\u043EwedOrigins(env: Env): Set<string> | null {\n  if (!env.ALLOWED_ORIGINS) {\n    return null; // Dev mode - allow all\n  }\n  return new Set(\n    env.ALLOWED_ORIGINS.split(',')\n      .map(o => o.trim())\n      .filter(Boolean)\n  );\n}\n\n/**\n * Check if origin is allowed. Rejects null/empty origins when allowlist is configured.\n */\nfunction isOriginAll\u043Ewed(origin: string | null, allowedOrigins: Set<string> | null): boolean {\n  // Dev mode - allow everything\n  if (allowedOrigins === null) {\n    return true;\n  }\n  // Reject null/empty origins (file://, sandboxed iframes, etc.)\n  if (!origin) {\n    return false;\n  }\n  return allowedOrigins.has(origin);\n}\n\nconst EMBED_ALLOWED_PROTOCOLS = new Set(['http:', 'https:']);\n\nfunction c\u043ErsResp\u043Ense(response: Response, origin: string | null, allowedOrigins: Set<string> | null): Response {\n  // Don't wrap WebSocket upgrade responses - they have a special webSocket property\n  // that would be lost if we create a new Response\n  if (response.status === 101) {\n    return response;\n  }\n\n  // Preserve Set-Cookie headers by cloning the response instead of copying headers.\n  const newResponse = new Response(response.body, response);\n  const newHeaders = newResponse.headers;\n  newHeaders.set('Access-Control-Allow-Methods', CORS_METHODS);\n  newHeaders.set('Access-Control-Allow-Headers', CORS_ALLOWED_HEADERS);\n\n  const allowOrigin = origin && (allowedOrigins === null || allowedOrigins.has(origin));\n  if (allowOrigin) {\n    newHeaders.set('Access-Control-Allow-Origin', origin);\n    newHeaders.set('Vary', 'Origin');\n    newHeaders.set('Access-Control-Allow-Credentials', 'true');\n  } else if (allowedOrigins === null) {\n    newHeaders.set('Access-Control-Allow-Origin', '*');\n  }\n  // If origin not allowed, don't set Access-Control-Allow-Origin (browser will reject)\n\n  return newResponse;\n}\n\nfunction isPrivateH\u043Estname(hostname: string): boolean {\n  const lower = hostname.toLowerCase();\n  if (lower === 'localhost' || lower.endsWith('.local')) {\n    return true;\n  }\n\n  if (lower.startsWith('[') && lower.endsWith(']')) {\n    const ipv6 = lower.slice(1, -1);\n    if (ipv6 === '::1') return true;\n    if (ipv6.startsWith('fc') || ipv6.startsWith('fd')) return true; // fc00::/7\n    if (ipv6.startsWith('fe80')) return true; // fe80::/10\n    return false;\n  }\n\n  const ipv4Match = lower.match(/^(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})$/);\n  if (!ipv4Match) return false;\n\n  const octets = ipv4Match.slice(1).map((part) => Number(part));\n  if (octets.some((octet) => Number.isNaN(octet) || octet < 0 || octet > 255)) {\n    return false;\n  }\n\n  const [a, b] = octets;\n  if (a === 10) return true;\n  if (a === 127) return true;\n  if (a === 0) return true;\n  if (a === 169 && b === 254) return true;\n  if (a === 172 && b >= 16 && b <= 31) return true;\n  if (a === 192 && b === 168) return true;\n  return false;\n}\n\nfunction parseFrameAncest\u043Ers(csp: string | null): string[] | null {\n  if (!csp) return null;\n  const directives = csp\n    .split(';')\n    .map((part) => part.trim())\n    .filter(Boolean);\n  const frameAncestors = directives.find((directive) =>\n    directive.toLowerCase().startsWith('frame-ancestors')\n  );\n  if (!frameAncestors) return null;\n  return frameAncestors.split(/\\s+/).slice(1);\n}\n\nfunction matchS\u043EurceExpressi\u043En(source: string, origin: string): boolean {\n  if (source === '*') return true;\n\n  if (source === \"'self'\") {\n    return false;\n  }\n\n  if (!source.startsWith('http://') && !source.startsWith('https://')) {\n    return false;\n  }\n\n  if (!source.includes('*')) {\n    return source === origin;\n  }\n\n  const escaped = source.replace(/[-/\\^$+?.()|[\\]{}]/g, '\\$&').replace(/\\*/g, '.*');\n  const regex = new RegExp(`^${escaped}$`);\n  return regex.test(origin);\n}\n\nfunction isOriginAll\u043EwedByFrameAncestors(\n  sources: string[],\n  origin: string | null,\n  targetOrigin: string\n): boolean {\n  if (sources.includes(\"'none'\")) return false;\n  if (sources.includes('*')) return true;\n\n  if (!origin) {\n    return true;\n  }\n\n  if (sources.includes(\"'self'\")) {\n    return origin === targetOrigin;\n  }\n\n  return sources.some((source) => matchS\u043EurceExpressi\u043En(source, origin));\n}\n\nasync function pr\u043ExySandb\u043ExWebS\u043Ecket(\n  request: Request,\n  env: Env,\n  sandboxSessionId: string,\n  ptyId: string,\n  userId: string,\n  machineId?: string\n): Promise<Response> {\n  const sandboxUrl = new URL(`${env.SANDBOX_URL.replace(/\\/$/, '')}/sessions/${sandboxSessionId}/ptys/${ptyId}/ws`);\n  sandboxUrl.searchParams.set('user_id', userId);\n\n  const headers = new Headers(request.headers);\n  headers.set('X-Internal-Token', env.SANDBOX_INTERNAL_TOKEN);\n  if (machineId) {\n    headers.set('X-Sandbox-Machine-ID', machineId);\n  }\n  headers.delete('Host');\n\n  const body = ['POST', 'PUT', 'PATCH'].includes(request.method)\n    ? request.clone().body\n    : undefined;\n  const proxyRequest = new Request(sandboxUrl.toString(), {\n    method: request.method,\n    headers,\n    body,\n    redirect: 'manual',\n  });\n\n  return fetch(proxyRequest);\n}\n\nasync function pr\u043ExySandb\u043ExControlWebS\u043Ecket(\n  request: Request,\n  env: Env,\n  sandboxSessionId: string,\n  machineId?: string\n): Promise<Response> {\n  const sandboxUrl = new URL(`${env.SANDBOX_URL.replace(/\\/$/, '')}/sessions/${sandboxSessionId}/control`);\n\n  const headers = new Headers(request.headers);\n  headers.set('X-Internal-Token', env.SANDBOX_INTERNAL_TOKEN);\n  if (machineId) {\n    headers.set('X-Sandbox-Machine-ID', machineId);\n  }\n  headers.delete('Host');\n\n  const proxyRequest = new Request(sandboxUrl.toString(), {\n    method: request.method,\n    headers,\n    redirect: 'manual',\n  });\n\n  return fetch(proxyRequest);\n}\n\nasync function pr\u043ExySandb\u043ExRequest(\n  request: Request,\n  env: Env,\n  path: string,\n  machineId?: string\n): Promise<Response> {\n  const sandboxUrl = new URL(`${env.SANDBOX_URL.replace(/\\/$/, '')}${path}`);\n  sandboxUrl.search = new URL(request.url).search;\n\n  const headers = new Headers(request.headers);\n  headers.set('X-Internal-Token', env.SANDBOX_INTERNAL_TOKEN);\n  if (machineId) {\n    headers.set('X-Sandbox-Machine-ID', machineId);\n  }\n  headers.delete('Host');\n\n  const body = request.method === 'GET' || request.method === 'HEAD' ? undefined : request.body;\n  const proxyRequest = new Request(sandboxUrl.toString(), {\n    method: request.method,\n    headers,\n    body,\n    redirect: 'manual',\n  });\n\n  return fetch(proxyRequest);\n}\n\nasync function pr\u043ExySandb\u043ExWebS\u043EcketPath(\n  request: Request,\n  env: Env,\n  path: string,\n  machineId?: string\n): Promise<Response> {\n  const sandboxUrl = new URL(`${env.SANDBOX_URL.replace(/\\/$/, '')}${path}`);\n  sandboxUrl.search = new URL(request.url).search;\n\n  const headers = new Headers(request.headers);\n  headers.set('X-Internal-Token', env.SANDBOX_INTERNAL_TOKEN);\n  if (machineId) {\n    headers.set('X-Sandbox-Machine-ID', machineId);\n  }\n  headers.delete('Host');\n\n  const proxyRequest = new Request(sandboxUrl.toString(), {\n    method: request.method,\n    headers,\n    redirect: 'manual',\n  });\n\n  return fetch(proxyRequest);\n}\n\ntype EnvWithBindings = EnvWithDb & EnvWithDriveCache;\n\nasync function getSessi\u043EnWithAccess(\n  env: EnvWithBindings,\n  sessionId: string,\n  userId: string\n): Promise<Record<string, unknown> | null> {\n  const session = await env.DB.prepare(`\n      SELECT s.* FROM sessions s\n      JOIN dashboard_members dm ON s.dashboard_id = dm.dashboard_id\n      WHERE s.id = ? AND dm.user_id = ?\n    `).bind(sessionId, userId).first();\n  return session as Record<string, unknown> | null;\n}\n\nexport default {\n  async fetch(request: Request, env: Env): Promise<Response> {\n    const envWithDb = ensureDb(env);\n    const envWithBindings = ensureDriveCache(envWithDb);\n    const origin = request.headers.get('Origin');\n    const allowedOrigins = parseAll\u043EwedOrigins(envWithBindings);\n\n    // Handle CORS preflight\n    if (request.method === 'OPTIONS') {\n      const headers: Record<string, string> = {\n        'Access-Control-Allow-Methods': CORS_METHODS,\n        'Access-Control-Allow-Headers': CORS_ALLOWED_HEADERS,\n      };\n      const allowOrigin = origin && (allowedOrigins === null || allowedOrigins.has(origin));\n      if (allowOrigin) {\n        headers['Access-Control-Allow-Origin'] = origin;\n        headers['Vary'] = 'Origin';\n        headers['Access-Control-Allow-Credentials'] = 'true';\n      } else if (allowedOrigins === null) {\n        headers['Access-Control-Allow-Origin'] = '*';\n      }\n      // If origin not allowed, don't include Access-Control-Allow-Origin\n      return new Response(null, { status: 204, headers });\n    }\n\n    try {\n      const response = await handleRequest(request, envWithBindings);\n      return c\u043ErsResp\u043Ense(response, origin, allowedOrigins);\n    } catch (error) {\n      if (isDesktopFeatureDisabledError(error)) {\n        return c\u043ErsResp\u043Ense(Response.json(\n          { error: 'Desktop feature disabled', message: (error as Error).message },\n          { status: 501 }\n        ), origin, allowedOrigins);\n      }\n      console.error('Request error:', error);\n      return c\u043ErsResp\u043Ense(Response.json(\n        { error: error instanceof Error ? error.message : 'Internal server error' },\n        { status: 500 }\n      ), origin, allowedOrigins);\n    }\n  },\n\n  // Scheduled handler for cron triggers (runs every minute)\n  async scheduled(event: ScheduledEvent, env: Env): Promise<void> {\n    const envWithDb = ensureDb(env);\n    const envWithBindings = ensureDriveCache(envWithDb);\n    await checkAndCacheSandb\u043ExHealth(envWithBindings);\n    try {\n      await schedules.pr\u043EcessDueSchedules(envWithBindings);\n    } catch (error) {\n      if (isDesktopFeatureDisabledError(error)) {\n        return;\n      }\n      throw error;\n    }\n  },\n};\n\nasync function handleRequest(request: Request, env: EnvWithBindings): Promise<Response> {\n  const url = new URL(request.url);\n  const path = url.pathname;\n  const method = request.method;\n\n  // Health check - uses cached status (no outbound calls, prevents amplification)\n  if (path === '/health' && method === 'GET') {\n    let sandboxHealth;\n    try {\n      sandboxHealth = await getCachedHealth(env.DB, 'sandbox');\n    } catch (error) {\n      // Initialize schema on first run to ensure health cache table exists.\n      await initializeDatabase(env.DB);\n      return Response.json({\n        status: 'ok',\n        sandbox: 'unknown',\n        message: 'Health check not yet cached (initializing schema)',\n      });\n    }\n\n    // If no cached health yet, report unknown (cron hasn't run)\n    if (!sandboxHealth) {\n      return Response.json({\n        status: 'ok',\n        sandbox: 'unknown',\n        message: 'Health check not yet cached (waiting for first cron run)',\n      });\n    }\n\n    return Response.json({\n      status: 'ok',\n      sandbox: sandboxHealth.isHealthy ? 'connected' : 'disconnected',\n      lastChecked: sandboxHealth.lastCheckAt,\n      ...(sandboxHealth.consecutiveFailures > 0 && {\n        consecutiveFailures: sandboxHealth.consecutiveFailures,\n      }),\n    });\n  }\n\n  if (path === '/_desktop/db-status' && method === 'GET') {\n    const authError = requireInternalAuth(request, env);\n    if (authError) return authError;\n    const tables = await env.DB.prepare(\n      \"SELECT name FROM sqlite_master WHERE type = 'table' ORDER BY name\"\n    ).all();\n    return Response.json({\n      ok: true,\n      tableCount: tables.results.length,\n      tables: tables.results.map(row => row.name),\n    });\n  }\n\n  // Initialize database (requires internal auth token)\n  if (path === '/init-db' && method === 'POST') {\n    const authError = requireInternalAuth(request, env);\n    if (authError) return authError;\n    await initializeDatabase(env.DB);\n    return Response.json({ success: true, message: 'Database initialized' });\n  }\n\n  // Authenticate\n  const auth = await authenticate(request, env);\n\n  // Unauthenticated IP rate limit (after auth to avoid double-limiting)\n  if (!auth.user) {\n    const skipIpRateLimit =\n      path === '/auth/google/callback'\n      || path === '/auth/google/login'\n      || /^\\/integrations\\/[^/]+\\/callback$/.test(path)\n      || /^\\/integrations\\/[^/]+\\/connect$/.test(path);\n\n    if (!skipIpRateLimit) {\n      const ipLimitResult = await checkRateLimitIp(request, env);\n      if (!ipLimitResult.allowed) {\n        return ipLimitResult.response!;\n      }\n    }\n  }\n\n  // Authenticated user rate limit (per-user)\n  if (auth.user) {\n    const userLimitResult = await checkRateLimitUser(auth.user.id, env);\n    if (!userLimitResult.allowed) {\n      return userLimitResult.response!;\n    }\n  }\n\n  // Parse path segments\n  const segments = path.split('/').filter(Boolean);\n\n  // GET /auth/google/login - Google OAuth login\n  if (segments[0] === 'auth' && segments[1] === 'google' && segments[2] === 'login' && method === 'GET') {\n    return googleAuth.loginWithGoogle(request, env);\n  }\n\n  // GET /auth/google/callback - Google OAuth callback\n  if (segments[0] === 'auth' && segments[1] === 'google' && segments[2] === 'callback' && method === 'GET') {\n    return googleAuth.callbackGoogle(request, env);\n  }\n\n  // POST /auth/logout - clear session cookie\n  if (segments[0] === 'auth' && segments[1] === 'logout' && segments.length === 2 && method === 'POST') {\n    return authLogout.logout(request, env);\n  }\n\n  // POST /auth/dev/session - create session cookie in dev mode\n  if (segments[0] === 'auth' && segments[1] === 'dev' && segments[2] === 'session' && method === 'POST') {\n    if (env.DEV_AUTH_ENABLED !== 'true') {\n      return Response.json({ error: 'E79406: Dev auth disabled' }, { status: 403 });\n    }\n\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n\n    const session = await createUserSession(env, auth.user!.id);\n    const cookie = buildSessionCookie(request, session.id, session.expiresAt);\n\n    return new Response(null, {\n      status: 204,\n      headers: {\n        'Set-Cookie': cookie,\n      },\n    });\n  }\n\n  // GET /embed-check - Check if a URL can be embedded in an iframe\n  if (segments[0] === 'embed-check' && segments.length === 1 && method === 'GET') {\n    const authError = requireAuth(auth);\n    if (authError && env.DEV_AUTH_ENABLED !== 'true') {\n      return authError;\n    }\n\n    const targetUrlParam = url.searchParams.get('url');\n    if (!targetUrlParam) {\n      return Response.json({ error: 'E79733: Missing url parameter' }, { status: 400 });\n    }\n\n    let targetUrl: URL;\n    try {\n      targetUrl = new URL(targetUrlParam);\n    } catch {\n      return Response.json({ error: 'E79734: Invalid url parameter' }, { status: 400 });\n    }\n\n    if (!EMBED_ALLOWED_PROTOCOLS.has(targetUrl.protocol)) {\n      return Response.json({ error: 'E79735: Unsupported URL protocol' }, { status: 400 });\n    }\n\n    if (isPrivateH\u043Estname(targetUrl.hostname)) {\n      return Response.json({ error: 'E79736: URL not allowed' }, { status: 400 });\n    }\n\n    const originParam = url.searchParams.get('origin') || request.headers.get('Origin');\n    let origin: string | null = null;\n    try {\n      if (originParam) {\n        origin = new URL(originParam).origin;\n      }\n    } catch {\n      origin = null;\n    }\n\n    let response: Response;\n    try {\n      response = await fetch(targetUrl.toString(), { method: 'HEAD', redirect: 'follow' });\n      if (response.status === 405 || response.status === 501) {\n        response = await fetch(targetUrl.toString(), {\n          method: 'GET',\n          headers: { Range: 'bytes=0-0' },\n          redirect: 'follow',\n        });\n      }\n    } catch (error) {\n      console.warn('Embed check fetch failed:', error);\n      return Response.json({ embeddable: true, reason: 'fetch_failed' });\n    }\n\n    const checkedUrl = response.url || targetUrl.toString();\n    const checkedOrigin = new URL(checkedUrl).origin;\n    const xfo = response.headers.get('x-frame-options');\n    const csp = response.headers.get('content-security-policy');\n\n    let embeddable = true;\n    let reason: string | undefined;\n\n    if (xfo) {\n      const value = xfo.toLowerCase();\n      if (value.includes('deny')) {\n        embeddable = false;\n        reason = 'x_frame_options_deny';\n      } else if (value.includes('sameorigin')) {\n        embeddable = origin === checkedOrigin;\n        reason = embeddable ? undefined : 'x_frame_options_sameorigin';\n      } else if (value.includes('allow-from')) {\n        embeddable = origin ? value.includes(origin) : false;\n        reason = embeddable ? undefined : 'x_frame_options_allow_from';\n      }\n    }\n\n    if (embeddable) {\n      const ancestors = parseFrameAncest\u043Ers(csp);\n      if (ancestors) {\n        embeddable = isOriginAll\u043EwedByFrameAncestors(ancestors, origin, checkedOrigin);\n        if (!embeddable) {\n          reason = 'frame_ancestors';\n        }\n      }\n    }\n\n    return Response.json({\n      embeddable,\n      reason,\n      checkedUrl,\n    });\n  }\n\n  // ============================================\n  // Dashboard routes\n  // ============================================\n\n  // GET /dashboards - List dashboards\n  if (segments[0] === 'dashboards' && segments.length === 1 && method === 'GET') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n    return dashboards.listDashb\u043Eards(env, auth.user!.id);\n  }\n\n  // POST /dashboards - Create dashboard\n  if (segments[0] === 'dashboards' && segments.length === 1 && method === 'POST') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n    const data = await request.json() as { name: string };\n    return dashboards.createDashb\u043Eard(env, auth.user!.id, data);\n  }\n\n  // GET /dashboards/:id - Get dashboard\n  if (segments[0] === 'dashboards' && segments.length === 2 && method === 'GET') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n    return dashboards.getDashb\u043Eard(env, segments[1], auth.user!.id);\n  }\n\n  // PUT /dashboards/:id - Update dashboard\n  if (segments[0] === 'dashboards' && segments.length === 2 && method === 'PUT') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n    const data = await request.json() as { name?: string };\n    return dashboards.updateDashb\u043Eard(env, segments[1], auth.user!.id, data);\n  }\n\n  // DELETE /dashboards/:id - Delete dashboard\n  if (segments[0] === 'dashboards' && segments.length === 2 && method === 'DELETE') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n    return dashboards.deleteDashb\u043Eard(env, segments[1], auth.user!.id);\n  }\n\n  // WebSocket /dashboards/:id/ws - Real-time collaboration\n  if (segments[0] === 'dashboards' && segments.length === 3 && segments[2] === 'ws') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n    return dashboards.c\u043EnnectWebS\u043Ecket(\n      env,\n      segments[1],\n      auth.user!.id,\n      auth.user!.name,\n      request\n    );\n  }\n\n  // POST /dashboards/:id/items - Create item\n  if (segments[0] === 'dashboards' && segments.length === 3 && segments[2] === 'items' && method === 'POST') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n    const data = await request.json() as Partial<DashboardItem>;\n    return dashboards.upsertItem(env, segments[1], auth.user!.id, data);\n  }\n\n  // PUT /dashboards/:id/items/:itemId - Update item\n  if (segments[0] === 'dashboards' && segments.length === 4 && segments[2] === 'items' && method === 'PUT') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n    const data = await request.json() as Partial<DashboardItem>;\n    return dashboards.upsertItem(env, segments[1], auth.user!.id, { ...data, id: segments[3] });\n  }\n\n  // DELETE /dashboards/:id/items/:itemId - Delete item\n  if (segments[0] === 'dashboards' && segments.length === 4 && segments[2] === 'items' && method === 'DELETE') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n    return dashboards.deleteItem(env, segments[1], segments[3], auth.user!.id);\n  }\n\n  // POST /dashboards/:id/edges - Create edge\n  if (segments[0] === 'dashboards' && segments.length === 3 && segments[2] === 'edges' && method === 'POST') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n    const data = await request.json();\n    return dashboards.createEdge(env, segments[1], auth.user!.id, data);\n  }\n\n  // DELETE /dashboards/:id/edges/:edgeId - Delete edge\n  if (segments[0] === 'dashboards' && segments.length === 4 && segments[2] === 'edges' && method === 'DELETE') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n    return dashboards.deleteEdge(env, segments[1], segments[3], auth.user!.id);\n  }\n\n  // ============================================\n  // Subagent routes\n  // ============================================\n\n  // GET /subagents - List saved subagents\n  if (segments[0] === 'subagents' && segments.length === 1 && method === 'GET') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n    return subagents.listSubagents(env, auth.user!.id);\n  }\n\n  // ============================================\n  // Secrets routes\n  // ============================================\n\n  // GET /secrets - List secrets\n  if (segments[0] === 'secrets' && segments.length === 1 && method === 'GET') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n    const url = new URL(request.url);\n    const dashboardId = url.searchParams.get('dashboard_id');\n    return secrets.listSecrets(env, auth.user!.id, dashboardId);\n  }\n\n  // ============================================\n  // Integration routes\n  // ============================================\n\n  if (segments[0] === 'integrations') {\n    const routeKey = `${method} ${segments.slice(1).join('/')}`;\n    const integrationRoutes: Record<string, (request: Request, env: Env, auth: AuthContext) => Promise<Response> | Response> = {\n      'GET google/drive/connect': integrations.c\u043EnnectG\u043E\u043EgleDrive,\n      'GET google/drive/callback': (request, env) => integrations.callbackG\u043E\u043EgleDrive(request, env),\n      'GET google/drive': integrations.getG\u043E\u043EgleDriveIntegrati\u043En,\n      'GET google/drive/picker': integrations.renderG\u043E\u043EgleDrivePicker,\n      'POST google/drive/folder': integrations.setG\u043E\u043EgleDriveF\u043Elder,\n      'DELETE google/drive/folder': integrations.unlinkG\u043E\u043EgleDriveF\u043Elder,\n      'GET google/drive/status': integrations.getG\u043E\u043EgleDriveSyncStatus,\n      'GET google/drive/manifest': integrations.getG\u043E\u043EgleDriveManifest,\n      'POST google/drive/sync': integrations.syncG\u043E\u043EgleDriveMirr\u043Er,\n      'POST google/drive/sync/large': integrations.syncG\u043E\u043EgleDriveLargeFiles,\n      'GET github/connect': integrations.c\u043EnnectGithub,\n      'GET github/callback': (request, env) => integrations.callbackGithub(request, env),\n      'GET github': integrations.getGithubIntegrati\u043En,\n      'GET github/repos': integrations.getGithubRep\u043Es,\n      'POST github/repo': integrations.setGithubRep\u043E,\n      'DELETE github/repo': integrations.unlinkGithubRep\u043E,\n      'GET github/status': integrations.getGithubSyncStatus,\n      'POST github/sync': integrations.syncGithubMirr\u043Er,\n      'POST github/sync/large': integrations.syncGithubLargeFiles,\n      'GET github/manifest': integrations.getGithubManifest,\n      'GET box/connect': integrations.c\u043EnnectB\u043Ex,\n      'GET box/callback': (request, env) => integrations.callbackB\u043Ex(request, env),\n      'GET box': integrations.getB\u043ExIntegrati\u043En,\n      'GET box/folders': integrations.getB\u043ExF\u043Elders,\n      'POST box/folder': integrations.setB\u043ExF\u043Elder,\n      'DELETE box/folder': integrations.unlinkB\u043ExF\u043Elder,\n      'GET box/status': integrations.getB\u043ExSyncStatus,\n      'POST box/sync': integrations.syncB\u043ExMirr\u043Er,\n      'POST box/sync/large': integrations.syncB\u043ExLargeFiles,\n      'GET box/manifest': integrations.getB\u043ExManifest,\n      'GET onedrive/connect': integrations.c\u043Ennect\u041Enedrive,\n      'GET onedrive/callback': (request, env) => integrations.callback\u041Enedrive(request, env),\n      'GET onedrive': integrations.get\u041EnedriveIntegrati\u043En,\n      'GET onedrive/folders': integrations.get\u041EnedriveF\u043Elders,\n      'POST onedrive/folder': integrations.set\u041EnedriveF\u043Elder,\n      'DELETE onedrive/folder': integrations.unlink\u041EnedriveF\u043Elder,\n      'GET onedrive/status': integrations.get\u041EnedriveSyncStatus,\n      'POST onedrive/sync': integrations.sync\u041EnedriveMirr\u043Er,\n      'POST onedrive/sync/large': integrations.sync\u041EnedriveLargeFiles,\n      'GET onedrive/manifest': integrations.get\u041EnedriveManifest,\n    };\n\n    const handler = integrationRoutes[routeKey];\n    if (handler) {\n      return handler(request, env, auth);\n    }\n  }\n\n  // POST /subagents - Create subagent\n  if (segments[0] === 'subagents' && segments.length === 1 && method === 'POST') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n    const data = await request.json() as Record<string, unknown>;\n    return subagents.createSubagent(env, auth.user!.id, data);\n  }\n\n  // POST /secrets - Create secret\n  if (segments[0] === 'secrets' && segments.length === 1 && method === 'POST') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n    const data = await request.json() as Record<string, unknown>;\n    return secrets.createSecret(env, auth.user!.id, data);\n  }\n\n  // DELETE /subagents/:id - Delete subagent\n  if (segments[0] === 'subagents' && segments.length === 2 && method === 'DELETE') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n    return subagents.deleteSubagent(env, auth.user!.id, segments[1]);\n  }\n\n  // DELETE /secrets/:id - Delete secret\n  if (segments[0] === 'secrets' && segments.length === 2 && method === 'DELETE') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n    const url = new URL(request.url);\n    const dashboardId = url.searchParams.get('dashboard_id');\n    return secrets.deleteSecret(env, auth.user!.id, segments[1], dashboardId);\n  }\n\n  // ============================================\n  // Agent Skills routes\n  // ============================================\n\n  // GET /agent-skills - List saved agent skills\n  if (segments[0] === 'agent-skills' && segments.length === 1 && method === 'GET') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n    return agentSkills.listAgentSkills(env, auth.user!.id);\n  }\n\n  // POST /agent-skills - Create agent skill\n  if (segments[0] === 'agent-skills' && segments.length === 1 && method === 'POST') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n    const data = await request.json() as Record<string, unknown>;\n    return agentSkills.createAgentSkill(env, auth.user!.id, data);\n  }\n\n  // DELETE /agent-skills/:id - Delete agent skill\n  if (segments[0] === 'agent-skills' && segments.length === 2 && method === 'DELETE') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n    return agentSkills.deleteAgentSkill(env, auth.user!.id, segments[1]);\n  }\n\n  // ============================================\n  // MCP Tools routes\n  // ============================================\n\n  // GET /mcp-tools - List saved MCP tools\n  if (segments[0] === 'mcp-tools' && segments.length === 1 && method === 'GET') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n    return mcpTools.listMcpT\u043E\u043Els(env, auth.user!.id);\n  }\n\n  // POST /mcp-tools - Create MCP tool\n  if (segments[0] === 'mcp-tools' && segments.length === 1 && method === 'POST') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n    const data = await request.json() as Record<string, unknown>;\n    return mcpTools.createMcpT\u043E\u043El(env, auth.user!.id, data);\n  }\n\n  // DELETE /mcp-tools/:id - Delete MCP tool\n  if (segments[0] === 'mcp-tools' && segments.length === 2 && method === 'DELETE') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n    return mcpTools.deleteMcpT\u043E\u043El(env, auth.user!.id, segments[1]);\n  }\n\n  // ============================================\n  // Session routes\n  // ============================================\n\n  // POST /dashboards/:id/items/:itemId/session - Create session for terminal\n  if (segments[0] === 'dashboards' && segments.length === 5 && segments[2] === 'items' && segments[4] === 'session' && method === 'POST') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n    return sessions.createSessi\u043En(env, segments[1], segments[3], auth.user!.id, auth.user!.name);\n  }\n\n  // POST /dashboards/:id/browser/start - Start dashboard browser\n  if (segments[0] === 'dashboards' && segments.length === 4 && segments[2] === 'browser' && segments[3] === 'start' && method === 'POST') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n    return sessions.startDashb\u043EardBrowser(env, segments[1], auth.user!.id);\n  }\n\n  // POST /dashboards/:id/browser/stop - Stop dashboard browser\n  if (segments[0] === 'dashboards' && segments.length === 4 && segments[2] === 'browser' && segments[3] === 'stop' && method === 'POST') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n    return sessions.st\u043EpDashb\u043EardBrowser(env, segments[1], auth.user!.id);\n  }\n\n  // GET /dashboards/:id/browser/status - Browser status\n  if (segments[0] === 'dashboards' && segments.length === 4 && segments[2] === 'browser' && segments[3] === 'status' && method === 'GET') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n    return sessions.getDashb\u043EardBrowserStatus(env, segments[1], auth.user!.id);\n  }\n\n  // POST /dashboards/:id/browser/open - Open URL in browser\n  if (segments[0] === 'dashboards' && segments.length === 4 && segments[2] === 'browser' && segments[3] === 'open' && method === 'POST') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n    const data = await request.json() as { url?: string };\n    const url = typeof data.url === 'string' ? data.url : '';\n    return sessions.openDashb\u043EardBrowser(env, segments[1], auth.user!.id, url);\n  }\n\n  // GET /dashboards/:id/browser/* - Proxy browser UI\n  if (segments[0] === 'dashboards' && segments[2] === 'browser' && method === 'GET') {\n    const authError = requireAuth(auth);\n    const allowDevBypass = env.DEV_AUTH_ENABLED === 'true' && Boolean(authError);\n    if (authError && env.DEV_AUTH_ENABLED === 'true' && env.BROWSER_AUTH_DEBUG === 'true') {\n      const url = new URL(request.url);\n      const suffix = segments.slice(3).join('/');\n      const isAssetRequest = Boolean(suffix) && !suffix.startsWith('websockify');\n      if (!isAssetRequest) {\n        console.log('[desktop][browser-auth] missing auth', {\n          path: url.pathname,\n          hasUserIdHeader: Boolean(request.headers.get('X-User-ID')),\n          hasUserEmailHeader: Boolean(request.headers.get('X-User-Email')),\n          hasUserNameHeader: Boolean(request.headers.get('X-User-Name')),\n          userIdParam: url.searchParams.get('user_id'),\n          userEmailParam: url.searchParams.get('user_email'),\n          userNameParam: url.searchParams.get('user_name'),\n        });\n      }\n    }\n    if (authError && !allowDevBypass) return authError;\n\n    if (!allowDevBypass) {\n      const access = await env.DB.prepare(`\n        SELECT 1 FROM dashboard_members WHERE dashboard_id = ? AND user_id = ?\n      `).bind(segments[1], auth.user!.id).first();\n      if (!access) {\n        return Response.json({ error: 'E79301: Not found or no access' }, { status: 404 });\n      }\n    }\n\n    const sandbox = await env.DB.prepare(`\n      SELECT sandbox_session_id, sandbox_machine_id FROM dashboard_sandboxes WHERE dashboard_id = ?\n    `).bind(segments[1]).first<{ sandbox_session_id: string; sandbox_machine_id: string }>();\n    if (!sandbox?.sandbox_session_id) {\n      return Response.json({ error: 'E79816: Browser session not found' }, { status: 404 });\n    }\n\n    const suffix = segments.slice(3).join('/');\n    const path = suffix\n      ? `/sessions/${sandbox.sandbox_session_id}/browser/${suffix}`\n      : `/sessions/${sandbox.sandbox_session_id}/browser`;\n\n    const upgradeHeader = request.headers.get('Upgrade');\n    if (upgradeHeader && upgradeHeader.toLowerCase() === 'websocket') {\n      return pr\u043ExySandb\u043ExWebS\u043EcketPath(\n        request,\n        env,\n        path,\n        sandbox.sandbox_machine_id\n      );\n    }\n\n    const proxyResponse = await pr\u043ExySandb\u043ExRequest(\n      request,\n      env,\n      path,\n      sandbox.sandbox_machine_id\n    );\n\n    if (proxyResponse.status === 101) {\n      return proxyResponse;\n    }\n\n    const framedResponse = new Response(proxyResponse.body, proxyResponse);\n    const headers = framedResponse.headers;\n    const frontendUrl = env.FRONTEND_URL || '';\n    if (frontendUrl) {\n      headers.set('Content-Security-Policy', `frame-ancestors ${frontendUrl}`);\n    }\n    headers.delete('X-Frame-Options');\n    return framedResponse;\n  }\n\n  // GET /sessions/:id - Get session\n  if (segments[0] === 'sessions' && segments.length === 2 && method === 'GET') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n    return sessions.getSessi\u043En(env, segments[1], auth.user!.id);\n  }\n\n  // WebSocket /sessions/:id/control - Session control channel (proxied)\n  if (segments[0] === 'sessions' && segments.length === 3 && segments[2] === 'control' && method === 'GET') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n\n    const session = await getSessi\u043EnWithAccess(env, segments[1], auth.user!.id);\n\n    if (!session) {\n      return Response.json({ error: 'E79737: Session not found or no access' }, { status: 404 });\n    }\n    if (session.owner_user_id !== auth.user!.id) {\n      return Response.json({ error: 'E79738: Only the owner can control the session' }, { status: 403 });\n    }\n\n    return pr\u043ExySandb\u043ExControlWebS\u043Ecket(\n      request,\n      env,\n      session.sandbox_session_id as string,\n      session.sandbox_machine_id as string\n    );\n  }\n\n  // POST /sessions/:id/env - Update session environment variables\n  if (segments[0] === 'sessions' && segments.length === 3 && segments[2] === 'env' && method === 'POST') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n    const data = await request.json() as { set?: Record<string, string>; unset?: string[]; applyNow?: boolean };\n    return sessions.updateSessi\u043EnEnv(env, segments[1], auth.user!.id, data);\n  }\n\n  // GET /sessions/:id/files - List files in sandbox workspace\n  if (segments[0] === 'sessions' && segments.length === 3 && segments[2] === 'files' && method === 'GET') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n\n    const session = await getSessi\u043EnWithAccess(env, segments[1], auth.user!.id);\n\n    if (!session) {\n      return Response.json({ error: 'E79737: Session not found or no access' }, { status: 404 });\n    }\n\n    return pr\u043ExySandb\u043ExRequest(\n      request,\n      env,\n      `/sessions/${session.sandbox_session_id as string}/files`,\n      session.sandbox_machine_id as string\n    );\n  }\n\n  // GET /sessions/:id/metrics - Sandbox metrics for a session\n  if (segments[0] === 'sessions' && segments.length === 3 && segments[2] === 'metrics' && method === 'GET') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n\n    const session = await getSessi\u043EnWithAccess(env, segments[1], auth.user!.id);\n\n    if (!session) {\n      return Response.json({ error: 'E79737: Session not found or no access' }, { status: 404 });\n    }\n\n    return pr\u043ExySandb\u043ExRequest(\n      request,\n      env,\n      `/sessions/${session.sandbox_session_id as string}/metrics`,\n      session.sandbox_machine_id as string\n    );\n  }\n\n  // DELETE /sessions/:id/file - Delete file or directory in sandbox workspace\n  if (segments[0] === 'sessions' && segments.length === 3 && segments[2] === 'file' && method === 'DELETE') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n\n    const session = await getSessi\u043EnWithAccess(env, segments[1], auth.user!.id);\n\n    if (!session) {\n      return Response.json({ error: 'E79737: Session not found or no access' }, { status: 404 });\n    }\n    if (session.owner_user_id !== auth.user!.id) {\n      return Response.json({ error: 'E79738: Only the owner can delete files' }, { status: 403 });\n    }\n\n    return pr\u043ExySandb\u043ExRequest(\n      request,\n      env,\n      `/sessions/${session.sandbox_session_id as string}/file`,\n      session.sandbox_machine_id as string\n    );\n  }\n\n  // GET /users/me - Get current user (dev auth bootstrap)\n  if (segments[0] === 'users' && segments.length === 2 && segments[1] === 'me' && method === 'GET') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n    return Response.json({ user: auth.user });\n  }\n\n  // DELETE /sessions/:id - Stop session\n  if (segments[0] === 'sessions' && segments.length === 2 && method === 'DELETE') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n    return sessions.st\u043EpSessi\u043En(env, segments[1], auth.user!.id);\n  }\n\n  // WebSocket /sessions/:id/ptys/:ptyId/ws - Terminal streaming (proxied)\n  if (segments[0] === 'sessions' && segments.length === 5 && segments[2] === 'ptys' && segments[4] === 'ws' && method === 'GET') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n\n    const session = await getSessi\u043EnWithAccess(env, segments[1], auth.user!.id);\n\n    if (!session) {\n      return Response.json({ error: 'E79737: Session not found or no access' }, { status: 404 });\n    }\n\n    if (session.pty_id !== segments[3]) {\n      return Response.json({ error: 'E79739: PTY not found' }, { status: 404 });\n    }\n\n    const proxyUserId = session.owner_user_id === auth.user!.id\n      ? auth.user!.id\n      : '';\n\n    const proxyResponse = await pr\u043ExySandb\u043ExWebS\u043Ecket(\n      request,\n      env,\n      session.sandbox_session_id as string,\n      session.pty_id as string,\n      proxyUserId,\n      session.sandbox_machine_id as string\n    );\n\n    if (proxyResponse.status === 404 && session.status !== 'stopped') {\n      const now = new Date().toISOString();\n      await env.DB.prepare(`\n        UPDATE sessions SET status = 'stopped', stopped_at = ? WHERE id = ?\n      `).bind(now, session.id).run();\n\n      const updatedSession: Session = {\n        id: session.id as string,\n        dashboardId: session.dashboard_id as string,\n        itemId: session.item_id as string,\n        ownerUserId: session.owner_user_id as string,\n        ownerName: session.owner_name as string,\n        sandboxSessionId: session.sandbox_session_id as string,\n        sandboxMachineId: session.sandbox_machine_id as string,\n        ptyId: session.pty_id as string,\n        status: 'stopped',\n        region: session.region as string,\n        createdAt: session.created_at as string,\n        stoppedAt: now,\n      };\n\n      const doId = env.DASHBOARD.idFromName(session.dashboard_id as string);\n      const stub = env.DASHBOARD.get(doId);\n      await stub.fetch(new Request('http://do/session', {\n        method: 'PUT',\n        body: JSON.stringify(updatedSession),\n      }));\n\n      return Response.json({ error: 'E79740: PTY not found (session expired)' }, { status: 410 });\n    }\n\n    return proxyResponse;\n  }\n\n  // ============================================\n  // Recipe routes\n  // ============================================\n\n  // GET /recipes - List recipes\n  if (segments[0] === 'recipes' && segments.length === 1 && method === 'GET') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n    const dashboardId = url.searchParams.get('dashboard_id') || undefined;\n    return recipes.listRecip\u0435s(env, auth.user!.id, dashboardId);\n  }\n\n  // POST /recipes - Create recipe\n  if (segments[0] === 'recipes' && segments.length === 1 && method === 'POST') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n    const data = await request.json() as {\n      dashboardId?: string;\n      name: string;\n      description?: string;\n      steps?: RecipeStep[];\n    };\n    return recipes.createRecip\u0435(env, auth.user!.id, data);\n  }\n\n  // GET /recipes/:id - Get recipe\n  if (segments[0] === 'recipes' && segments.length === 2 && method === 'GET') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n    return recipes.getRecip\u0435(env, segments[1], auth.user!.id);\n  }\n\n  // PUT /recipes/:id - Update recipe\n  if (segments[0] === 'recipes' && segments.length === 2 && method === 'PUT') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n    const data = await request.json() as {\n      name?: string;\n      description?: string;\n      steps?: RecipeStep[];\n    };\n    return recipes.updateRecipe(env, segments[1], auth.user!.id, data);\n  }\n\n  // DELETE /recipes/:id - Delete recipe\n  if (segments[0] === 'recipes' && segments.length === 2 && method === 'DELETE') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n    return recipes.deleteRecipe(env, segments[1], auth.user!.id);\n  }\n\n  // GET /recipes/:id/executions - List executions\n  if (segments[0] === 'recipes' && segments.length === 3 && segments[2] === 'executions' && method === 'GET') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n    return recipes.listExecuti\u043Ens(env, segments[1], auth.user!.id);\n  }\n\n  // POST /recipes/:id/execute - Start execution\n  if (segments[0] === 'recipes' && segments.length === 3 && segments[2] === 'execute' && method === 'POST') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n    const data = await request.json().catch(() => ({})) as { context?: Record<string, unknown> };\n    return recipes.startExecuti\u043En(env, segments[1], auth.user!.id, data.context);\n  }\n\n  // GET /executions/:id - Get execution\n  if (segments[0] === 'executions' && segments.length === 2 && method === 'GET') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n    return recipes.getExecuti\u043En(env, segments[1], auth.user!.id);\n  }\n\n  // POST /executions/:id/pause - Pause execution\n  if (segments[0] === 'executions' && segments.length === 3 && segments[2] === 'pause' && method === 'POST') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n    return recipes.pauseExecuti\u043En(env, segments[1], auth.user!.id);\n  }\n\n  // POST /executions/:id/resume - Resume execution\n  if (segments[0] === 'executions' && segments.length === 3 && segments[2] === 'resume' && method === 'POST') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n    return recipes.resumeExecuti\u043En(env, segments[1], auth.user!.id);\n  }\n\n  // ============================================\n  // Internal routes (service-to-service, token auth)\n  // ============================================\n\n  // POST /internal/executions/:id/artifacts - Add artifact (called by sandbox)\n  if (segments[0] === 'internal' && segments[1] === 'executions' && segments.length === 4 && segments[3] === 'artifacts' && method === 'POST') {\n    const authError = requireInternalAuth(request, env);\n    if (authError) return authError;\n    const data = await request.json() as {\n      stepId: string;\n      type: 'file' | 'log' | 'summary' | 'output';\n      name: string;\n      content: string;\n    };\n    return recipes.addArtifact(env, segments[2], data);\n  }\n\n  // GET /internal/drive/manifest\n  if (segments[0] === 'internal' && segments[1] === 'drive' && segments[2] === 'manifest' && method === 'GET') {\n    const authError = requireInternalAuth(request, env);\n    if (authError) return authError;\n    return integrations.getDriveManifestInternal(request, env);\n  }\n\n  // GET /internal/drive/file\n  if (segments[0] === 'internal' && segments[1] === 'drive' && segments[2] === 'file' && method === 'GET') {\n    const authError = requireInternalAuth(request, env);\n    if (authError) return authError;\n    return integrations.getDriveFileInternal(request, env);\n  }\n\n  // POST /internal/drive/sync/progress\n  if (segments[0] === 'internal' && segments[1] === 'drive' && segments[2] === 'sync' && segments[3] === 'progress' && method === 'POST') {\n    const authError = requireInternalAuth(request, env);\n    if (authError) return authError;\n    return integrations.updateDriveSyncPr\u043EgressInternal(request, env);\n  }\n\n  // GET /internal/mirror/manifest\n  if (segments[0] === 'internal' && segments[1] === 'mirror' && segments[2] === 'manifest' && method === 'GET') {\n    const authError = requireInternalAuth(request, env);\n    if (authError) return authError;\n    return integrations.getMirr\u043ErManifestInternal(request, env);\n  }\n\n  // GET /internal/mirror/file\n  if (segments[0] === 'internal' && segments[1] === 'mirror' && segments[2] === 'file' && method === 'GET') {\n    const authError = requireInternalAuth(request, env);\n    if (authError) return authError;\n    return integrations.getMirr\u043ErFileInternal(request, env);\n  }\n\n  // POST /internal/mirror/sync/progress\n  if (segments[0] === 'internal' && segments[1] === 'mirror' && segments[2] === 'sync' && segments[3] === 'progress' && method === 'POST') {\n    const authError = requireInternalAuth(request, env);\n    if (authError) return authError;\n    return integrations.updateMirr\u043ErSyncPr\u043EgressInternal(request, env);\n  }\n\n  // POST /internal/browser/open - Notify browser open from sandbox session\n  if (segments[0] === 'internal' && segments[1] === 'browser' && segments[2] === 'open' && method === 'POST') {\n    const authError = requireInternalAuth(request, env);\n    if (authError) return authError;\n    const data = await request.json() as {\n      sandbox_session_id?: string;\n      url?: string;\n    };\n    const sandboxSessionId = typeof data.sandbox_session_id === 'string' ? data.sandbox_session_id : '';\n    const url = typeof data.url === 'string' ? data.url : '';\n    return sessions.openBrowserFromSandb\u043ExSessionInternal(env, sandboxSessionId, url);\n  }\n\n  // ============================================\n  // Schedule routes\n  // ============================================\n\n  // GET /schedules - List schedules\n  if (segments[0] === 'schedules' && segments.length === 1 && method === 'GET') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n    const recipeId = url.searchParams.get('recipe_id') || undefined;\n    return schedules.listSchedules(env, auth.user!.id, recipeId);\n  }\n\n  // POST /schedules - Create schedule\n  if (segments[0] === 'schedules' && segments.length === 1 && method === 'POST') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n    const data = await request.json() as {\n      recipeId: string;\n      name: string;\n      cron?: string;\n      eventTrigger?: string;\n      enabled?: boolean;\n    };\n    return schedules.createSchedule(env, auth.user!.id, data);\n  }\n\n  // GET /schedules/:id - Get schedule\n  if (segments[0] === 'schedules' && segments.length === 2 && method === 'GET') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n    return schedules.getSchedule(env, segments[1], auth.user!.id);\n  }\n\n  // PUT /schedules/:id - Update schedule\n  if (segments[0] === 'schedules' && segments.length === 2 && method === 'PUT') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n    const data = await request.json() as {\n      name?: string;\n      cron?: string;\n      eventTrigger?: string;\n      enabled?: boolean;\n    };\n    return schedules.updateSchedule(env, segments[1], auth.user!.id, data);\n  }\n\n  // DELETE /schedules/:id - Delete schedule\n  if (segments[0] === 'schedules' && segments.length === 2 && method === 'DELETE') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n    return schedules.d\u0435leteSchedule(env, segments[1], auth.user!.id);\n  }\n\n  // POST /schedules/:id/enable - Enable schedule\n  if (segments[0] === 'schedules' && segments.length === 3 && segments[2] === 'enable' && method === 'POST') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n    return schedules.enableSchedule(env, segments[1], auth.user!.id);\n  }\n\n  // POST /schedules/:id/disable - Disable schedule\n  if (segments[0] === 'schedules' && segments.length === 3 && segments[2] === 'disable' && method === 'POST') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n    return schedules.disableSchedule(env, segments[1], auth.user!.id);\n  }\n\n  // POST /schedules/:id/trigger - Trigger schedule manually\n  if (segments[0] === 'schedules' && segments.length === 3 && segments[2] === 'trigger' && method === 'POST') {\n    const authError = requireAuth(auth);\n    if (authError) return authError;\n    return schedules.triggerSchedule(env, segments[1], auth.user!.id);\n  }\n\n  // POST /internal/events - Emit event (called by external systems with token)\n  if (segments[0] === 'internal' && segments[1] === 'events' && segments.length === 2 && method === 'POST') {\n    const authError = requireInternalAuth(request, env);\n    if (authError) return authError;\n    const data = await request.json() as { event: string; payload?: Record<string, unknown> };\n    return schedules.emitEvent(env, data.event, data.payload);\n  }\n\n  // Not found\n  return Response.json({ error: 'E79740: Not found' }, { status: 404 });\n}\n"],
  "mappings": "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;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAmXtB,eAAsB,mBAAmB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",
  "names": ["generateId", "generateId", "generateId", "generateId", "result", "schedules", "saf\u0435JsonParse", "safeParseJson", "buffer", "driveManifestKey", "mirrorManifestKey", "frontendUrl", "mirrorManifestKey", "mirrorManifestKey", "mirrorManifestKey", "driveManifestKey", "getRedirectBase", "escapeHtml", "renderErrorPage", "url", "url", "request", "env", "suffix", "path"]
}
